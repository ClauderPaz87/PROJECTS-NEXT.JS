"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/zod";
exports.ids = ["vendor-chunks/zod"];
exports.modules = {

/***/ "(ssr)/./node_modules/zod/lib/index.mjs":
/*!****************************************!*\
  !*** ./node_modules/zod/lib/index.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BRAND: () => (/* binding */ BRAND),\n/* harmony export */   DIRTY: () => (/* binding */ DIRTY),\n/* harmony export */   EMPTY_PATH: () => (/* binding */ EMPTY_PATH),\n/* harmony export */   INVALID: () => (/* binding */ INVALID),\n/* harmony export */   NEVER: () => (/* binding */ NEVER),\n/* harmony export */   OK: () => (/* binding */ OK),\n/* harmony export */   ParseStatus: () => (/* binding */ ParseStatus),\n/* harmony export */   Schema: () => (/* binding */ ZodType),\n/* harmony export */   ZodAny: () => (/* binding */ ZodAny),\n/* harmony export */   ZodArray: () => (/* binding */ ZodArray),\n/* harmony export */   ZodBigInt: () => (/* binding */ ZodBigInt),\n/* harmony export */   ZodBoolean: () => (/* binding */ ZodBoolean),\n/* harmony export */   ZodBranded: () => (/* binding */ ZodBranded),\n/* harmony export */   ZodCatch: () => (/* binding */ ZodCatch),\n/* harmony export */   ZodDate: () => (/* binding */ ZodDate),\n/* harmony export */   ZodDefault: () => (/* binding */ ZodDefault),\n/* harmony export */   ZodDiscriminatedUnion: () => (/* binding */ ZodDiscriminatedUnion),\n/* harmony export */   ZodEffects: () => (/* binding */ ZodEffects),\n/* harmony export */   ZodEnum: () => (/* binding */ ZodEnum),\n/* harmony export */   ZodError: () => (/* binding */ ZodError),\n/* harmony export */   ZodFirstPartyTypeKind: () => (/* binding */ ZodFirstPartyTypeKind),\n/* harmony export */   ZodFunction: () => (/* binding */ ZodFunction),\n/* harmony export */   ZodIntersection: () => (/* binding */ ZodIntersection),\n/* harmony export */   ZodIssueCode: () => (/* binding */ ZodIssueCode),\n/* harmony export */   ZodLazy: () => (/* binding */ ZodLazy),\n/* harmony export */   ZodLiteral: () => (/* binding */ ZodLiteral),\n/* harmony export */   ZodMap: () => (/* binding */ ZodMap),\n/* harmony export */   ZodNaN: () => (/* binding */ ZodNaN),\n/* harmony export */   ZodNativeEnum: () => (/* binding */ ZodNativeEnum),\n/* harmony export */   ZodNever: () => (/* binding */ ZodNever),\n/* harmony export */   ZodNull: () => (/* binding */ ZodNull),\n/* harmony export */   ZodNullable: () => (/* binding */ ZodNullable),\n/* harmony export */   ZodNumber: () => (/* binding */ ZodNumber),\n/* harmony export */   ZodObject: () => (/* binding */ ZodObject),\n/* harmony export */   ZodOptional: () => (/* binding */ ZodOptional),\n/* harmony export */   ZodParsedType: () => (/* binding */ ZodParsedType),\n/* harmony export */   ZodPipeline: () => (/* binding */ ZodPipeline),\n/* harmony export */   ZodPromise: () => (/* binding */ ZodPromise),\n/* harmony export */   ZodReadonly: () => (/* binding */ ZodReadonly),\n/* harmony export */   ZodRecord: () => (/* binding */ ZodRecord),\n/* harmony export */   ZodSchema: () => (/* binding */ ZodType),\n/* harmony export */   ZodSet: () => (/* binding */ ZodSet),\n/* harmony export */   ZodString: () => (/* binding */ ZodString),\n/* harmony export */   ZodSymbol: () => (/* binding */ ZodSymbol),\n/* harmony export */   ZodTransformer: () => (/* binding */ ZodEffects),\n/* harmony export */   ZodTuple: () => (/* binding */ ZodTuple),\n/* harmony export */   ZodType: () => (/* binding */ ZodType),\n/* harmony export */   ZodUndefined: () => (/* binding */ ZodUndefined),\n/* harmony export */   ZodUnion: () => (/* binding */ ZodUnion),\n/* harmony export */   ZodUnknown: () => (/* binding */ ZodUnknown),\n/* harmony export */   ZodVoid: () => (/* binding */ ZodVoid),\n/* harmony export */   addIssueToContext: () => (/* binding */ addIssueToContext),\n/* harmony export */   any: () => (/* binding */ anyType),\n/* harmony export */   array: () => (/* binding */ arrayType),\n/* harmony export */   bigint: () => (/* binding */ bigIntType),\n/* harmony export */   boolean: () => (/* binding */ booleanType),\n/* harmony export */   coerce: () => (/* binding */ coerce),\n/* harmony export */   custom: () => (/* binding */ custom),\n/* harmony export */   date: () => (/* binding */ dateType),\n/* harmony export */   datetimeRegex: () => (/* binding */ datetimeRegex),\n/* harmony export */   \"default\": () => (/* binding */ z),\n/* harmony export */   defaultErrorMap: () => (/* binding */ errorMap),\n/* harmony export */   discriminatedUnion: () => (/* binding */ discriminatedUnionType),\n/* harmony export */   effect: () => (/* binding */ effectsType),\n/* harmony export */   \"enum\": () => (/* binding */ enumType),\n/* harmony export */   \"function\": () => (/* binding */ functionType),\n/* harmony export */   getErrorMap: () => (/* binding */ getErrorMap),\n/* harmony export */   getParsedType: () => (/* binding */ getParsedType),\n/* harmony export */   \"instanceof\": () => (/* binding */ instanceOfType),\n/* harmony export */   intersection: () => (/* binding */ intersectionType),\n/* harmony export */   isAborted: () => (/* binding */ isAborted),\n/* harmony export */   isAsync: () => (/* binding */ isAsync),\n/* harmony export */   isDirty: () => (/* binding */ isDirty),\n/* harmony export */   isValid: () => (/* binding */ isValid),\n/* harmony export */   late: () => (/* binding */ late),\n/* harmony export */   lazy: () => (/* binding */ lazyType),\n/* harmony export */   literal: () => (/* binding */ literalType),\n/* harmony export */   makeIssue: () => (/* binding */ makeIssue),\n/* harmony export */   map: () => (/* binding */ mapType),\n/* harmony export */   nan: () => (/* binding */ nanType),\n/* harmony export */   nativeEnum: () => (/* binding */ nativeEnumType),\n/* harmony export */   never: () => (/* binding */ neverType),\n/* harmony export */   \"null\": () => (/* binding */ nullType),\n/* harmony export */   nullable: () => (/* binding */ nullableType),\n/* harmony export */   number: () => (/* binding */ numberType),\n/* harmony export */   object: () => (/* binding */ objectType),\n/* harmony export */   objectUtil: () => (/* binding */ objectUtil),\n/* harmony export */   oboolean: () => (/* binding */ oboolean),\n/* harmony export */   onumber: () => (/* binding */ onumber),\n/* harmony export */   optional: () => (/* binding */ optionalType),\n/* harmony export */   ostring: () => (/* binding */ ostring),\n/* harmony export */   pipeline: () => (/* binding */ pipelineType),\n/* harmony export */   preprocess: () => (/* binding */ preprocessType),\n/* harmony export */   promise: () => (/* binding */ promiseType),\n/* harmony export */   quotelessJson: () => (/* binding */ quotelessJson),\n/* harmony export */   record: () => (/* binding */ recordType),\n/* harmony export */   set: () => (/* binding */ setType),\n/* harmony export */   setErrorMap: () => (/* binding */ setErrorMap),\n/* harmony export */   strictObject: () => (/* binding */ strictObjectType),\n/* harmony export */   string: () => (/* binding */ stringType),\n/* harmony export */   symbol: () => (/* binding */ symbolType),\n/* harmony export */   transformer: () => (/* binding */ effectsType),\n/* harmony export */   tuple: () => (/* binding */ tupleType),\n/* harmony export */   undefined: () => (/* binding */ undefinedType),\n/* harmony export */   union: () => (/* binding */ unionType),\n/* harmony export */   unknown: () => (/* binding */ unknownType),\n/* harmony export */   util: () => (/* binding */ util),\n/* harmony export */   \"void\": () => (/* binding */ voidType),\n/* harmony export */   z: () => (/* binding */ z)\n/* harmony export */ });\nvar util;\r\n(function (util) {\r\n    util.assertEqual = (val) => val;\r\n    function assertIs(_arg) { }\r\n    util.assertIs = assertIs;\r\n    function assertNever(_x) {\r\n        throw new Error();\r\n    }\r\n    util.assertNever = assertNever;\r\n    util.arrayToEnum = (items) => {\r\n        const obj = {};\r\n        for (const item of items) {\r\n            obj[item] = item;\r\n        }\r\n        return obj;\r\n    };\r\n    util.getValidEnumValues = (obj) => {\r\n        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\r\n        const filtered = {};\r\n        for (const k of validKeys) {\r\n            filtered[k] = obj[k];\r\n        }\r\n        return util.objectValues(filtered);\r\n    };\r\n    util.objectValues = (obj) => {\r\n        return util.objectKeys(obj).map(function (e) {\r\n            return obj[e];\r\n        });\r\n    };\r\n    util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\r\n        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban\r\n        : (object) => {\r\n            const keys = [];\r\n            for (const key in object) {\r\n                if (Object.prototype.hasOwnProperty.call(object, key)) {\r\n                    keys.push(key);\r\n                }\r\n            }\r\n            return keys;\r\n        };\r\n    util.find = (arr, checker) => {\r\n        for (const item of arr) {\r\n            if (checker(item))\r\n                return item;\r\n        }\r\n        return undefined;\r\n    };\r\n    util.isInteger = typeof Number.isInteger === \"function\"\r\n        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban\r\n        : (val) => typeof val === \"number\" && isFinite(val) && Math.floor(val) === val;\r\n    function joinValues(array, separator = \" | \") {\r\n        return array\r\n            .map((val) => (typeof val === \"string\" ? `'${val}'` : val))\r\n            .join(separator);\r\n    }\r\n    util.joinValues = joinValues;\r\n    util.jsonStringifyReplacer = (_, value) => {\r\n        if (typeof value === \"bigint\") {\r\n            return value.toString();\r\n        }\r\n        return value;\r\n    };\r\n})(util || (util = {}));\r\nvar objectUtil;\r\n(function (objectUtil) {\r\n    objectUtil.mergeShapes = (first, second) => {\r\n        return {\r\n            ...first,\r\n            ...second, // second overwrites first\r\n        };\r\n    };\r\n})(objectUtil || (objectUtil = {}));\r\nconst ZodParsedType = util.arrayToEnum([\r\n    \"string\",\r\n    \"nan\",\r\n    \"number\",\r\n    \"integer\",\r\n    \"float\",\r\n    \"boolean\",\r\n    \"date\",\r\n    \"bigint\",\r\n    \"symbol\",\r\n    \"function\",\r\n    \"undefined\",\r\n    \"null\",\r\n    \"array\",\r\n    \"object\",\r\n    \"unknown\",\r\n    \"promise\",\r\n    \"void\",\r\n    \"never\",\r\n    \"map\",\r\n    \"set\",\r\n]);\r\nconst getParsedType = (data) => {\r\n    const t = typeof data;\r\n    switch (t) {\r\n        case \"undefined\":\r\n            return ZodParsedType.undefined;\r\n        case \"string\":\r\n            return ZodParsedType.string;\r\n        case \"number\":\r\n            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\r\n        case \"boolean\":\r\n            return ZodParsedType.boolean;\r\n        case \"function\":\r\n            return ZodParsedType.function;\r\n        case \"bigint\":\r\n            return ZodParsedType.bigint;\r\n        case \"symbol\":\r\n            return ZodParsedType.symbol;\r\n        case \"object\":\r\n            if (Array.isArray(data)) {\r\n                return ZodParsedType.array;\r\n            }\r\n            if (data === null) {\r\n                return ZodParsedType.null;\r\n            }\r\n            if (data.then &&\r\n                typeof data.then === \"function\" &&\r\n                data.catch &&\r\n                typeof data.catch === \"function\") {\r\n                return ZodParsedType.promise;\r\n            }\r\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\r\n                return ZodParsedType.map;\r\n            }\r\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\r\n                return ZodParsedType.set;\r\n            }\r\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\r\n                return ZodParsedType.date;\r\n            }\r\n            return ZodParsedType.object;\r\n        default:\r\n            return ZodParsedType.unknown;\r\n    }\r\n};\r\n\r\nconst ZodIssueCode = util.arrayToEnum([\r\n    \"invalid_type\",\r\n    \"invalid_literal\",\r\n    \"custom\",\r\n    \"invalid_union\",\r\n    \"invalid_union_discriminator\",\r\n    \"invalid_enum_value\",\r\n    \"unrecognized_keys\",\r\n    \"invalid_arguments\",\r\n    \"invalid_return_type\",\r\n    \"invalid_date\",\r\n    \"invalid_string\",\r\n    \"too_small\",\r\n    \"too_big\",\r\n    \"invalid_intersection_types\",\r\n    \"not_multiple_of\",\r\n    \"not_finite\",\r\n]);\r\nconst quotelessJson = (obj) => {\r\n    const json = JSON.stringify(obj, null, 2);\r\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\r\n};\r\nclass ZodError extends Error {\r\n    get errors() {\r\n        return this.issues;\r\n    }\r\n    constructor(issues) {\r\n        super();\r\n        this.issues = [];\r\n        this.addIssue = (sub) => {\r\n            this.issues = [...this.issues, sub];\r\n        };\r\n        this.addIssues = (subs = []) => {\r\n            this.issues = [...this.issues, ...subs];\r\n        };\r\n        const actualProto = new.target.prototype;\r\n        if (Object.setPrototypeOf) {\r\n            // eslint-disable-next-line ban/ban\r\n            Object.setPrototypeOf(this, actualProto);\r\n        }\r\n        else {\r\n            this.__proto__ = actualProto;\r\n        }\r\n        this.name = \"ZodError\";\r\n        this.issues = issues;\r\n    }\r\n    format(_mapper) {\r\n        const mapper = _mapper ||\r\n            function (issue) {\r\n                return issue.message;\r\n            };\r\n        const fieldErrors = { _errors: [] };\r\n        const processError = (error) => {\r\n            for (const issue of error.issues) {\r\n                if (issue.code === \"invalid_union\") {\r\n                    issue.unionErrors.map(processError);\r\n                }\r\n                else if (issue.code === \"invalid_return_type\") {\r\n                    processError(issue.returnTypeError);\r\n                }\r\n                else if (issue.code === \"invalid_arguments\") {\r\n                    processError(issue.argumentsError);\r\n                }\r\n                else if (issue.path.length === 0) {\r\n                    fieldErrors._errors.push(mapper(issue));\r\n                }\r\n                else {\r\n                    let curr = fieldErrors;\r\n                    let i = 0;\r\n                    while (i < issue.path.length) {\r\n                        const el = issue.path[i];\r\n                        const terminal = i === issue.path.length - 1;\r\n                        if (!terminal) {\r\n                            curr[el] = curr[el] || { _errors: [] };\r\n                            // if (typeof el === \"string\") {\r\n                            //   curr[el] = curr[el] || { _errors: [] };\r\n                            // } else if (typeof el === \"number\") {\r\n                            //   const errorArray: any = [];\r\n                            //   errorArray._errors = [];\r\n                            //   curr[el] = curr[el] || errorArray;\r\n                            // }\r\n                        }\r\n                        else {\r\n                            curr[el] = curr[el] || { _errors: [] };\r\n                            curr[el]._errors.push(mapper(issue));\r\n                        }\r\n                        curr = curr[el];\r\n                        i++;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        processError(this);\r\n        return fieldErrors;\r\n    }\r\n    static assert(value) {\r\n        if (!(value instanceof ZodError)) {\r\n            throw new Error(`Not a ZodError: ${value}`);\r\n        }\r\n    }\r\n    toString() {\r\n        return this.message;\r\n    }\r\n    get message() {\r\n        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\r\n    }\r\n    get isEmpty() {\r\n        return this.issues.length === 0;\r\n    }\r\n    flatten(mapper = (issue) => issue.message) {\r\n        const fieldErrors = {};\r\n        const formErrors = [];\r\n        for (const sub of this.issues) {\r\n            if (sub.path.length > 0) {\r\n                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\r\n                fieldErrors[sub.path[0]].push(mapper(sub));\r\n            }\r\n            else {\r\n                formErrors.push(mapper(sub));\r\n            }\r\n        }\r\n        return { formErrors, fieldErrors };\r\n    }\r\n    get formErrors() {\r\n        return this.flatten();\r\n    }\r\n}\r\nZodError.create = (issues) => {\r\n    const error = new ZodError(issues);\r\n    return error;\r\n};\r\n\r\nconst errorMap = (issue, _ctx) => {\r\n    let message;\r\n    switch (issue.code) {\r\n        case ZodIssueCode.invalid_type:\r\n            if (issue.received === ZodParsedType.undefined) {\r\n                message = \"Required\";\r\n            }\r\n            else {\r\n                message = `Expected ${issue.expected}, received ${issue.received}`;\r\n            }\r\n            break;\r\n        case ZodIssueCode.invalid_literal:\r\n            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\r\n            break;\r\n        case ZodIssueCode.unrecognized_keys:\r\n            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\r\n            break;\r\n        case ZodIssueCode.invalid_union:\r\n            message = `Invalid input`;\r\n            break;\r\n        case ZodIssueCode.invalid_union_discriminator:\r\n            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\r\n            break;\r\n        case ZodIssueCode.invalid_enum_value:\r\n            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\r\n            break;\r\n        case ZodIssueCode.invalid_arguments:\r\n            message = `Invalid function arguments`;\r\n            break;\r\n        case ZodIssueCode.invalid_return_type:\r\n            message = `Invalid function return type`;\r\n            break;\r\n        case ZodIssueCode.invalid_date:\r\n            message = `Invalid date`;\r\n            break;\r\n        case ZodIssueCode.invalid_string:\r\n            if (typeof issue.validation === \"object\") {\r\n                if (\"includes\" in issue.validation) {\r\n                    message = `Invalid input: must include \"${issue.validation.includes}\"`;\r\n                    if (typeof issue.validation.position === \"number\") {\r\n                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\r\n                    }\r\n                }\r\n                else if (\"startsWith\" in issue.validation) {\r\n                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\r\n                }\r\n                else if (\"endsWith\" in issue.validation) {\r\n                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\r\n                }\r\n                else {\r\n                    util.assertNever(issue.validation);\r\n                }\r\n            }\r\n            else if (issue.validation !== \"regex\") {\r\n                message = `Invalid ${issue.validation}`;\r\n            }\r\n            else {\r\n                message = \"Invalid\";\r\n            }\r\n            break;\r\n        case ZodIssueCode.too_small:\r\n            if (issue.type === \"array\")\r\n                message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\r\n            else if (issue.type === \"string\")\r\n                message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\r\n            else if (issue.type === \"number\")\r\n                message = `Number must be ${issue.exact\r\n                    ? `exactly equal to `\r\n                    : issue.inclusive\r\n                        ? `greater than or equal to `\r\n                        : `greater than `}${issue.minimum}`;\r\n            else if (issue.type === \"date\")\r\n                message = `Date must be ${issue.exact\r\n                    ? `exactly equal to `\r\n                    : issue.inclusive\r\n                        ? `greater than or equal to `\r\n                        : `greater than `}${new Date(Number(issue.minimum))}`;\r\n            else\r\n                message = \"Invalid input\";\r\n            break;\r\n        case ZodIssueCode.too_big:\r\n            if (issue.type === \"array\")\r\n                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\r\n            else if (issue.type === \"string\")\r\n                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\r\n            else if (issue.type === \"number\")\r\n                message = `Number must be ${issue.exact\r\n                    ? `exactly`\r\n                    : issue.inclusive\r\n                        ? `less than or equal to`\r\n                        : `less than`} ${issue.maximum}`;\r\n            else if (issue.type === \"bigint\")\r\n                message = `BigInt must be ${issue.exact\r\n                    ? `exactly`\r\n                    : issue.inclusive\r\n                        ? `less than or equal to`\r\n                        : `less than`} ${issue.maximum}`;\r\n            else if (issue.type === \"date\")\r\n                message = `Date must be ${issue.exact\r\n                    ? `exactly`\r\n                    : issue.inclusive\r\n                        ? `smaller than or equal to`\r\n                        : `smaller than`} ${new Date(Number(issue.maximum))}`;\r\n            else\r\n                message = \"Invalid input\";\r\n            break;\r\n        case ZodIssueCode.custom:\r\n            message = `Invalid input`;\r\n            break;\r\n        case ZodIssueCode.invalid_intersection_types:\r\n            message = `Intersection results could not be merged`;\r\n            break;\r\n        case ZodIssueCode.not_multiple_of:\r\n            message = `Number must be a multiple of ${issue.multipleOf}`;\r\n            break;\r\n        case ZodIssueCode.not_finite:\r\n            message = \"Number must be finite\";\r\n            break;\r\n        default:\r\n            message = _ctx.defaultError;\r\n            util.assertNever(issue);\r\n    }\r\n    return { message };\r\n};\r\n\r\nlet overrideErrorMap = errorMap;\r\nfunction setErrorMap(map) {\r\n    overrideErrorMap = map;\r\n}\r\nfunction getErrorMap() {\r\n    return overrideErrorMap;\r\n}\r\n\r\nconst makeIssue = (params) => {\r\n    const { data, path, errorMaps, issueData } = params;\r\n    const fullPath = [...path, ...(issueData.path || [])];\r\n    const fullIssue = {\r\n        ...issueData,\r\n        path: fullPath,\r\n    };\r\n    if (issueData.message !== undefined) {\r\n        return {\r\n            ...issueData,\r\n            path: fullPath,\r\n            message: issueData.message,\r\n        };\r\n    }\r\n    let errorMessage = \"\";\r\n    const maps = errorMaps\r\n        .filter((m) => !!m)\r\n        .slice()\r\n        .reverse();\r\n    for (const map of maps) {\r\n        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\r\n    }\r\n    return {\r\n        ...issueData,\r\n        path: fullPath,\r\n        message: errorMessage,\r\n    };\r\n};\r\nconst EMPTY_PATH = [];\r\nfunction addIssueToContext(ctx, issueData) {\r\n    const overrideMap = getErrorMap();\r\n    const issue = makeIssue({\r\n        issueData: issueData,\r\n        data: ctx.data,\r\n        path: ctx.path,\r\n        errorMaps: [\r\n            ctx.common.contextualErrorMap, // contextual error map is first priority\r\n            ctx.schemaErrorMap, // then schema-bound map if available\r\n            overrideMap, // then global override map\r\n            overrideMap === errorMap ? undefined : errorMap, // then global default map\r\n        ].filter((x) => !!x),\r\n    });\r\n    ctx.common.issues.push(issue);\r\n}\r\nclass ParseStatus {\r\n    constructor() {\r\n        this.value = \"valid\";\r\n    }\r\n    dirty() {\r\n        if (this.value === \"valid\")\r\n            this.value = \"dirty\";\r\n    }\r\n    abort() {\r\n        if (this.value !== \"aborted\")\r\n            this.value = \"aborted\";\r\n    }\r\n    static mergeArray(status, results) {\r\n        const arrayValue = [];\r\n        for (const s of results) {\r\n            if (s.status === \"aborted\")\r\n                return INVALID;\r\n            if (s.status === \"dirty\")\r\n                status.dirty();\r\n            arrayValue.push(s.value);\r\n        }\r\n        return { status: status.value, value: arrayValue };\r\n    }\r\n    static async mergeObjectAsync(status, pairs) {\r\n        const syncPairs = [];\r\n        for (const pair of pairs) {\r\n            const key = await pair.key;\r\n            const value = await pair.value;\r\n            syncPairs.push({\r\n                key,\r\n                value,\r\n            });\r\n        }\r\n        return ParseStatus.mergeObjectSync(status, syncPairs);\r\n    }\r\n    static mergeObjectSync(status, pairs) {\r\n        const finalObject = {};\r\n        for (const pair of pairs) {\r\n            const { key, value } = pair;\r\n            if (key.status === \"aborted\")\r\n                return INVALID;\r\n            if (value.status === \"aborted\")\r\n                return INVALID;\r\n            if (key.status === \"dirty\")\r\n                status.dirty();\r\n            if (value.status === \"dirty\")\r\n                status.dirty();\r\n            if (key.value !== \"__proto__\" &&\r\n                (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\r\n                finalObject[key.value] = value.value;\r\n            }\r\n        }\r\n        return { status: status.value, value: finalObject };\r\n    }\r\n}\r\nconst INVALID = Object.freeze({\r\n    status: \"aborted\",\r\n});\r\nconst DIRTY = (value) => ({ status: \"dirty\", value });\r\nconst OK = (value) => ({ status: \"valid\", value });\r\nconst isAborted = (x) => x.status === \"aborted\";\r\nconst isDirty = (x) => x.status === \"dirty\";\r\nconst isValid = (x) => x.status === \"valid\";\r\nconst isAsync = (x) => typeof Promise !== \"undefined\" && x instanceof Promise;\r\n\r\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nvar errorUtil;\r\n(function (errorUtil) {\r\n    errorUtil.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\r\n    errorUtil.toString = (message) => typeof message === \"string\" ? message : message === null || message === void 0 ? void 0 : message.message;\r\n})(errorUtil || (errorUtil = {}));\r\n\r\nvar _ZodEnum_cache, _ZodNativeEnum_cache;\r\nclass ParseInputLazyPath {\r\n    constructor(parent, value, path, key) {\r\n        this._cachedPath = [];\r\n        this.parent = parent;\r\n        this.data = value;\r\n        this._path = path;\r\n        this._key = key;\r\n    }\r\n    get path() {\r\n        if (!this._cachedPath.length) {\r\n            if (this._key instanceof Array) {\r\n                this._cachedPath.push(...this._path, ...this._key);\r\n            }\r\n            else {\r\n                this._cachedPath.push(...this._path, this._key);\r\n            }\r\n        }\r\n        return this._cachedPath;\r\n    }\r\n}\r\nconst handleResult = (ctx, result) => {\r\n    if (isValid(result)) {\r\n        return { success: true, data: result.value };\r\n    }\r\n    else {\r\n        if (!ctx.common.issues.length) {\r\n            throw new Error(\"Validation failed but no issues detected.\");\r\n        }\r\n        return {\r\n            success: false,\r\n            get error() {\r\n                if (this._error)\r\n                    return this._error;\r\n                const error = new ZodError(ctx.common.issues);\r\n                this._error = error;\r\n                return this._error;\r\n            },\r\n        };\r\n    }\r\n};\r\nfunction processCreateParams(params) {\r\n    if (!params)\r\n        return {};\r\n    const { errorMap, invalid_type_error, required_error, description } = params;\r\n    if (errorMap && (invalid_type_error || required_error)) {\r\n        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\r\n    }\r\n    if (errorMap)\r\n        return { errorMap: errorMap, description };\r\n    const customMap = (iss, ctx) => {\r\n        var _a, _b;\r\n        const { message } = params;\r\n        if (iss.code === \"invalid_enum_value\") {\r\n            return { message: message !== null && message !== void 0 ? message : ctx.defaultError };\r\n        }\r\n        if (typeof ctx.data === \"undefined\") {\r\n            return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };\r\n        }\r\n        if (iss.code !== \"invalid_type\")\r\n            return { message: ctx.defaultError };\r\n        return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };\r\n    };\r\n    return { errorMap: customMap, description };\r\n}\r\nclass ZodType {\r\n    get description() {\r\n        return this._def.description;\r\n    }\r\n    _getType(input) {\r\n        return getParsedType(input.data);\r\n    }\r\n    _getOrReturnCtx(input, ctx) {\r\n        return (ctx || {\r\n            common: input.parent.common,\r\n            data: input.data,\r\n            parsedType: getParsedType(input.data),\r\n            schemaErrorMap: this._def.errorMap,\r\n            path: input.path,\r\n            parent: input.parent,\r\n        });\r\n    }\r\n    _processInputParams(input) {\r\n        return {\r\n            status: new ParseStatus(),\r\n            ctx: {\r\n                common: input.parent.common,\r\n                data: input.data,\r\n                parsedType: getParsedType(input.data),\r\n                schemaErrorMap: this._def.errorMap,\r\n                path: input.path,\r\n                parent: input.parent,\r\n            },\r\n        };\r\n    }\r\n    _parseSync(input) {\r\n        const result = this._parse(input);\r\n        if (isAsync(result)) {\r\n            throw new Error(\"Synchronous parse encountered promise.\");\r\n        }\r\n        return result;\r\n    }\r\n    _parseAsync(input) {\r\n        const result = this._parse(input);\r\n        return Promise.resolve(result);\r\n    }\r\n    parse(data, params) {\r\n        const result = this.safeParse(data, params);\r\n        if (result.success)\r\n            return result.data;\r\n        throw result.error;\r\n    }\r\n    safeParse(data, params) {\r\n        var _a;\r\n        const ctx = {\r\n            common: {\r\n                issues: [],\r\n                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,\r\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\r\n            },\r\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\r\n            schemaErrorMap: this._def.errorMap,\r\n            parent: null,\r\n            data,\r\n            parsedType: getParsedType(data),\r\n        };\r\n        const result = this._parseSync({ data, path: ctx.path, parent: ctx });\r\n        return handleResult(ctx, result);\r\n    }\r\n    \"~validate\"(data) {\r\n        var _a, _b;\r\n        const ctx = {\r\n            common: {\r\n                issues: [],\r\n                async: !!this[\"~standard\"].async,\r\n            },\r\n            path: [],\r\n            schemaErrorMap: this._def.errorMap,\r\n            parent: null,\r\n            data,\r\n            parsedType: getParsedType(data),\r\n        };\r\n        if (!this[\"~standard\"].async) {\r\n            try {\r\n                const result = this._parseSync({ data, path: [], parent: ctx });\r\n                return isValid(result)\r\n                    ? {\r\n                        value: result.value,\r\n                    }\r\n                    : {\r\n                        issues: ctx.common.issues,\r\n                    };\r\n            }\r\n            catch (err) {\r\n                if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes(\"encountered\")) {\r\n                    this[\"~standard\"].async = true;\r\n                }\r\n                ctx.common = {\r\n                    issues: [],\r\n                    async: true,\r\n                };\r\n            }\r\n        }\r\n        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result)\r\n            ? {\r\n                value: result.value,\r\n            }\r\n            : {\r\n                issues: ctx.common.issues,\r\n            });\r\n    }\r\n    async parseAsync(data, params) {\r\n        const result = await this.safeParseAsync(data, params);\r\n        if (result.success)\r\n            return result.data;\r\n        throw result.error;\r\n    }\r\n    async safeParseAsync(data, params) {\r\n        const ctx = {\r\n            common: {\r\n                issues: [],\r\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\r\n                async: true,\r\n            },\r\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\r\n            schemaErrorMap: this._def.errorMap,\r\n            parent: null,\r\n            data,\r\n            parsedType: getParsedType(data),\r\n        };\r\n        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\r\n        const result = await (isAsync(maybeAsyncResult)\r\n            ? maybeAsyncResult\r\n            : Promise.resolve(maybeAsyncResult));\r\n        return handleResult(ctx, result);\r\n    }\r\n    refine(check, message) {\r\n        const getIssueProperties = (val) => {\r\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\r\n                return { message };\r\n            }\r\n            else if (typeof message === \"function\") {\r\n                return message(val);\r\n            }\r\n            else {\r\n                return message;\r\n            }\r\n        };\r\n        return this._refinement((val, ctx) => {\r\n            const result = check(val);\r\n            const setError = () => ctx.addIssue({\r\n                code: ZodIssueCode.custom,\r\n                ...getIssueProperties(val),\r\n            });\r\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\r\n                return result.then((data) => {\r\n                    if (!data) {\r\n                        setError();\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        return true;\r\n                    }\r\n                });\r\n            }\r\n            if (!result) {\r\n                setError();\r\n                return false;\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n        });\r\n    }\r\n    refinement(check, refinementData) {\r\n        return this._refinement((val, ctx) => {\r\n            if (!check(val)) {\r\n                ctx.addIssue(typeof refinementData === \"function\"\r\n                    ? refinementData(val, ctx)\r\n                    : refinementData);\r\n                return false;\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n        });\r\n    }\r\n    _refinement(refinement) {\r\n        return new ZodEffects({\r\n            schema: this,\r\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\r\n            effect: { type: \"refinement\", refinement },\r\n        });\r\n    }\r\n    superRefine(refinement) {\r\n        return this._refinement(refinement);\r\n    }\r\n    constructor(def) {\r\n        /** Alias of safeParseAsync */\r\n        this.spa = this.safeParseAsync;\r\n        this._def = def;\r\n        this.parse = this.parse.bind(this);\r\n        this.safeParse = this.safeParse.bind(this);\r\n        this.parseAsync = this.parseAsync.bind(this);\r\n        this.safeParseAsync = this.safeParseAsync.bind(this);\r\n        this.spa = this.spa.bind(this);\r\n        this.refine = this.refine.bind(this);\r\n        this.refinement = this.refinement.bind(this);\r\n        this.superRefine = this.superRefine.bind(this);\r\n        this.optional = this.optional.bind(this);\r\n        this.nullable = this.nullable.bind(this);\r\n        this.nullish = this.nullish.bind(this);\r\n        this.array = this.array.bind(this);\r\n        this.promise = this.promise.bind(this);\r\n        this.or = this.or.bind(this);\r\n        this.and = this.and.bind(this);\r\n        this.transform = this.transform.bind(this);\r\n        this.brand = this.brand.bind(this);\r\n        this.default = this.default.bind(this);\r\n        this.catch = this.catch.bind(this);\r\n        this.describe = this.describe.bind(this);\r\n        this.pipe = this.pipe.bind(this);\r\n        this.readonly = this.readonly.bind(this);\r\n        this.isNullable = this.isNullable.bind(this);\r\n        this.isOptional = this.isOptional.bind(this);\r\n        this[\"~standard\"] = {\r\n            version: 1,\r\n            vendor: \"zod\",\r\n            validate: (data) => this[\"~validate\"](data),\r\n        };\r\n    }\r\n    optional() {\r\n        return ZodOptional.create(this, this._def);\r\n    }\r\n    nullable() {\r\n        return ZodNullable.create(this, this._def);\r\n    }\r\n    nullish() {\r\n        return this.nullable().optional();\r\n    }\r\n    array() {\r\n        return ZodArray.create(this);\r\n    }\r\n    promise() {\r\n        return ZodPromise.create(this, this._def);\r\n    }\r\n    or(option) {\r\n        return ZodUnion.create([this, option], this._def);\r\n    }\r\n    and(incoming) {\r\n        return ZodIntersection.create(this, incoming, this._def);\r\n    }\r\n    transform(transform) {\r\n        return new ZodEffects({\r\n            ...processCreateParams(this._def),\r\n            schema: this,\r\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\r\n            effect: { type: \"transform\", transform },\r\n        });\r\n    }\r\n    default(def) {\r\n        const defaultValueFunc = typeof def === \"function\" ? def : () => def;\r\n        return new ZodDefault({\r\n            ...processCreateParams(this._def),\r\n            innerType: this,\r\n            defaultValue: defaultValueFunc,\r\n            typeName: ZodFirstPartyTypeKind.ZodDefault,\r\n        });\r\n    }\r\n    brand() {\r\n        return new ZodBranded({\r\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\r\n            type: this,\r\n            ...processCreateParams(this._def),\r\n        });\r\n    }\r\n    catch(def) {\r\n        const catchValueFunc = typeof def === \"function\" ? def : () => def;\r\n        return new ZodCatch({\r\n            ...processCreateParams(this._def),\r\n            innerType: this,\r\n            catchValue: catchValueFunc,\r\n            typeName: ZodFirstPartyTypeKind.ZodCatch,\r\n        });\r\n    }\r\n    describe(description) {\r\n        const This = this.constructor;\r\n        return new This({\r\n            ...this._def,\r\n            description,\r\n        });\r\n    }\r\n    pipe(target) {\r\n        return ZodPipeline.create(this, target);\r\n    }\r\n    readonly() {\r\n        return ZodReadonly.create(this);\r\n    }\r\n    isOptional() {\r\n        return this.safeParse(undefined).success;\r\n    }\r\n    isNullable() {\r\n        return this.safeParse(null).success;\r\n    }\r\n}\r\nconst cuidRegex = /^c[^\\s-]{8,}$/i;\r\nconst cuid2Regex = /^[0-9a-z]+$/;\r\nconst ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;\r\n// const uuidRegex =\r\n//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\r\nconst uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\r\nconst nanoidRegex = /^[a-z0-9_-]{21}$/i;\r\nconst jwtRegex = /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/;\r\nconst durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\r\n// from https://stackoverflow.com/a/46181/1550155\r\n// old version: too slow, didn't support unicode\r\n// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\r\n//old email regex\r\n// const emailRegex = /^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@((?!-)([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{1,})[^-<>()[\\].,;:\\s@\"]$/i;\r\n// eslint-disable-next-line\r\n// const emailRegex =\r\n//   /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$/;\r\n// const emailRegex =\r\n//   /^[a-zA-Z0-9\\.\\!\\#\\$\\%\\&\\'\\*\\+\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~\\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\r\n// const emailRegex =\r\n//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i;\r\nconst emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\r\n// const emailRegex =\r\n//   /^[a-z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\\.[a-z0-9\\-]+)*$/i;\r\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\r\nconst _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\r\nlet emojiRegex;\r\n// faster, simpler, safer\r\nconst ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\r\nconst ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/;\r\n// const ipv6Regex =\r\n// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\r\nconst ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;\r\nconst ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\r\n// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript\r\nconst base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\r\n// https://base64.guru/standards/base64url\r\nconst base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;\r\n// simple\r\n// const dateRegexSource = `\\\\d{4}-\\\\d{2}-\\\\d{2}`;\r\n// no leap year validation\r\n// const dateRegexSource = `\\\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\\\d|2\\\\d))`;\r\n// with leap year validation\r\nconst dateRegexSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\r\nconst dateRegex = new RegExp(`^${dateRegexSource}$`);\r\nfunction timeRegexSource(args) {\r\n    // let regex = `\\\\d{2}:\\\\d{2}:\\\\d{2}`;\r\n    let regex = `([01]\\\\d|2[0-3]):[0-5]\\\\d:[0-5]\\\\d`;\r\n    if (args.precision) {\r\n        regex = `${regex}\\\\.\\\\d{${args.precision}}`;\r\n    }\r\n    else if (args.precision == null) {\r\n        regex = `${regex}(\\\\.\\\\d+)?`;\r\n    }\r\n    return regex;\r\n}\r\nfunction timeRegex(args) {\r\n    return new RegExp(`^${timeRegexSource(args)}$`);\r\n}\r\n// Adapted from https://stackoverflow.com/a/3143231\r\nfunction datetimeRegex(args) {\r\n    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\r\n    const opts = [];\r\n    opts.push(args.local ? `Z?` : `Z`);\r\n    if (args.offset)\r\n        opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\r\n    regex = `${regex}(${opts.join(\"|\")})`;\r\n    return new RegExp(`^${regex}$`);\r\n}\r\nfunction isValidIP(ip, version) {\r\n    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\r\n        return true;\r\n    }\r\n    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nfunction isValidJWT(jwt, alg) {\r\n    if (!jwtRegex.test(jwt))\r\n        return false;\r\n    try {\r\n        const [header] = jwt.split(\".\");\r\n        // Convert base64url to base64\r\n        const base64 = header\r\n            .replace(/-/g, \"+\")\r\n            .replace(/_/g, \"/\")\r\n            .padEnd(header.length + ((4 - (header.length % 4)) % 4), \"=\");\r\n        const decoded = JSON.parse(atob(base64));\r\n        if (typeof decoded !== \"object\" || decoded === null)\r\n            return false;\r\n        if (!decoded.typ || !decoded.alg)\r\n            return false;\r\n        if (alg && decoded.alg !== alg)\r\n            return false;\r\n        return true;\r\n    }\r\n    catch (_a) {\r\n        return false;\r\n    }\r\n}\r\nfunction isValidCidr(ip, version) {\r\n    if ((version === \"v4\" || !version) && ipv4CidrRegex.test(ip)) {\r\n        return true;\r\n    }\r\n    if ((version === \"v6\" || !version) && ipv6CidrRegex.test(ip)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nclass ZodString extends ZodType {\r\n    _parse(input) {\r\n        if (this._def.coerce) {\r\n            input.data = String(input.data);\r\n        }\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.string) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.string,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        const status = new ParseStatus();\r\n        let ctx = undefined;\r\n        for (const check of this._def.checks) {\r\n            if (check.kind === \"min\") {\r\n                if (input.data.length < check.value) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.too_small,\r\n                        minimum: check.value,\r\n                        type: \"string\",\r\n                        inclusive: true,\r\n                        exact: false,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"max\") {\r\n                if (input.data.length > check.value) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.too_big,\r\n                        maximum: check.value,\r\n                        type: \"string\",\r\n                        inclusive: true,\r\n                        exact: false,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"length\") {\r\n                const tooBig = input.data.length > check.value;\r\n                const tooSmall = input.data.length < check.value;\r\n                if (tooBig || tooSmall) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    if (tooBig) {\r\n                        addIssueToContext(ctx, {\r\n                            code: ZodIssueCode.too_big,\r\n                            maximum: check.value,\r\n                            type: \"string\",\r\n                            inclusive: true,\r\n                            exact: true,\r\n                            message: check.message,\r\n                        });\r\n                    }\r\n                    else if (tooSmall) {\r\n                        addIssueToContext(ctx, {\r\n                            code: ZodIssueCode.too_small,\r\n                            minimum: check.value,\r\n                            type: \"string\",\r\n                            inclusive: true,\r\n                            exact: true,\r\n                            message: check.message,\r\n                        });\r\n                    }\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"email\") {\r\n                if (!emailRegex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"email\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"emoji\") {\r\n                if (!emojiRegex) {\r\n                    emojiRegex = new RegExp(_emojiRegex, \"u\");\r\n                }\r\n                if (!emojiRegex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"emoji\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"uuid\") {\r\n                if (!uuidRegex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"uuid\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"nanoid\") {\r\n                if (!nanoidRegex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"nanoid\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"cuid\") {\r\n                if (!cuidRegex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"cuid\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"cuid2\") {\r\n                if (!cuid2Regex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"cuid2\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"ulid\") {\r\n                if (!ulidRegex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"ulid\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"url\") {\r\n                try {\r\n                    new URL(input.data);\r\n                }\r\n                catch (_a) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"url\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"regex\") {\r\n                check.regex.lastIndex = 0;\r\n                const testResult = check.regex.test(input.data);\r\n                if (!testResult) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"regex\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"trim\") {\r\n                input.data = input.data.trim();\r\n            }\r\n            else if (check.kind === \"includes\") {\r\n                if (!input.data.includes(check.value, check.position)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.invalid_string,\r\n                        validation: { includes: check.value, position: check.position },\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"toLowerCase\") {\r\n                input.data = input.data.toLowerCase();\r\n            }\r\n            else if (check.kind === \"toUpperCase\") {\r\n                input.data = input.data.toUpperCase();\r\n            }\r\n            else if (check.kind === \"startsWith\") {\r\n                if (!input.data.startsWith(check.value)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.invalid_string,\r\n                        validation: { startsWith: check.value },\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"endsWith\") {\r\n                if (!input.data.endsWith(check.value)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.invalid_string,\r\n                        validation: { endsWith: check.value },\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"datetime\") {\r\n                const regex = datetimeRegex(check);\r\n                if (!regex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.invalid_string,\r\n                        validation: \"datetime\",\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"date\") {\r\n                const regex = dateRegex;\r\n                if (!regex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.invalid_string,\r\n                        validation: \"date\",\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"time\") {\r\n                const regex = timeRegex(check);\r\n                if (!regex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.invalid_string,\r\n                        validation: \"time\",\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"duration\") {\r\n                if (!durationRegex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"duration\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"ip\") {\r\n                if (!isValidIP(input.data, check.version)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"ip\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"jwt\") {\r\n                if (!isValidJWT(input.data, check.alg)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"jwt\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"cidr\") {\r\n                if (!isValidCidr(input.data, check.version)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"cidr\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"base64\") {\r\n                if (!base64Regex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"base64\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"base64url\") {\r\n                if (!base64urlRegex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"base64url\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else {\r\n                util.assertNever(check);\r\n            }\r\n        }\r\n        return { status: status.value, value: input.data };\r\n    }\r\n    _regex(regex, validation, message) {\r\n        return this.refinement((data) => regex.test(data), {\r\n            validation,\r\n            code: ZodIssueCode.invalid_string,\r\n            ...errorUtil.errToObj(message),\r\n        });\r\n    }\r\n    _addCheck(check) {\r\n        return new ZodString({\r\n            ...this._def,\r\n            checks: [...this._def.checks, check],\r\n        });\r\n    }\r\n    email(message) {\r\n        return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\r\n    }\r\n    url(message) {\r\n        return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\r\n    }\r\n    emoji(message) {\r\n        return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message) });\r\n    }\r\n    uuid(message) {\r\n        return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\r\n    }\r\n    nanoid(message) {\r\n        return this._addCheck({ kind: \"nanoid\", ...errorUtil.errToObj(message) });\r\n    }\r\n    cuid(message) {\r\n        return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\r\n    }\r\n    cuid2(message) {\r\n        return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message) });\r\n    }\r\n    ulid(message) {\r\n        return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message) });\r\n    }\r\n    base64(message) {\r\n        return this._addCheck({ kind: \"base64\", ...errorUtil.errToObj(message) });\r\n    }\r\n    base64url(message) {\r\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\r\n        return this._addCheck({\r\n            kind: \"base64url\",\r\n            ...errorUtil.errToObj(message),\r\n        });\r\n    }\r\n    jwt(options) {\r\n        return this._addCheck({ kind: \"jwt\", ...errorUtil.errToObj(options) });\r\n    }\r\n    ip(options) {\r\n        return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\r\n    }\r\n    cidr(options) {\r\n        return this._addCheck({ kind: \"cidr\", ...errorUtil.errToObj(options) });\r\n    }\r\n    datetime(options) {\r\n        var _a, _b;\r\n        if (typeof options === \"string\") {\r\n            return this._addCheck({\r\n                kind: \"datetime\",\r\n                precision: null,\r\n                offset: false,\r\n                local: false,\r\n                message: options,\r\n            });\r\n        }\r\n        return this._addCheck({\r\n            kind: \"datetime\",\r\n            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\r\n            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,\r\n            local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,\r\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\r\n        });\r\n    }\r\n    date(message) {\r\n        return this._addCheck({ kind: \"date\", message });\r\n    }\r\n    time(options) {\r\n        if (typeof options === \"string\") {\r\n            return this._addCheck({\r\n                kind: \"time\",\r\n                precision: null,\r\n                message: options,\r\n            });\r\n        }\r\n        return this._addCheck({\r\n            kind: \"time\",\r\n            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\r\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\r\n        });\r\n    }\r\n    duration(message) {\r\n        return this._addCheck({ kind: \"duration\", ...errorUtil.errToObj(message) });\r\n    }\r\n    regex(regex, message) {\r\n        return this._addCheck({\r\n            kind: \"regex\",\r\n            regex: regex,\r\n            ...errorUtil.errToObj(message),\r\n        });\r\n    }\r\n    includes(value, options) {\r\n        return this._addCheck({\r\n            kind: \"includes\",\r\n            value: value,\r\n            position: options === null || options === void 0 ? void 0 : options.position,\r\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\r\n        });\r\n    }\r\n    startsWith(value, message) {\r\n        return this._addCheck({\r\n            kind: \"startsWith\",\r\n            value: value,\r\n            ...errorUtil.errToObj(message),\r\n        });\r\n    }\r\n    endsWith(value, message) {\r\n        return this._addCheck({\r\n            kind: \"endsWith\",\r\n            value: value,\r\n            ...errorUtil.errToObj(message),\r\n        });\r\n    }\r\n    min(minLength, message) {\r\n        return this._addCheck({\r\n            kind: \"min\",\r\n            value: minLength,\r\n            ...errorUtil.errToObj(message),\r\n        });\r\n    }\r\n    max(maxLength, message) {\r\n        return this._addCheck({\r\n            kind: \"max\",\r\n            value: maxLength,\r\n            ...errorUtil.errToObj(message),\r\n        });\r\n    }\r\n    length(len, message) {\r\n        return this._addCheck({\r\n            kind: \"length\",\r\n            value: len,\r\n            ...errorUtil.errToObj(message),\r\n        });\r\n    }\r\n    /**\r\n     * Equivalent to `.min(1)`\r\n     */\r\n    nonempty(message) {\r\n        return this.min(1, errorUtil.errToObj(message));\r\n    }\r\n    trim() {\r\n        return new ZodString({\r\n            ...this._def,\r\n            checks: [...this._def.checks, { kind: \"trim\" }],\r\n        });\r\n    }\r\n    toLowerCase() {\r\n        return new ZodString({\r\n            ...this._def,\r\n            checks: [...this._def.checks, { kind: \"toLowerCase\" }],\r\n        });\r\n    }\r\n    toUpperCase() {\r\n        return new ZodString({\r\n            ...this._def,\r\n            checks: [...this._def.checks, { kind: \"toUpperCase\" }],\r\n        });\r\n    }\r\n    get isDatetime() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\r\n    }\r\n    get isDate() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"date\");\r\n    }\r\n    get isTime() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"time\");\r\n    }\r\n    get isDuration() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"duration\");\r\n    }\r\n    get isEmail() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"email\");\r\n    }\r\n    get isURL() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"url\");\r\n    }\r\n    get isEmoji() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\r\n    }\r\n    get isUUID() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\r\n    }\r\n    get isNANOID() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"nanoid\");\r\n    }\r\n    get isCUID() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\r\n    }\r\n    get isCUID2() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\r\n    }\r\n    get isULID() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\r\n    }\r\n    get isIP() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"ip\");\r\n    }\r\n    get isCIDR() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"cidr\");\r\n    }\r\n    get isBase64() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"base64\");\r\n    }\r\n    get isBase64url() {\r\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\r\n        return !!this._def.checks.find((ch) => ch.kind === \"base64url\");\r\n    }\r\n    get minLength() {\r\n        let min = null;\r\n        for (const ch of this._def.checks) {\r\n            if (ch.kind === \"min\") {\r\n                if (min === null || ch.value > min)\r\n                    min = ch.value;\r\n            }\r\n        }\r\n        return min;\r\n    }\r\n    get maxLength() {\r\n        let max = null;\r\n        for (const ch of this._def.checks) {\r\n            if (ch.kind === \"max\") {\r\n                if (max === null || ch.value < max)\r\n                    max = ch.value;\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n}\r\nZodString.create = (params) => {\r\n    var _a;\r\n    return new ZodString({\r\n        checks: [],\r\n        typeName: ZodFirstPartyTypeKind.ZodString,\r\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\r\nfunction floatSafeRemainder(val, step) {\r\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\r\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\r\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\r\n    const valInt = parseInt(val.toFixed(decCount).replace(\".\", \"\"));\r\n    const stepInt = parseInt(step.toFixed(decCount).replace(\".\", \"\"));\r\n    return (valInt % stepInt) / Math.pow(10, decCount);\r\n}\r\nclass ZodNumber extends ZodType {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.min = this.gte;\r\n        this.max = this.lte;\r\n        this.step = this.multipleOf;\r\n    }\r\n    _parse(input) {\r\n        if (this._def.coerce) {\r\n            input.data = Number(input.data);\r\n        }\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.number) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.number,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        let ctx = undefined;\r\n        const status = new ParseStatus();\r\n        for (const check of this._def.checks) {\r\n            if (check.kind === \"int\") {\r\n                if (!util.isInteger(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.invalid_type,\r\n                        expected: \"integer\",\r\n                        received: \"float\",\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"min\") {\r\n                const tooSmall = check.inclusive\r\n                    ? input.data < check.value\r\n                    : input.data <= check.value;\r\n                if (tooSmall) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.too_small,\r\n                        minimum: check.value,\r\n                        type: \"number\",\r\n                        inclusive: check.inclusive,\r\n                        exact: false,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"max\") {\r\n                const tooBig = check.inclusive\r\n                    ? input.data > check.value\r\n                    : input.data >= check.value;\r\n                if (tooBig) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.too_big,\r\n                        maximum: check.value,\r\n                        type: \"number\",\r\n                        inclusive: check.inclusive,\r\n                        exact: false,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"multipleOf\") {\r\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.not_multiple_of,\r\n                        multipleOf: check.value,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"finite\") {\r\n                if (!Number.isFinite(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.not_finite,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else {\r\n                util.assertNever(check);\r\n            }\r\n        }\r\n        return { status: status.value, value: input.data };\r\n    }\r\n    gte(value, message) {\r\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\r\n    }\r\n    gt(value, message) {\r\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\r\n    }\r\n    lte(value, message) {\r\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\r\n    }\r\n    lt(value, message) {\r\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\r\n    }\r\n    setLimit(kind, value, inclusive, message) {\r\n        return new ZodNumber({\r\n            ...this._def,\r\n            checks: [\r\n                ...this._def.checks,\r\n                {\r\n                    kind,\r\n                    value,\r\n                    inclusive,\r\n                    message: errorUtil.toString(message),\r\n                },\r\n            ],\r\n        });\r\n    }\r\n    _addCheck(check) {\r\n        return new ZodNumber({\r\n            ...this._def,\r\n            checks: [...this._def.checks, check],\r\n        });\r\n    }\r\n    int(message) {\r\n        return this._addCheck({\r\n            kind: \"int\",\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    positive(message) {\r\n        return this._addCheck({\r\n            kind: \"min\",\r\n            value: 0,\r\n            inclusive: false,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    negative(message) {\r\n        return this._addCheck({\r\n            kind: \"max\",\r\n            value: 0,\r\n            inclusive: false,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    nonpositive(message) {\r\n        return this._addCheck({\r\n            kind: \"max\",\r\n            value: 0,\r\n            inclusive: true,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    nonnegative(message) {\r\n        return this._addCheck({\r\n            kind: \"min\",\r\n            value: 0,\r\n            inclusive: true,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    multipleOf(value, message) {\r\n        return this._addCheck({\r\n            kind: \"multipleOf\",\r\n            value: value,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    finite(message) {\r\n        return this._addCheck({\r\n            kind: \"finite\",\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    safe(message) {\r\n        return this._addCheck({\r\n            kind: \"min\",\r\n            inclusive: true,\r\n            value: Number.MIN_SAFE_INTEGER,\r\n            message: errorUtil.toString(message),\r\n        })._addCheck({\r\n            kind: \"max\",\r\n            inclusive: true,\r\n            value: Number.MAX_SAFE_INTEGER,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    get minValue() {\r\n        let min = null;\r\n        for (const ch of this._def.checks) {\r\n            if (ch.kind === \"min\") {\r\n                if (min === null || ch.value > min)\r\n                    min = ch.value;\r\n            }\r\n        }\r\n        return min;\r\n    }\r\n    get maxValue() {\r\n        let max = null;\r\n        for (const ch of this._def.checks) {\r\n            if (ch.kind === \"max\") {\r\n                if (max === null || ch.value < max)\r\n                    max = ch.value;\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n    get isInt() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"int\" ||\r\n            (ch.kind === \"multipleOf\" && util.isInteger(ch.value)));\r\n    }\r\n    get isFinite() {\r\n        let max = null, min = null;\r\n        for (const ch of this._def.checks) {\r\n            if (ch.kind === \"finite\" ||\r\n                ch.kind === \"int\" ||\r\n                ch.kind === \"multipleOf\") {\r\n                return true;\r\n            }\r\n            else if (ch.kind === \"min\") {\r\n                if (min === null || ch.value > min)\r\n                    min = ch.value;\r\n            }\r\n            else if (ch.kind === \"max\") {\r\n                if (max === null || ch.value < max)\r\n                    max = ch.value;\r\n            }\r\n        }\r\n        return Number.isFinite(min) && Number.isFinite(max);\r\n    }\r\n}\r\nZodNumber.create = (params) => {\r\n    return new ZodNumber({\r\n        checks: [],\r\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\r\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodBigInt extends ZodType {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.min = this.gte;\r\n        this.max = this.lte;\r\n    }\r\n    _parse(input) {\r\n        if (this._def.coerce) {\r\n            try {\r\n                input.data = BigInt(input.data);\r\n            }\r\n            catch (_a) {\r\n                return this._getInvalidInput(input);\r\n            }\r\n        }\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.bigint) {\r\n            return this._getInvalidInput(input);\r\n        }\r\n        let ctx = undefined;\r\n        const status = new ParseStatus();\r\n        for (const check of this._def.checks) {\r\n            if (check.kind === \"min\") {\r\n                const tooSmall = check.inclusive\r\n                    ? input.data < check.value\r\n                    : input.data <= check.value;\r\n                if (tooSmall) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.too_small,\r\n                        type: \"bigint\",\r\n                        minimum: check.value,\r\n                        inclusive: check.inclusive,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"max\") {\r\n                const tooBig = check.inclusive\r\n                    ? input.data > check.value\r\n                    : input.data >= check.value;\r\n                if (tooBig) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.too_big,\r\n                        type: \"bigint\",\r\n                        maximum: check.value,\r\n                        inclusive: check.inclusive,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"multipleOf\") {\r\n                if (input.data % check.value !== BigInt(0)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.not_multiple_of,\r\n                        multipleOf: check.value,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else {\r\n                util.assertNever(check);\r\n            }\r\n        }\r\n        return { status: status.value, value: input.data };\r\n    }\r\n    _getInvalidInput(input) {\r\n        const ctx = this._getOrReturnCtx(input);\r\n        addIssueToContext(ctx, {\r\n            code: ZodIssueCode.invalid_type,\r\n            expected: ZodParsedType.bigint,\r\n            received: ctx.parsedType,\r\n        });\r\n        return INVALID;\r\n    }\r\n    gte(value, message) {\r\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\r\n    }\r\n    gt(value, message) {\r\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\r\n    }\r\n    lte(value, message) {\r\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\r\n    }\r\n    lt(value, message) {\r\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\r\n    }\r\n    setLimit(kind, value, inclusive, message) {\r\n        return new ZodBigInt({\r\n            ...this._def,\r\n            checks: [\r\n                ...this._def.checks,\r\n                {\r\n                    kind,\r\n                    value,\r\n                    inclusive,\r\n                    message: errorUtil.toString(message),\r\n                },\r\n            ],\r\n        });\r\n    }\r\n    _addCheck(check) {\r\n        return new ZodBigInt({\r\n            ...this._def,\r\n            checks: [...this._def.checks, check],\r\n        });\r\n    }\r\n    positive(message) {\r\n        return this._addCheck({\r\n            kind: \"min\",\r\n            value: BigInt(0),\r\n            inclusive: false,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    negative(message) {\r\n        return this._addCheck({\r\n            kind: \"max\",\r\n            value: BigInt(0),\r\n            inclusive: false,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    nonpositive(message) {\r\n        return this._addCheck({\r\n            kind: \"max\",\r\n            value: BigInt(0),\r\n            inclusive: true,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    nonnegative(message) {\r\n        return this._addCheck({\r\n            kind: \"min\",\r\n            value: BigInt(0),\r\n            inclusive: true,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    multipleOf(value, message) {\r\n        return this._addCheck({\r\n            kind: \"multipleOf\",\r\n            value,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    get minValue() {\r\n        let min = null;\r\n        for (const ch of this._def.checks) {\r\n            if (ch.kind === \"min\") {\r\n                if (min === null || ch.value > min)\r\n                    min = ch.value;\r\n            }\r\n        }\r\n        return min;\r\n    }\r\n    get maxValue() {\r\n        let max = null;\r\n        for (const ch of this._def.checks) {\r\n            if (ch.kind === \"max\") {\r\n                if (max === null || ch.value < max)\r\n                    max = ch.value;\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n}\r\nZodBigInt.create = (params) => {\r\n    var _a;\r\n    return new ZodBigInt({\r\n        checks: [],\r\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\r\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodBoolean extends ZodType {\r\n    _parse(input) {\r\n        if (this._def.coerce) {\r\n            input.data = Boolean(input.data);\r\n        }\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.boolean) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.boolean,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        return OK(input.data);\r\n    }\r\n}\r\nZodBoolean.create = (params) => {\r\n    return new ZodBoolean({\r\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\r\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodDate extends ZodType {\r\n    _parse(input) {\r\n        if (this._def.coerce) {\r\n            input.data = new Date(input.data);\r\n        }\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.date) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.date,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        if (isNaN(input.data.getTime())) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_date,\r\n            });\r\n            return INVALID;\r\n        }\r\n        const status = new ParseStatus();\r\n        let ctx = undefined;\r\n        for (const check of this._def.checks) {\r\n            if (check.kind === \"min\") {\r\n                if (input.data.getTime() < check.value) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.too_small,\r\n                        message: check.message,\r\n                        inclusive: true,\r\n                        exact: false,\r\n                        minimum: check.value,\r\n                        type: \"date\",\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"max\") {\r\n                if (input.data.getTime() > check.value) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.too_big,\r\n                        message: check.message,\r\n                        inclusive: true,\r\n                        exact: false,\r\n                        maximum: check.value,\r\n                        type: \"date\",\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else {\r\n                util.assertNever(check);\r\n            }\r\n        }\r\n        return {\r\n            status: status.value,\r\n            value: new Date(input.data.getTime()),\r\n        };\r\n    }\r\n    _addCheck(check) {\r\n        return new ZodDate({\r\n            ...this._def,\r\n            checks: [...this._def.checks, check],\r\n        });\r\n    }\r\n    min(minDate, message) {\r\n        return this._addCheck({\r\n            kind: \"min\",\r\n            value: minDate.getTime(),\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    max(maxDate, message) {\r\n        return this._addCheck({\r\n            kind: \"max\",\r\n            value: maxDate.getTime(),\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    get minDate() {\r\n        let min = null;\r\n        for (const ch of this._def.checks) {\r\n            if (ch.kind === \"min\") {\r\n                if (min === null || ch.value > min)\r\n                    min = ch.value;\r\n            }\r\n        }\r\n        return min != null ? new Date(min) : null;\r\n    }\r\n    get maxDate() {\r\n        let max = null;\r\n        for (const ch of this._def.checks) {\r\n            if (ch.kind === \"max\") {\r\n                if (max === null || ch.value < max)\r\n                    max = ch.value;\r\n            }\r\n        }\r\n        return max != null ? new Date(max) : null;\r\n    }\r\n}\r\nZodDate.create = (params) => {\r\n    return new ZodDate({\r\n        checks: [],\r\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\r\n        typeName: ZodFirstPartyTypeKind.ZodDate,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodSymbol extends ZodType {\r\n    _parse(input) {\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.symbol) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.symbol,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        return OK(input.data);\r\n    }\r\n}\r\nZodSymbol.create = (params) => {\r\n    return new ZodSymbol({\r\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodUndefined extends ZodType {\r\n    _parse(input) {\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.undefined) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.undefined,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        return OK(input.data);\r\n    }\r\n}\r\nZodUndefined.create = (params) => {\r\n    return new ZodUndefined({\r\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodNull extends ZodType {\r\n    _parse(input) {\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.null) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.null,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        return OK(input.data);\r\n    }\r\n}\r\nZodNull.create = (params) => {\r\n    return new ZodNull({\r\n        typeName: ZodFirstPartyTypeKind.ZodNull,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodAny extends ZodType {\r\n    constructor() {\r\n        super(...arguments);\r\n        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\r\n        this._any = true;\r\n    }\r\n    _parse(input) {\r\n        return OK(input.data);\r\n    }\r\n}\r\nZodAny.create = (params) => {\r\n    return new ZodAny({\r\n        typeName: ZodFirstPartyTypeKind.ZodAny,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodUnknown extends ZodType {\r\n    constructor() {\r\n        super(...arguments);\r\n        // required\r\n        this._unknown = true;\r\n    }\r\n    _parse(input) {\r\n        return OK(input.data);\r\n    }\r\n}\r\nZodUnknown.create = (params) => {\r\n    return new ZodUnknown({\r\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodNever extends ZodType {\r\n    _parse(input) {\r\n        const ctx = this._getOrReturnCtx(input);\r\n        addIssueToContext(ctx, {\r\n            code: ZodIssueCode.invalid_type,\r\n            expected: ZodParsedType.never,\r\n            received: ctx.parsedType,\r\n        });\r\n        return INVALID;\r\n    }\r\n}\r\nZodNever.create = (params) => {\r\n    return new ZodNever({\r\n        typeName: ZodFirstPartyTypeKind.ZodNever,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodVoid extends ZodType {\r\n    _parse(input) {\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.undefined) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.void,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        return OK(input.data);\r\n    }\r\n}\r\nZodVoid.create = (params) => {\r\n    return new ZodVoid({\r\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodArray extends ZodType {\r\n    _parse(input) {\r\n        const { ctx, status } = this._processInputParams(input);\r\n        const def = this._def;\r\n        if (ctx.parsedType !== ZodParsedType.array) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.array,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        if (def.exactLength !== null) {\r\n            const tooBig = ctx.data.length > def.exactLength.value;\r\n            const tooSmall = ctx.data.length < def.exactLength.value;\r\n            if (tooBig || tooSmall) {\r\n                addIssueToContext(ctx, {\r\n                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\r\n                    minimum: (tooSmall ? def.exactLength.value : undefined),\r\n                    maximum: (tooBig ? def.exactLength.value : undefined),\r\n                    type: \"array\",\r\n                    inclusive: true,\r\n                    exact: true,\r\n                    message: def.exactLength.message,\r\n                });\r\n                status.dirty();\r\n            }\r\n        }\r\n        if (def.minLength !== null) {\r\n            if (ctx.data.length < def.minLength.value) {\r\n                addIssueToContext(ctx, {\r\n                    code: ZodIssueCode.too_small,\r\n                    minimum: def.minLength.value,\r\n                    type: \"array\",\r\n                    inclusive: true,\r\n                    exact: false,\r\n                    message: def.minLength.message,\r\n                });\r\n                status.dirty();\r\n            }\r\n        }\r\n        if (def.maxLength !== null) {\r\n            if (ctx.data.length > def.maxLength.value) {\r\n                addIssueToContext(ctx, {\r\n                    code: ZodIssueCode.too_big,\r\n                    maximum: def.maxLength.value,\r\n                    type: \"array\",\r\n                    inclusive: true,\r\n                    exact: false,\r\n                    message: def.maxLength.message,\r\n                });\r\n                status.dirty();\r\n            }\r\n        }\r\n        if (ctx.common.async) {\r\n            return Promise.all([...ctx.data].map((item, i) => {\r\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\r\n            })).then((result) => {\r\n                return ParseStatus.mergeArray(status, result);\r\n            });\r\n        }\r\n        const result = [...ctx.data].map((item, i) => {\r\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\r\n        });\r\n        return ParseStatus.mergeArray(status, result);\r\n    }\r\n    get element() {\r\n        return this._def.type;\r\n    }\r\n    min(minLength, message) {\r\n        return new ZodArray({\r\n            ...this._def,\r\n            minLength: { value: minLength, message: errorUtil.toString(message) },\r\n        });\r\n    }\r\n    max(maxLength, message) {\r\n        return new ZodArray({\r\n            ...this._def,\r\n            maxLength: { value: maxLength, message: errorUtil.toString(message) },\r\n        });\r\n    }\r\n    length(len, message) {\r\n        return new ZodArray({\r\n            ...this._def,\r\n            exactLength: { value: len, message: errorUtil.toString(message) },\r\n        });\r\n    }\r\n    nonempty(message) {\r\n        return this.min(1, message);\r\n    }\r\n}\r\nZodArray.create = (schema, params) => {\r\n    return new ZodArray({\r\n        type: schema,\r\n        minLength: null,\r\n        maxLength: null,\r\n        exactLength: null,\r\n        typeName: ZodFirstPartyTypeKind.ZodArray,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nfunction deepPartialify(schema) {\r\n    if (schema instanceof ZodObject) {\r\n        const newShape = {};\r\n        for (const key in schema.shape) {\r\n            const fieldSchema = schema.shape[key];\r\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\r\n        }\r\n        return new ZodObject({\r\n            ...schema._def,\r\n            shape: () => newShape,\r\n        });\r\n    }\r\n    else if (schema instanceof ZodArray) {\r\n        return new ZodArray({\r\n            ...schema._def,\r\n            type: deepPartialify(schema.element),\r\n        });\r\n    }\r\n    else if (schema instanceof ZodOptional) {\r\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\r\n    }\r\n    else if (schema instanceof ZodNullable) {\r\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\r\n    }\r\n    else if (schema instanceof ZodTuple) {\r\n        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\r\n    }\r\n    else {\r\n        return schema;\r\n    }\r\n}\r\nclass ZodObject extends ZodType {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._cached = null;\r\n        /**\r\n         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\r\n         * If you want to pass through unknown properties, use `.passthrough()` instead.\r\n         */\r\n        this.nonstrict = this.passthrough;\r\n        // extend<\r\n        //   Augmentation extends ZodRawShape,\r\n        //   NewOutput extends util.flatten<{\r\n        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\r\n        //       ? Augmentation[k][\"_output\"]\r\n        //       : k extends keyof Output\r\n        //       ? Output[k]\r\n        //       : never;\r\n        //   }>,\r\n        //   NewInput extends util.flatten<{\r\n        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\r\n        //       ? Augmentation[k][\"_input\"]\r\n        //       : k extends keyof Input\r\n        //       ? Input[k]\r\n        //       : never;\r\n        //   }>\r\n        // >(\r\n        //   augmentation: Augmentation\r\n        // ): ZodObject<\r\n        //   extendShape<T, Augmentation>,\r\n        //   UnknownKeys,\r\n        //   Catchall,\r\n        //   NewOutput,\r\n        //   NewInput\r\n        // > {\r\n        //   return new ZodObject({\r\n        //     ...this._def,\r\n        //     shape: () => ({\r\n        //       ...this._def.shape(),\r\n        //       ...augmentation,\r\n        //     }),\r\n        //   }) as any;\r\n        // }\r\n        /**\r\n         * @deprecated Use `.extend` instead\r\n         *  */\r\n        this.augment = this.extend;\r\n    }\r\n    _getCached() {\r\n        if (this._cached !== null)\r\n            return this._cached;\r\n        const shape = this._def.shape();\r\n        const keys = util.objectKeys(shape);\r\n        return (this._cached = { shape, keys });\r\n    }\r\n    _parse(input) {\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.object) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.object,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        const { status, ctx } = this._processInputParams(input);\r\n        const { shape, keys: shapeKeys } = this._getCached();\r\n        const extraKeys = [];\r\n        if (!(this._def.catchall instanceof ZodNever &&\r\n            this._def.unknownKeys === \"strip\")) {\r\n            for (const key in ctx.data) {\r\n                if (!shapeKeys.includes(key)) {\r\n                    extraKeys.push(key);\r\n                }\r\n            }\r\n        }\r\n        const pairs = [];\r\n        for (const key of shapeKeys) {\r\n            const keyValidator = shape[key];\r\n            const value = ctx.data[key];\r\n            pairs.push({\r\n                key: { status: \"valid\", value: key },\r\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\r\n                alwaysSet: key in ctx.data,\r\n            });\r\n        }\r\n        if (this._def.catchall instanceof ZodNever) {\r\n            const unknownKeys = this._def.unknownKeys;\r\n            if (unknownKeys === \"passthrough\") {\r\n                for (const key of extraKeys) {\r\n                    pairs.push({\r\n                        key: { status: \"valid\", value: key },\r\n                        value: { status: \"valid\", value: ctx.data[key] },\r\n                    });\r\n                }\r\n            }\r\n            else if (unknownKeys === \"strict\") {\r\n                if (extraKeys.length > 0) {\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.unrecognized_keys,\r\n                        keys: extraKeys,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (unknownKeys === \"strip\") ;\r\n            else {\r\n                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\r\n            }\r\n        }\r\n        else {\r\n            // run catchall validation\r\n            const catchall = this._def.catchall;\r\n            for (const key of extraKeys) {\r\n                const value = ctx.data[key];\r\n                pairs.push({\r\n                    key: { status: \"valid\", value: key },\r\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\r\n                    ),\r\n                    alwaysSet: key in ctx.data,\r\n                });\r\n            }\r\n        }\r\n        if (ctx.common.async) {\r\n            return Promise.resolve()\r\n                .then(async () => {\r\n                const syncPairs = [];\r\n                for (const pair of pairs) {\r\n                    const key = await pair.key;\r\n                    const value = await pair.value;\r\n                    syncPairs.push({\r\n                        key,\r\n                        value,\r\n                        alwaysSet: pair.alwaysSet,\r\n                    });\r\n                }\r\n                return syncPairs;\r\n            })\r\n                .then((syncPairs) => {\r\n                return ParseStatus.mergeObjectSync(status, syncPairs);\r\n            });\r\n        }\r\n        else {\r\n            return ParseStatus.mergeObjectSync(status, pairs);\r\n        }\r\n    }\r\n    get shape() {\r\n        return this._def.shape();\r\n    }\r\n    strict(message) {\r\n        errorUtil.errToObj;\r\n        return new ZodObject({\r\n            ...this._def,\r\n            unknownKeys: \"strict\",\r\n            ...(message !== undefined\r\n                ? {\r\n                    errorMap: (issue, ctx) => {\r\n                        var _a, _b, _c, _d;\r\n                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;\r\n                        if (issue.code === \"unrecognized_keys\")\r\n                            return {\r\n                                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,\r\n                            };\r\n                        return {\r\n                            message: defaultError,\r\n                        };\r\n                    },\r\n                }\r\n                : {}),\r\n        });\r\n    }\r\n    strip() {\r\n        return new ZodObject({\r\n            ...this._def,\r\n            unknownKeys: \"strip\",\r\n        });\r\n    }\r\n    passthrough() {\r\n        return new ZodObject({\r\n            ...this._def,\r\n            unknownKeys: \"passthrough\",\r\n        });\r\n    }\r\n    // const AugmentFactory =\r\n    //   <Def extends ZodObjectDef>(def: Def) =>\r\n    //   <Augmentation extends ZodRawShape>(\r\n    //     augmentation: Augmentation\r\n    //   ): ZodObject<\r\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\r\n    //     Def[\"unknownKeys\"],\r\n    //     Def[\"catchall\"]\r\n    //   > => {\r\n    //     return new ZodObject({\r\n    //       ...def,\r\n    //       shape: () => ({\r\n    //         ...def.shape(),\r\n    //         ...augmentation,\r\n    //       }),\r\n    //     }) as any;\r\n    //   };\r\n    extend(augmentation) {\r\n        return new ZodObject({\r\n            ...this._def,\r\n            shape: () => ({\r\n                ...this._def.shape(),\r\n                ...augmentation,\r\n            }),\r\n        });\r\n    }\r\n    /**\r\n     * Prior to zod@1.0.12 there was a bug in the\r\n     * inferred type of merged objects. Please\r\n     * upgrade if you are experiencing issues.\r\n     */\r\n    merge(merging) {\r\n        const merged = new ZodObject({\r\n            unknownKeys: merging._def.unknownKeys,\r\n            catchall: merging._def.catchall,\r\n            shape: () => ({\r\n                ...this._def.shape(),\r\n                ...merging._def.shape(),\r\n            }),\r\n            typeName: ZodFirstPartyTypeKind.ZodObject,\r\n        });\r\n        return merged;\r\n    }\r\n    // merge<\r\n    //   Incoming extends AnyZodObject,\r\n    //   Augmentation extends Incoming[\"shape\"],\r\n    //   NewOutput extends {\r\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\r\n    //       ? Augmentation[k][\"_output\"]\r\n    //       : k extends keyof Output\r\n    //       ? Output[k]\r\n    //       : never;\r\n    //   },\r\n    //   NewInput extends {\r\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\r\n    //       ? Augmentation[k][\"_input\"]\r\n    //       : k extends keyof Input\r\n    //       ? Input[k]\r\n    //       : never;\r\n    //   }\r\n    // >(\r\n    //   merging: Incoming\r\n    // ): ZodObject<\r\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\r\n    //   Incoming[\"_def\"][\"unknownKeys\"],\r\n    //   Incoming[\"_def\"][\"catchall\"],\r\n    //   NewOutput,\r\n    //   NewInput\r\n    // > {\r\n    //   const merged: any = new ZodObject({\r\n    //     unknownKeys: merging._def.unknownKeys,\r\n    //     catchall: merging._def.catchall,\r\n    //     shape: () =>\r\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\r\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\r\n    //   }) as any;\r\n    //   return merged;\r\n    // }\r\n    setKey(key, schema) {\r\n        return this.augment({ [key]: schema });\r\n    }\r\n    // merge<Incoming extends AnyZodObject>(\r\n    //   merging: Incoming\r\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\r\n    // ZodObject<\r\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\r\n    //   Incoming[\"_def\"][\"unknownKeys\"],\r\n    //   Incoming[\"_def\"][\"catchall\"]\r\n    // > {\r\n    //   // const mergedShape = objectUtil.mergeShapes(\r\n    //   //   this._def.shape(),\r\n    //   //   merging._def.shape()\r\n    //   // );\r\n    //   const merged: any = new ZodObject({\r\n    //     unknownKeys: merging._def.unknownKeys,\r\n    //     catchall: merging._def.catchall,\r\n    //     shape: () =>\r\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\r\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\r\n    //   }) as any;\r\n    //   return merged;\r\n    // }\r\n    catchall(index) {\r\n        return new ZodObject({\r\n            ...this._def,\r\n            catchall: index,\r\n        });\r\n    }\r\n    pick(mask) {\r\n        const shape = {};\r\n        util.objectKeys(mask).forEach((key) => {\r\n            if (mask[key] && this.shape[key]) {\r\n                shape[key] = this.shape[key];\r\n            }\r\n        });\r\n        return new ZodObject({\r\n            ...this._def,\r\n            shape: () => shape,\r\n        });\r\n    }\r\n    omit(mask) {\r\n        const shape = {};\r\n        util.objectKeys(this.shape).forEach((key) => {\r\n            if (!mask[key]) {\r\n                shape[key] = this.shape[key];\r\n            }\r\n        });\r\n        return new ZodObject({\r\n            ...this._def,\r\n            shape: () => shape,\r\n        });\r\n    }\r\n    /**\r\n     * @deprecated\r\n     */\r\n    deepPartial() {\r\n        return deepPartialify(this);\r\n    }\r\n    partial(mask) {\r\n        const newShape = {};\r\n        util.objectKeys(this.shape).forEach((key) => {\r\n            const fieldSchema = this.shape[key];\r\n            if (mask && !mask[key]) {\r\n                newShape[key] = fieldSchema;\r\n            }\r\n            else {\r\n                newShape[key] = fieldSchema.optional();\r\n            }\r\n        });\r\n        return new ZodObject({\r\n            ...this._def,\r\n            shape: () => newShape,\r\n        });\r\n    }\r\n    required(mask) {\r\n        const newShape = {};\r\n        util.objectKeys(this.shape).forEach((key) => {\r\n            if (mask && !mask[key]) {\r\n                newShape[key] = this.shape[key];\r\n            }\r\n            else {\r\n                const fieldSchema = this.shape[key];\r\n                let newField = fieldSchema;\r\n                while (newField instanceof ZodOptional) {\r\n                    newField = newField._def.innerType;\r\n                }\r\n                newShape[key] = newField;\r\n            }\r\n        });\r\n        return new ZodObject({\r\n            ...this._def,\r\n            shape: () => newShape,\r\n        });\r\n    }\r\n    keyof() {\r\n        return createZodEnum(util.objectKeys(this.shape));\r\n    }\r\n}\r\nZodObject.create = (shape, params) => {\r\n    return new ZodObject({\r\n        shape: () => shape,\r\n        unknownKeys: \"strip\",\r\n        catchall: ZodNever.create(),\r\n        typeName: ZodFirstPartyTypeKind.ZodObject,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nZodObject.strictCreate = (shape, params) => {\r\n    return new ZodObject({\r\n        shape: () => shape,\r\n        unknownKeys: \"strict\",\r\n        catchall: ZodNever.create(),\r\n        typeName: ZodFirstPartyTypeKind.ZodObject,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nZodObject.lazycreate = (shape, params) => {\r\n    return new ZodObject({\r\n        shape,\r\n        unknownKeys: \"strip\",\r\n        catchall: ZodNever.create(),\r\n        typeName: ZodFirstPartyTypeKind.ZodObject,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodUnion extends ZodType {\r\n    _parse(input) {\r\n        const { ctx } = this._processInputParams(input);\r\n        const options = this._def.options;\r\n        function handleResults(results) {\r\n            // return first issue-free validation if it exists\r\n            for (const result of results) {\r\n                if (result.result.status === \"valid\") {\r\n                    return result.result;\r\n                }\r\n            }\r\n            for (const result of results) {\r\n                if (result.result.status === \"dirty\") {\r\n                    // add issues from dirty option\r\n                    ctx.common.issues.push(...result.ctx.common.issues);\r\n                    return result.result;\r\n                }\r\n            }\r\n            // return invalid\r\n            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_union,\r\n                unionErrors,\r\n            });\r\n            return INVALID;\r\n        }\r\n        if (ctx.common.async) {\r\n            return Promise.all(options.map(async (option) => {\r\n                const childCtx = {\r\n                    ...ctx,\r\n                    common: {\r\n                        ...ctx.common,\r\n                        issues: [],\r\n                    },\r\n                    parent: null,\r\n                };\r\n                return {\r\n                    result: await option._parseAsync({\r\n                        data: ctx.data,\r\n                        path: ctx.path,\r\n                        parent: childCtx,\r\n                    }),\r\n                    ctx: childCtx,\r\n                };\r\n            })).then(handleResults);\r\n        }\r\n        else {\r\n            let dirty = undefined;\r\n            const issues = [];\r\n            for (const option of options) {\r\n                const childCtx = {\r\n                    ...ctx,\r\n                    common: {\r\n                        ...ctx.common,\r\n                        issues: [],\r\n                    },\r\n                    parent: null,\r\n                };\r\n                const result = option._parseSync({\r\n                    data: ctx.data,\r\n                    path: ctx.path,\r\n                    parent: childCtx,\r\n                });\r\n                if (result.status === \"valid\") {\r\n                    return result;\r\n                }\r\n                else if (result.status === \"dirty\" && !dirty) {\r\n                    dirty = { result, ctx: childCtx };\r\n                }\r\n                if (childCtx.common.issues.length) {\r\n                    issues.push(childCtx.common.issues);\r\n                }\r\n            }\r\n            if (dirty) {\r\n                ctx.common.issues.push(...dirty.ctx.common.issues);\r\n                return dirty.result;\r\n            }\r\n            const unionErrors = issues.map((issues) => new ZodError(issues));\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_union,\r\n                unionErrors,\r\n            });\r\n            return INVALID;\r\n        }\r\n    }\r\n    get options() {\r\n        return this._def.options;\r\n    }\r\n}\r\nZodUnion.create = (types, params) => {\r\n    return new ZodUnion({\r\n        options: types,\r\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\n/////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////\r\n//////////                                 //////////\r\n//////////      ZodDiscriminatedUnion      //////////\r\n//////////                                 //////////\r\n/////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////\r\nconst getDiscriminator = (type) => {\r\n    if (type instanceof ZodLazy) {\r\n        return getDiscriminator(type.schema);\r\n    }\r\n    else if (type instanceof ZodEffects) {\r\n        return getDiscriminator(type.innerType());\r\n    }\r\n    else if (type instanceof ZodLiteral) {\r\n        return [type.value];\r\n    }\r\n    else if (type instanceof ZodEnum) {\r\n        return type.options;\r\n    }\r\n    else if (type instanceof ZodNativeEnum) {\r\n        // eslint-disable-next-line ban/ban\r\n        return util.objectValues(type.enum);\r\n    }\r\n    else if (type instanceof ZodDefault) {\r\n        return getDiscriminator(type._def.innerType);\r\n    }\r\n    else if (type instanceof ZodUndefined) {\r\n        return [undefined];\r\n    }\r\n    else if (type instanceof ZodNull) {\r\n        return [null];\r\n    }\r\n    else if (type instanceof ZodOptional) {\r\n        return [undefined, ...getDiscriminator(type.unwrap())];\r\n    }\r\n    else if (type instanceof ZodNullable) {\r\n        return [null, ...getDiscriminator(type.unwrap())];\r\n    }\r\n    else if (type instanceof ZodBranded) {\r\n        return getDiscriminator(type.unwrap());\r\n    }\r\n    else if (type instanceof ZodReadonly) {\r\n        return getDiscriminator(type.unwrap());\r\n    }\r\n    else if (type instanceof ZodCatch) {\r\n        return getDiscriminator(type._def.innerType);\r\n    }\r\n    else {\r\n        return [];\r\n    }\r\n};\r\nclass ZodDiscriminatedUnion extends ZodType {\r\n    _parse(input) {\r\n        const { ctx } = this._processInputParams(input);\r\n        if (ctx.parsedType !== ZodParsedType.object) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.object,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        const discriminator = this.discriminator;\r\n        const discriminatorValue = ctx.data[discriminator];\r\n        const option = this.optionsMap.get(discriminatorValue);\r\n        if (!option) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_union_discriminator,\r\n                options: Array.from(this.optionsMap.keys()),\r\n                path: [discriminator],\r\n            });\r\n            return INVALID;\r\n        }\r\n        if (ctx.common.async) {\r\n            return option._parseAsync({\r\n                data: ctx.data,\r\n                path: ctx.path,\r\n                parent: ctx,\r\n            });\r\n        }\r\n        else {\r\n            return option._parseSync({\r\n                data: ctx.data,\r\n                path: ctx.path,\r\n                parent: ctx,\r\n            });\r\n        }\r\n    }\r\n    get discriminator() {\r\n        return this._def.discriminator;\r\n    }\r\n    get options() {\r\n        return this._def.options;\r\n    }\r\n    get optionsMap() {\r\n        return this._def.optionsMap;\r\n    }\r\n    /**\r\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\r\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\r\n     * have a different value for each object in the union.\r\n     * @param discriminator the name of the discriminator property\r\n     * @param types an array of object schemas\r\n     * @param params\r\n     */\r\n    static create(discriminator, options, params) {\r\n        // Get all the valid discriminator values\r\n        const optionsMap = new Map();\r\n        // try {\r\n        for (const type of options) {\r\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\r\n            if (!discriminatorValues.length) {\r\n                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\r\n            }\r\n            for (const value of discriminatorValues) {\r\n                if (optionsMap.has(value)) {\r\n                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\r\n                }\r\n                optionsMap.set(value, type);\r\n            }\r\n        }\r\n        return new ZodDiscriminatedUnion({\r\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\r\n            discriminator,\r\n            options,\r\n            optionsMap,\r\n            ...processCreateParams(params),\r\n        });\r\n    }\r\n}\r\nfunction mergeValues(a, b) {\r\n    const aType = getParsedType(a);\r\n    const bType = getParsedType(b);\r\n    if (a === b) {\r\n        return { valid: true, data: a };\r\n    }\r\n    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\r\n        const bKeys = util.objectKeys(b);\r\n        const sharedKeys = util\r\n            .objectKeys(a)\r\n            .filter((key) => bKeys.indexOf(key) !== -1);\r\n        const newObj = { ...a, ...b };\r\n        for (const key of sharedKeys) {\r\n            const sharedValue = mergeValues(a[key], b[key]);\r\n            if (!sharedValue.valid) {\r\n                return { valid: false };\r\n            }\r\n            newObj[key] = sharedValue.data;\r\n        }\r\n        return { valid: true, data: newObj };\r\n    }\r\n    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\r\n        if (a.length !== b.length) {\r\n            return { valid: false };\r\n        }\r\n        const newArray = [];\r\n        for (let index = 0; index < a.length; index++) {\r\n            const itemA = a[index];\r\n            const itemB = b[index];\r\n            const sharedValue = mergeValues(itemA, itemB);\r\n            if (!sharedValue.valid) {\r\n                return { valid: false };\r\n            }\r\n            newArray.push(sharedValue.data);\r\n        }\r\n        return { valid: true, data: newArray };\r\n    }\r\n    else if (aType === ZodParsedType.date &&\r\n        bType === ZodParsedType.date &&\r\n        +a === +b) {\r\n        return { valid: true, data: a };\r\n    }\r\n    else {\r\n        return { valid: false };\r\n    }\r\n}\r\nclass ZodIntersection extends ZodType {\r\n    _parse(input) {\r\n        const { status, ctx } = this._processInputParams(input);\r\n        const handleParsed = (parsedLeft, parsedRight) => {\r\n            if (isAborted(parsedLeft) || isAborted(parsedRight)) {\r\n                return INVALID;\r\n            }\r\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\r\n            if (!merged.valid) {\r\n                addIssueToContext(ctx, {\r\n                    code: ZodIssueCode.invalid_intersection_types,\r\n                });\r\n                return INVALID;\r\n            }\r\n            if (isDirty(parsedLeft) || isDirty(parsedRight)) {\r\n                status.dirty();\r\n            }\r\n            return { status: status.value, value: merged.data };\r\n        };\r\n        if (ctx.common.async) {\r\n            return Promise.all([\r\n                this._def.left._parseAsync({\r\n                    data: ctx.data,\r\n                    path: ctx.path,\r\n                    parent: ctx,\r\n                }),\r\n                this._def.right._parseAsync({\r\n                    data: ctx.data,\r\n                    path: ctx.path,\r\n                    parent: ctx,\r\n                }),\r\n            ]).then(([left, right]) => handleParsed(left, right));\r\n        }\r\n        else {\r\n            return handleParsed(this._def.left._parseSync({\r\n                data: ctx.data,\r\n                path: ctx.path,\r\n                parent: ctx,\r\n            }), this._def.right._parseSync({\r\n                data: ctx.data,\r\n                path: ctx.path,\r\n                parent: ctx,\r\n            }));\r\n        }\r\n    }\r\n}\r\nZodIntersection.create = (left, right, params) => {\r\n    return new ZodIntersection({\r\n        left: left,\r\n        right: right,\r\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodTuple extends ZodType {\r\n    _parse(input) {\r\n        const { status, ctx } = this._processInputParams(input);\r\n        if (ctx.parsedType !== ZodParsedType.array) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.array,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        if (ctx.data.length < this._def.items.length) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.too_small,\r\n                minimum: this._def.items.length,\r\n                inclusive: true,\r\n                exact: false,\r\n                type: \"array\",\r\n            });\r\n            return INVALID;\r\n        }\r\n        const rest = this._def.rest;\r\n        if (!rest && ctx.data.length > this._def.items.length) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.too_big,\r\n                maximum: this._def.items.length,\r\n                inclusive: true,\r\n                exact: false,\r\n                type: \"array\",\r\n            });\r\n            status.dirty();\r\n        }\r\n        const items = [...ctx.data]\r\n            .map((item, itemIndex) => {\r\n            const schema = this._def.items[itemIndex] || this._def.rest;\r\n            if (!schema)\r\n                return null;\r\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\r\n        })\r\n            .filter((x) => !!x); // filter nulls\r\n        if (ctx.common.async) {\r\n            return Promise.all(items).then((results) => {\r\n                return ParseStatus.mergeArray(status, results);\r\n            });\r\n        }\r\n        else {\r\n            return ParseStatus.mergeArray(status, items);\r\n        }\r\n    }\r\n    get items() {\r\n        return this._def.items;\r\n    }\r\n    rest(rest) {\r\n        return new ZodTuple({\r\n            ...this._def,\r\n            rest,\r\n        });\r\n    }\r\n}\r\nZodTuple.create = (schemas, params) => {\r\n    if (!Array.isArray(schemas)) {\r\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\r\n    }\r\n    return new ZodTuple({\r\n        items: schemas,\r\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\r\n        rest: null,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodRecord extends ZodType {\r\n    get keySchema() {\r\n        return this._def.keyType;\r\n    }\r\n    get valueSchema() {\r\n        return this._def.valueType;\r\n    }\r\n    _parse(input) {\r\n        const { status, ctx } = this._processInputParams(input);\r\n        if (ctx.parsedType !== ZodParsedType.object) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.object,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        const pairs = [];\r\n        const keyType = this._def.keyType;\r\n        const valueType = this._def.valueType;\r\n        for (const key in ctx.data) {\r\n            pairs.push({\r\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\r\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\r\n                alwaysSet: key in ctx.data,\r\n            });\r\n        }\r\n        if (ctx.common.async) {\r\n            return ParseStatus.mergeObjectAsync(status, pairs);\r\n        }\r\n        else {\r\n            return ParseStatus.mergeObjectSync(status, pairs);\r\n        }\r\n    }\r\n    get element() {\r\n        return this._def.valueType;\r\n    }\r\n    static create(first, second, third) {\r\n        if (second instanceof ZodType) {\r\n            return new ZodRecord({\r\n                keyType: first,\r\n                valueType: second,\r\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\r\n                ...processCreateParams(third),\r\n            });\r\n        }\r\n        return new ZodRecord({\r\n            keyType: ZodString.create(),\r\n            valueType: first,\r\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\r\n            ...processCreateParams(second),\r\n        });\r\n    }\r\n}\r\nclass ZodMap extends ZodType {\r\n    get keySchema() {\r\n        return this._def.keyType;\r\n    }\r\n    get valueSchema() {\r\n        return this._def.valueType;\r\n    }\r\n    _parse(input) {\r\n        const { status, ctx } = this._processInputParams(input);\r\n        if (ctx.parsedType !== ZodParsedType.map) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.map,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        const keyType = this._def.keyType;\r\n        const valueType = this._def.valueType;\r\n        const pairs = [...ctx.data.entries()].map(([key, value], index) => {\r\n            return {\r\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\r\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"])),\r\n            };\r\n        });\r\n        if (ctx.common.async) {\r\n            const finalMap = new Map();\r\n            return Promise.resolve().then(async () => {\r\n                for (const pair of pairs) {\r\n                    const key = await pair.key;\r\n                    const value = await pair.value;\r\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\r\n                        return INVALID;\r\n                    }\r\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\r\n                        status.dirty();\r\n                    }\r\n                    finalMap.set(key.value, value.value);\r\n                }\r\n                return { status: status.value, value: finalMap };\r\n            });\r\n        }\r\n        else {\r\n            const finalMap = new Map();\r\n            for (const pair of pairs) {\r\n                const key = pair.key;\r\n                const value = pair.value;\r\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\r\n                    return INVALID;\r\n                }\r\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\r\n                    status.dirty();\r\n                }\r\n                finalMap.set(key.value, value.value);\r\n            }\r\n            return { status: status.value, value: finalMap };\r\n        }\r\n    }\r\n}\r\nZodMap.create = (keyType, valueType, params) => {\r\n    return new ZodMap({\r\n        valueType,\r\n        keyType,\r\n        typeName: ZodFirstPartyTypeKind.ZodMap,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodSet extends ZodType {\r\n    _parse(input) {\r\n        const { status, ctx } = this._processInputParams(input);\r\n        if (ctx.parsedType !== ZodParsedType.set) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.set,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        const def = this._def;\r\n        if (def.minSize !== null) {\r\n            if (ctx.data.size < def.minSize.value) {\r\n                addIssueToContext(ctx, {\r\n                    code: ZodIssueCode.too_small,\r\n                    minimum: def.minSize.value,\r\n                    type: \"set\",\r\n                    inclusive: true,\r\n                    exact: false,\r\n                    message: def.minSize.message,\r\n                });\r\n                status.dirty();\r\n            }\r\n        }\r\n        if (def.maxSize !== null) {\r\n            if (ctx.data.size > def.maxSize.value) {\r\n                addIssueToContext(ctx, {\r\n                    code: ZodIssueCode.too_big,\r\n                    maximum: def.maxSize.value,\r\n                    type: \"set\",\r\n                    inclusive: true,\r\n                    exact: false,\r\n                    message: def.maxSize.message,\r\n                });\r\n                status.dirty();\r\n            }\r\n        }\r\n        const valueType = this._def.valueType;\r\n        function finalizeSet(elements) {\r\n            const parsedSet = new Set();\r\n            for (const element of elements) {\r\n                if (element.status === \"aborted\")\r\n                    return INVALID;\r\n                if (element.status === \"dirty\")\r\n                    status.dirty();\r\n                parsedSet.add(element.value);\r\n            }\r\n            return { status: status.value, value: parsedSet };\r\n        }\r\n        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\r\n        if (ctx.common.async) {\r\n            return Promise.all(elements).then((elements) => finalizeSet(elements));\r\n        }\r\n        else {\r\n            return finalizeSet(elements);\r\n        }\r\n    }\r\n    min(minSize, message) {\r\n        return new ZodSet({\r\n            ...this._def,\r\n            minSize: { value: minSize, message: errorUtil.toString(message) },\r\n        });\r\n    }\r\n    max(maxSize, message) {\r\n        return new ZodSet({\r\n            ...this._def,\r\n            maxSize: { value: maxSize, message: errorUtil.toString(message) },\r\n        });\r\n    }\r\n    size(size, message) {\r\n        return this.min(size, message).max(size, message);\r\n    }\r\n    nonempty(message) {\r\n        return this.min(1, message);\r\n    }\r\n}\r\nZodSet.create = (valueType, params) => {\r\n    return new ZodSet({\r\n        valueType,\r\n        minSize: null,\r\n        maxSize: null,\r\n        typeName: ZodFirstPartyTypeKind.ZodSet,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodFunction extends ZodType {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.validate = this.implement;\r\n    }\r\n    _parse(input) {\r\n        const { ctx } = this._processInputParams(input);\r\n        if (ctx.parsedType !== ZodParsedType.function) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.function,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        function makeArgsIssue(args, error) {\r\n            return makeIssue({\r\n                data: args,\r\n                path: ctx.path,\r\n                errorMaps: [\r\n                    ctx.common.contextualErrorMap,\r\n                    ctx.schemaErrorMap,\r\n                    getErrorMap(),\r\n                    errorMap,\r\n                ].filter((x) => !!x),\r\n                issueData: {\r\n                    code: ZodIssueCode.invalid_arguments,\r\n                    argumentsError: error,\r\n                },\r\n            });\r\n        }\r\n        function makeReturnsIssue(returns, error) {\r\n            return makeIssue({\r\n                data: returns,\r\n                path: ctx.path,\r\n                errorMaps: [\r\n                    ctx.common.contextualErrorMap,\r\n                    ctx.schemaErrorMap,\r\n                    getErrorMap(),\r\n                    errorMap,\r\n                ].filter((x) => !!x),\r\n                issueData: {\r\n                    code: ZodIssueCode.invalid_return_type,\r\n                    returnTypeError: error,\r\n                },\r\n            });\r\n        }\r\n        const params = { errorMap: ctx.common.contextualErrorMap };\r\n        const fn = ctx.data;\r\n        if (this._def.returns instanceof ZodPromise) {\r\n            // Would love a way to avoid disabling this rule, but we need\r\n            // an alias (using an arrow function was what caused 2651).\r\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n            const me = this;\r\n            return OK(async function (...args) {\r\n                const error = new ZodError([]);\r\n                const parsedArgs = await me._def.args\r\n                    .parseAsync(args, params)\r\n                    .catch((e) => {\r\n                    error.addIssue(makeArgsIssue(args, e));\r\n                    throw error;\r\n                });\r\n                const result = await Reflect.apply(fn, this, parsedArgs);\r\n                const parsedReturns = await me._def.returns._def.type\r\n                    .parseAsync(result, params)\r\n                    .catch((e) => {\r\n                    error.addIssue(makeReturnsIssue(result, e));\r\n                    throw error;\r\n                });\r\n                return parsedReturns;\r\n            });\r\n        }\r\n        else {\r\n            // Would love a way to avoid disabling this rule, but we need\r\n            // an alias (using an arrow function was what caused 2651).\r\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n            const me = this;\r\n            return OK(function (...args) {\r\n                const parsedArgs = me._def.args.safeParse(args, params);\r\n                if (!parsedArgs.success) {\r\n                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\r\n                }\r\n                const result = Reflect.apply(fn, this, parsedArgs.data);\r\n                const parsedReturns = me._def.returns.safeParse(result, params);\r\n                if (!parsedReturns.success) {\r\n                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\r\n                }\r\n                return parsedReturns.data;\r\n            });\r\n        }\r\n    }\r\n    parameters() {\r\n        return this._def.args;\r\n    }\r\n    returnType() {\r\n        return this._def.returns;\r\n    }\r\n    args(...items) {\r\n        return new ZodFunction({\r\n            ...this._def,\r\n            args: ZodTuple.create(items).rest(ZodUnknown.create()),\r\n        });\r\n    }\r\n    returns(returnType) {\r\n        return new ZodFunction({\r\n            ...this._def,\r\n            returns: returnType,\r\n        });\r\n    }\r\n    implement(func) {\r\n        const validatedFunc = this.parse(func);\r\n        return validatedFunc;\r\n    }\r\n    strictImplement(func) {\r\n        const validatedFunc = this.parse(func);\r\n        return validatedFunc;\r\n    }\r\n    static create(args, returns, params) {\r\n        return new ZodFunction({\r\n            args: (args\r\n                ? args\r\n                : ZodTuple.create([]).rest(ZodUnknown.create())),\r\n            returns: returns || ZodUnknown.create(),\r\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\r\n            ...processCreateParams(params),\r\n        });\r\n    }\r\n}\r\nclass ZodLazy extends ZodType {\r\n    get schema() {\r\n        return this._def.getter();\r\n    }\r\n    _parse(input) {\r\n        const { ctx } = this._processInputParams(input);\r\n        const lazySchema = this._def.getter();\r\n        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\r\n    }\r\n}\r\nZodLazy.create = (getter, params) => {\r\n    return new ZodLazy({\r\n        getter: getter,\r\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodLiteral extends ZodType {\r\n    _parse(input) {\r\n        if (input.data !== this._def.value) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                received: ctx.data,\r\n                code: ZodIssueCode.invalid_literal,\r\n                expected: this._def.value,\r\n            });\r\n            return INVALID;\r\n        }\r\n        return { status: \"valid\", value: input.data };\r\n    }\r\n    get value() {\r\n        return this._def.value;\r\n    }\r\n}\r\nZodLiteral.create = (value, params) => {\r\n    return new ZodLiteral({\r\n        value: value,\r\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nfunction createZodEnum(values, params) {\r\n    return new ZodEnum({\r\n        values,\r\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\r\n        ...processCreateParams(params),\r\n    });\r\n}\r\nclass ZodEnum extends ZodType {\r\n    constructor() {\r\n        super(...arguments);\r\n        _ZodEnum_cache.set(this, void 0);\r\n    }\r\n    _parse(input) {\r\n        if (typeof input.data !== \"string\") {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            const expectedValues = this._def.values;\r\n            addIssueToContext(ctx, {\r\n                expected: util.joinValues(expectedValues),\r\n                received: ctx.parsedType,\r\n                code: ZodIssueCode.invalid_type,\r\n            });\r\n            return INVALID;\r\n        }\r\n        if (!__classPrivateFieldGet(this, _ZodEnum_cache, \"f\")) {\r\n            __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), \"f\");\r\n        }\r\n        if (!__classPrivateFieldGet(this, _ZodEnum_cache, \"f\").has(input.data)) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            const expectedValues = this._def.values;\r\n            addIssueToContext(ctx, {\r\n                received: ctx.data,\r\n                code: ZodIssueCode.invalid_enum_value,\r\n                options: expectedValues,\r\n            });\r\n            return INVALID;\r\n        }\r\n        return OK(input.data);\r\n    }\r\n    get options() {\r\n        return this._def.values;\r\n    }\r\n    get enum() {\r\n        const enumValues = {};\r\n        for (const val of this._def.values) {\r\n            enumValues[val] = val;\r\n        }\r\n        return enumValues;\r\n    }\r\n    get Values() {\r\n        const enumValues = {};\r\n        for (const val of this._def.values) {\r\n            enumValues[val] = val;\r\n        }\r\n        return enumValues;\r\n    }\r\n    get Enum() {\r\n        const enumValues = {};\r\n        for (const val of this._def.values) {\r\n            enumValues[val] = val;\r\n        }\r\n        return enumValues;\r\n    }\r\n    extract(values, newDef = this._def) {\r\n        return ZodEnum.create(values, {\r\n            ...this._def,\r\n            ...newDef,\r\n        });\r\n    }\r\n    exclude(values, newDef = this._def) {\r\n        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {\r\n            ...this._def,\r\n            ...newDef,\r\n        });\r\n    }\r\n}\r\n_ZodEnum_cache = new WeakMap();\r\nZodEnum.create = createZodEnum;\r\nclass ZodNativeEnum extends ZodType {\r\n    constructor() {\r\n        super(...arguments);\r\n        _ZodNativeEnum_cache.set(this, void 0);\r\n    }\r\n    _parse(input) {\r\n        const nativeEnumValues = util.getValidEnumValues(this._def.values);\r\n        const ctx = this._getOrReturnCtx(input);\r\n        if (ctx.parsedType !== ZodParsedType.string &&\r\n            ctx.parsedType !== ZodParsedType.number) {\r\n            const expectedValues = util.objectValues(nativeEnumValues);\r\n            addIssueToContext(ctx, {\r\n                expected: util.joinValues(expectedValues),\r\n                received: ctx.parsedType,\r\n                code: ZodIssueCode.invalid_type,\r\n            });\r\n            return INVALID;\r\n        }\r\n        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, \"f\")) {\r\n            __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), \"f\");\r\n        }\r\n        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, \"f\").has(input.data)) {\r\n            const expectedValues = util.objectValues(nativeEnumValues);\r\n            addIssueToContext(ctx, {\r\n                received: ctx.data,\r\n                code: ZodIssueCode.invalid_enum_value,\r\n                options: expectedValues,\r\n            });\r\n            return INVALID;\r\n        }\r\n        return OK(input.data);\r\n    }\r\n    get enum() {\r\n        return this._def.values;\r\n    }\r\n}\r\n_ZodNativeEnum_cache = new WeakMap();\r\nZodNativeEnum.create = (values, params) => {\r\n    return new ZodNativeEnum({\r\n        values: values,\r\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodPromise extends ZodType {\r\n    unwrap() {\r\n        return this._def.type;\r\n    }\r\n    _parse(input) {\r\n        const { ctx } = this._processInputParams(input);\r\n        if (ctx.parsedType !== ZodParsedType.promise &&\r\n            ctx.common.async === false) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.promise,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        const promisified = ctx.parsedType === ZodParsedType.promise\r\n            ? ctx.data\r\n            : Promise.resolve(ctx.data);\r\n        return OK(promisified.then((data) => {\r\n            return this._def.type.parseAsync(data, {\r\n                path: ctx.path,\r\n                errorMap: ctx.common.contextualErrorMap,\r\n            });\r\n        }));\r\n    }\r\n}\r\nZodPromise.create = (schema, params) => {\r\n    return new ZodPromise({\r\n        type: schema,\r\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodEffects extends ZodType {\r\n    innerType() {\r\n        return this._def.schema;\r\n    }\r\n    sourceType() {\r\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects\r\n            ? this._def.schema.sourceType()\r\n            : this._def.schema;\r\n    }\r\n    _parse(input) {\r\n        const { status, ctx } = this._processInputParams(input);\r\n        const effect = this._def.effect || null;\r\n        const checkCtx = {\r\n            addIssue: (arg) => {\r\n                addIssueToContext(ctx, arg);\r\n                if (arg.fatal) {\r\n                    status.abort();\r\n                }\r\n                else {\r\n                    status.dirty();\r\n                }\r\n            },\r\n            get path() {\r\n                return ctx.path;\r\n            },\r\n        };\r\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\r\n        if (effect.type === \"preprocess\") {\r\n            const processed = effect.transform(ctx.data, checkCtx);\r\n            if (ctx.common.async) {\r\n                return Promise.resolve(processed).then(async (processed) => {\r\n                    if (status.value === \"aborted\")\r\n                        return INVALID;\r\n                    const result = await this._def.schema._parseAsync({\r\n                        data: processed,\r\n                        path: ctx.path,\r\n                        parent: ctx,\r\n                    });\r\n                    if (result.status === \"aborted\")\r\n                        return INVALID;\r\n                    if (result.status === \"dirty\")\r\n                        return DIRTY(result.value);\r\n                    if (status.value === \"dirty\")\r\n                        return DIRTY(result.value);\r\n                    return result;\r\n                });\r\n            }\r\n            else {\r\n                if (status.value === \"aborted\")\r\n                    return INVALID;\r\n                const result = this._def.schema._parseSync({\r\n                    data: processed,\r\n                    path: ctx.path,\r\n                    parent: ctx,\r\n                });\r\n                if (result.status === \"aborted\")\r\n                    return INVALID;\r\n                if (result.status === \"dirty\")\r\n                    return DIRTY(result.value);\r\n                if (status.value === \"dirty\")\r\n                    return DIRTY(result.value);\r\n                return result;\r\n            }\r\n        }\r\n        if (effect.type === \"refinement\") {\r\n            const executeRefinement = (acc) => {\r\n                const result = effect.refinement(acc, checkCtx);\r\n                if (ctx.common.async) {\r\n                    return Promise.resolve(result);\r\n                }\r\n                if (result instanceof Promise) {\r\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\r\n                }\r\n                return acc;\r\n            };\r\n            if (ctx.common.async === false) {\r\n                const inner = this._def.schema._parseSync({\r\n                    data: ctx.data,\r\n                    path: ctx.path,\r\n                    parent: ctx,\r\n                });\r\n                if (inner.status === \"aborted\")\r\n                    return INVALID;\r\n                if (inner.status === \"dirty\")\r\n                    status.dirty();\r\n                // return value is ignored\r\n                executeRefinement(inner.value);\r\n                return { status: status.value, value: inner.value };\r\n            }\r\n            else {\r\n                return this._def.schema\r\n                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })\r\n                    .then((inner) => {\r\n                    if (inner.status === \"aborted\")\r\n                        return INVALID;\r\n                    if (inner.status === \"dirty\")\r\n                        status.dirty();\r\n                    return executeRefinement(inner.value).then(() => {\r\n                        return { status: status.value, value: inner.value };\r\n                    });\r\n                });\r\n            }\r\n        }\r\n        if (effect.type === \"transform\") {\r\n            if (ctx.common.async === false) {\r\n                const base = this._def.schema._parseSync({\r\n                    data: ctx.data,\r\n                    path: ctx.path,\r\n                    parent: ctx,\r\n                });\r\n                if (!isValid(base))\r\n                    return base;\r\n                const result = effect.transform(base.value, checkCtx);\r\n                if (result instanceof Promise) {\r\n                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\r\n                }\r\n                return { status: status.value, value: result };\r\n            }\r\n            else {\r\n                return this._def.schema\r\n                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })\r\n                    .then((base) => {\r\n                    if (!isValid(base))\r\n                        return base;\r\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));\r\n                });\r\n            }\r\n        }\r\n        util.assertNever(effect);\r\n    }\r\n}\r\nZodEffects.create = (schema, effect, params) => {\r\n    return new ZodEffects({\r\n        schema,\r\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\r\n        effect,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\r\n    return new ZodEffects({\r\n        schema,\r\n        effect: { type: \"preprocess\", transform: preprocess },\r\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodOptional extends ZodType {\r\n    _parse(input) {\r\n        const parsedType = this._getType(input);\r\n        if (parsedType === ZodParsedType.undefined) {\r\n            return OK(undefined);\r\n        }\r\n        return this._def.innerType._parse(input);\r\n    }\r\n    unwrap() {\r\n        return this._def.innerType;\r\n    }\r\n}\r\nZodOptional.create = (type, params) => {\r\n    return new ZodOptional({\r\n        innerType: type,\r\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodNullable extends ZodType {\r\n    _parse(input) {\r\n        const parsedType = this._getType(input);\r\n        if (parsedType === ZodParsedType.null) {\r\n            return OK(null);\r\n        }\r\n        return this._def.innerType._parse(input);\r\n    }\r\n    unwrap() {\r\n        return this._def.innerType;\r\n    }\r\n}\r\nZodNullable.create = (type, params) => {\r\n    return new ZodNullable({\r\n        innerType: type,\r\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodDefault extends ZodType {\r\n    _parse(input) {\r\n        const { ctx } = this._processInputParams(input);\r\n        let data = ctx.data;\r\n        if (ctx.parsedType === ZodParsedType.undefined) {\r\n            data = this._def.defaultValue();\r\n        }\r\n        return this._def.innerType._parse({\r\n            data,\r\n            path: ctx.path,\r\n            parent: ctx,\r\n        });\r\n    }\r\n    removeDefault() {\r\n        return this._def.innerType;\r\n    }\r\n}\r\nZodDefault.create = (type, params) => {\r\n    return new ZodDefault({\r\n        innerType: type,\r\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\r\n        defaultValue: typeof params.default === \"function\"\r\n            ? params.default\r\n            : () => params.default,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodCatch extends ZodType {\r\n    _parse(input) {\r\n        const { ctx } = this._processInputParams(input);\r\n        // newCtx is used to not collect issues from inner types in ctx\r\n        const newCtx = {\r\n            ...ctx,\r\n            common: {\r\n                ...ctx.common,\r\n                issues: [],\r\n            },\r\n        };\r\n        const result = this._def.innerType._parse({\r\n            data: newCtx.data,\r\n            path: newCtx.path,\r\n            parent: {\r\n                ...newCtx,\r\n            },\r\n        });\r\n        if (isAsync(result)) {\r\n            return result.then((result) => {\r\n                return {\r\n                    status: \"valid\",\r\n                    value: result.status === \"valid\"\r\n                        ? result.value\r\n                        : this._def.catchValue({\r\n                            get error() {\r\n                                return new ZodError(newCtx.common.issues);\r\n                            },\r\n                            input: newCtx.data,\r\n                        }),\r\n                };\r\n            });\r\n        }\r\n        else {\r\n            return {\r\n                status: \"valid\",\r\n                value: result.status === \"valid\"\r\n                    ? result.value\r\n                    : this._def.catchValue({\r\n                        get error() {\r\n                            return new ZodError(newCtx.common.issues);\r\n                        },\r\n                        input: newCtx.data,\r\n                    }),\r\n            };\r\n        }\r\n    }\r\n    removeCatch() {\r\n        return this._def.innerType;\r\n    }\r\n}\r\nZodCatch.create = (type, params) => {\r\n    return new ZodCatch({\r\n        innerType: type,\r\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\r\n        catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodNaN extends ZodType {\r\n    _parse(input) {\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.nan) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.nan,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        return { status: \"valid\", value: input.data };\r\n    }\r\n}\r\nZodNaN.create = (params) => {\r\n    return new ZodNaN({\r\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nconst BRAND = Symbol(\"zod_brand\");\r\nclass ZodBranded extends ZodType {\r\n    _parse(input) {\r\n        const { ctx } = this._processInputParams(input);\r\n        const data = ctx.data;\r\n        return this._def.type._parse({\r\n            data,\r\n            path: ctx.path,\r\n            parent: ctx,\r\n        });\r\n    }\r\n    unwrap() {\r\n        return this._def.type;\r\n    }\r\n}\r\nclass ZodPipeline extends ZodType {\r\n    _parse(input) {\r\n        const { status, ctx } = this._processInputParams(input);\r\n        if (ctx.common.async) {\r\n            const handleAsync = async () => {\r\n                const inResult = await this._def.in._parseAsync({\r\n                    data: ctx.data,\r\n                    path: ctx.path,\r\n                    parent: ctx,\r\n                });\r\n                if (inResult.status === \"aborted\")\r\n                    return INVALID;\r\n                if (inResult.status === \"dirty\") {\r\n                    status.dirty();\r\n                    return DIRTY(inResult.value);\r\n                }\r\n                else {\r\n                    return this._def.out._parseAsync({\r\n                        data: inResult.value,\r\n                        path: ctx.path,\r\n                        parent: ctx,\r\n                    });\r\n                }\r\n            };\r\n            return handleAsync();\r\n        }\r\n        else {\r\n            const inResult = this._def.in._parseSync({\r\n                data: ctx.data,\r\n                path: ctx.path,\r\n                parent: ctx,\r\n            });\r\n            if (inResult.status === \"aborted\")\r\n                return INVALID;\r\n            if (inResult.status === \"dirty\") {\r\n                status.dirty();\r\n                return {\r\n                    status: \"dirty\",\r\n                    value: inResult.value,\r\n                };\r\n            }\r\n            else {\r\n                return this._def.out._parseSync({\r\n                    data: inResult.value,\r\n                    path: ctx.path,\r\n                    parent: ctx,\r\n                });\r\n            }\r\n        }\r\n    }\r\n    static create(a, b) {\r\n        return new ZodPipeline({\r\n            in: a,\r\n            out: b,\r\n            typeName: ZodFirstPartyTypeKind.ZodPipeline,\r\n        });\r\n    }\r\n}\r\nclass ZodReadonly extends ZodType {\r\n    _parse(input) {\r\n        const result = this._def.innerType._parse(input);\r\n        const freeze = (data) => {\r\n            if (isValid(data)) {\r\n                data.value = Object.freeze(data.value);\r\n            }\r\n            return data;\r\n        };\r\n        return isAsync(result)\r\n            ? result.then((data) => freeze(data))\r\n            : freeze(result);\r\n    }\r\n    unwrap() {\r\n        return this._def.innerType;\r\n    }\r\n}\r\nZodReadonly.create = (type, params) => {\r\n    return new ZodReadonly({\r\n        innerType: type,\r\n        typeName: ZodFirstPartyTypeKind.ZodReadonly,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\n////////////////////////////////////////\r\n////////////////////////////////////////\r\n//////////                    //////////\r\n//////////      z.custom      //////////\r\n//////////                    //////////\r\n////////////////////////////////////////\r\n////////////////////////////////////////\r\nfunction cleanParams(params, data) {\r\n    const p = typeof params === \"function\"\r\n        ? params(data)\r\n        : typeof params === \"string\"\r\n            ? { message: params }\r\n            : params;\r\n    const p2 = typeof p === \"string\" ? { message: p } : p;\r\n    return p2;\r\n}\r\nfunction custom(check, _params = {}, \r\n/**\r\n * @deprecated\r\n *\r\n * Pass `fatal` into the params object instead:\r\n *\r\n * ```ts\r\n * z.string().custom((val) => val.length > 5, { fatal: false })\r\n * ```\r\n *\r\n */\r\nfatal) {\r\n    if (check)\r\n        return ZodAny.create().superRefine((data, ctx) => {\r\n            var _a, _b;\r\n            const r = check(data);\r\n            if (r instanceof Promise) {\r\n                return r.then((r) => {\r\n                    var _a, _b;\r\n                    if (!r) {\r\n                        const params = cleanParams(_params, data);\r\n                        const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;\r\n                        ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\r\n                    }\r\n                });\r\n            }\r\n            if (!r) {\r\n                const params = cleanParams(_params, data);\r\n                const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;\r\n                ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\r\n            }\r\n            return;\r\n        });\r\n    return ZodAny.create();\r\n}\r\nconst late = {\r\n    object: ZodObject.lazycreate,\r\n};\r\nvar ZodFirstPartyTypeKind;\r\n(function (ZodFirstPartyTypeKind) {\r\n    ZodFirstPartyTypeKind[\"ZodString\"] = \"ZodString\";\r\n    ZodFirstPartyTypeKind[\"ZodNumber\"] = \"ZodNumber\";\r\n    ZodFirstPartyTypeKind[\"ZodNaN\"] = \"ZodNaN\";\r\n    ZodFirstPartyTypeKind[\"ZodBigInt\"] = \"ZodBigInt\";\r\n    ZodFirstPartyTypeKind[\"ZodBoolean\"] = \"ZodBoolean\";\r\n    ZodFirstPartyTypeKind[\"ZodDate\"] = \"ZodDate\";\r\n    ZodFirstPartyTypeKind[\"ZodSymbol\"] = \"ZodSymbol\";\r\n    ZodFirstPartyTypeKind[\"ZodUndefined\"] = \"ZodUndefined\";\r\n    ZodFirstPartyTypeKind[\"ZodNull\"] = \"ZodNull\";\r\n    ZodFirstPartyTypeKind[\"ZodAny\"] = \"ZodAny\";\r\n    ZodFirstPartyTypeKind[\"ZodUnknown\"] = \"ZodUnknown\";\r\n    ZodFirstPartyTypeKind[\"ZodNever\"] = \"ZodNever\";\r\n    ZodFirstPartyTypeKind[\"ZodVoid\"] = \"ZodVoid\";\r\n    ZodFirstPartyTypeKind[\"ZodArray\"] = \"ZodArray\";\r\n    ZodFirstPartyTypeKind[\"ZodObject\"] = \"ZodObject\";\r\n    ZodFirstPartyTypeKind[\"ZodUnion\"] = \"ZodUnion\";\r\n    ZodFirstPartyTypeKind[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\r\n    ZodFirstPartyTypeKind[\"ZodIntersection\"] = \"ZodIntersection\";\r\n    ZodFirstPartyTypeKind[\"ZodTuple\"] = \"ZodTuple\";\r\n    ZodFirstPartyTypeKind[\"ZodRecord\"] = \"ZodRecord\";\r\n    ZodFirstPartyTypeKind[\"ZodMap\"] = \"ZodMap\";\r\n    ZodFirstPartyTypeKind[\"ZodSet\"] = \"ZodSet\";\r\n    ZodFirstPartyTypeKind[\"ZodFunction\"] = \"ZodFunction\";\r\n    ZodFirstPartyTypeKind[\"ZodLazy\"] = \"ZodLazy\";\r\n    ZodFirstPartyTypeKind[\"ZodLiteral\"] = \"ZodLiteral\";\r\n    ZodFirstPartyTypeKind[\"ZodEnum\"] = \"ZodEnum\";\r\n    ZodFirstPartyTypeKind[\"ZodEffects\"] = \"ZodEffects\";\r\n    ZodFirstPartyTypeKind[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\r\n    ZodFirstPartyTypeKind[\"ZodOptional\"] = \"ZodOptional\";\r\n    ZodFirstPartyTypeKind[\"ZodNullable\"] = \"ZodNullable\";\r\n    ZodFirstPartyTypeKind[\"ZodDefault\"] = \"ZodDefault\";\r\n    ZodFirstPartyTypeKind[\"ZodCatch\"] = \"ZodCatch\";\r\n    ZodFirstPartyTypeKind[\"ZodPromise\"] = \"ZodPromise\";\r\n    ZodFirstPartyTypeKind[\"ZodBranded\"] = \"ZodBranded\";\r\n    ZodFirstPartyTypeKind[\"ZodPipeline\"] = \"ZodPipeline\";\r\n    ZodFirstPartyTypeKind[\"ZodReadonly\"] = \"ZodReadonly\";\r\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\r\nconst instanceOfType = (\r\n// const instanceOfType = <T extends new (...args: any[]) => any>(\r\ncls, params = {\r\n    message: `Input not instance of ${cls.name}`,\r\n}) => custom((data) => data instanceof cls, params);\r\nconst stringType = ZodString.create;\r\nconst numberType = ZodNumber.create;\r\nconst nanType = ZodNaN.create;\r\nconst bigIntType = ZodBigInt.create;\r\nconst booleanType = ZodBoolean.create;\r\nconst dateType = ZodDate.create;\r\nconst symbolType = ZodSymbol.create;\r\nconst undefinedType = ZodUndefined.create;\r\nconst nullType = ZodNull.create;\r\nconst anyType = ZodAny.create;\r\nconst unknownType = ZodUnknown.create;\r\nconst neverType = ZodNever.create;\r\nconst voidType = ZodVoid.create;\r\nconst arrayType = ZodArray.create;\r\nconst objectType = ZodObject.create;\r\nconst strictObjectType = ZodObject.strictCreate;\r\nconst unionType = ZodUnion.create;\r\nconst discriminatedUnionType = ZodDiscriminatedUnion.create;\r\nconst intersectionType = ZodIntersection.create;\r\nconst tupleType = ZodTuple.create;\r\nconst recordType = ZodRecord.create;\r\nconst mapType = ZodMap.create;\r\nconst setType = ZodSet.create;\r\nconst functionType = ZodFunction.create;\r\nconst lazyType = ZodLazy.create;\r\nconst literalType = ZodLiteral.create;\r\nconst enumType = ZodEnum.create;\r\nconst nativeEnumType = ZodNativeEnum.create;\r\nconst promiseType = ZodPromise.create;\r\nconst effectsType = ZodEffects.create;\r\nconst optionalType = ZodOptional.create;\r\nconst nullableType = ZodNullable.create;\r\nconst preprocessType = ZodEffects.createWithPreprocess;\r\nconst pipelineType = ZodPipeline.create;\r\nconst ostring = () => stringType().optional();\r\nconst onumber = () => numberType().optional();\r\nconst oboolean = () => booleanType().optional();\r\nconst coerce = {\r\n    string: ((arg) => ZodString.create({ ...arg, coerce: true })),\r\n    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),\r\n    boolean: ((arg) => ZodBoolean.create({\r\n        ...arg,\r\n        coerce: true,\r\n    })),\r\n    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),\r\n    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),\r\n};\r\nconst NEVER = INVALID;\r\n\r\nvar z = /*#__PURE__*/Object.freeze({\r\n    __proto__: null,\r\n    defaultErrorMap: errorMap,\r\n    setErrorMap: setErrorMap,\r\n    getErrorMap: getErrorMap,\r\n    makeIssue: makeIssue,\r\n    EMPTY_PATH: EMPTY_PATH,\r\n    addIssueToContext: addIssueToContext,\r\n    ParseStatus: ParseStatus,\r\n    INVALID: INVALID,\r\n    DIRTY: DIRTY,\r\n    OK: OK,\r\n    isAborted: isAborted,\r\n    isDirty: isDirty,\r\n    isValid: isValid,\r\n    isAsync: isAsync,\r\n    get util () { return util; },\r\n    get objectUtil () { return objectUtil; },\r\n    ZodParsedType: ZodParsedType,\r\n    getParsedType: getParsedType,\r\n    ZodType: ZodType,\r\n    datetimeRegex: datetimeRegex,\r\n    ZodString: ZodString,\r\n    ZodNumber: ZodNumber,\r\n    ZodBigInt: ZodBigInt,\r\n    ZodBoolean: ZodBoolean,\r\n    ZodDate: ZodDate,\r\n    ZodSymbol: ZodSymbol,\r\n    ZodUndefined: ZodUndefined,\r\n    ZodNull: ZodNull,\r\n    ZodAny: ZodAny,\r\n    ZodUnknown: ZodUnknown,\r\n    ZodNever: ZodNever,\r\n    ZodVoid: ZodVoid,\r\n    ZodArray: ZodArray,\r\n    ZodObject: ZodObject,\r\n    ZodUnion: ZodUnion,\r\n    ZodDiscriminatedUnion: ZodDiscriminatedUnion,\r\n    ZodIntersection: ZodIntersection,\r\n    ZodTuple: ZodTuple,\r\n    ZodRecord: ZodRecord,\r\n    ZodMap: ZodMap,\r\n    ZodSet: ZodSet,\r\n    ZodFunction: ZodFunction,\r\n    ZodLazy: ZodLazy,\r\n    ZodLiteral: ZodLiteral,\r\n    ZodEnum: ZodEnum,\r\n    ZodNativeEnum: ZodNativeEnum,\r\n    ZodPromise: ZodPromise,\r\n    ZodEffects: ZodEffects,\r\n    ZodTransformer: ZodEffects,\r\n    ZodOptional: ZodOptional,\r\n    ZodNullable: ZodNullable,\r\n    ZodDefault: ZodDefault,\r\n    ZodCatch: ZodCatch,\r\n    ZodNaN: ZodNaN,\r\n    BRAND: BRAND,\r\n    ZodBranded: ZodBranded,\r\n    ZodPipeline: ZodPipeline,\r\n    ZodReadonly: ZodReadonly,\r\n    custom: custom,\r\n    Schema: ZodType,\r\n    ZodSchema: ZodType,\r\n    late: late,\r\n    get ZodFirstPartyTypeKind () { return ZodFirstPartyTypeKind; },\r\n    coerce: coerce,\r\n    any: anyType,\r\n    array: arrayType,\r\n    bigint: bigIntType,\r\n    boolean: booleanType,\r\n    date: dateType,\r\n    discriminatedUnion: discriminatedUnionType,\r\n    effect: effectsType,\r\n    'enum': enumType,\r\n    'function': functionType,\r\n    'instanceof': instanceOfType,\r\n    intersection: intersectionType,\r\n    lazy: lazyType,\r\n    literal: literalType,\r\n    map: mapType,\r\n    nan: nanType,\r\n    nativeEnum: nativeEnumType,\r\n    never: neverType,\r\n    'null': nullType,\r\n    nullable: nullableType,\r\n    number: numberType,\r\n    object: objectType,\r\n    oboolean: oboolean,\r\n    onumber: onumber,\r\n    optional: optionalType,\r\n    ostring: ostring,\r\n    pipeline: pipelineType,\r\n    preprocess: preprocessType,\r\n    promise: promiseType,\r\n    record: recordType,\r\n    set: setType,\r\n    strictObject: strictObjectType,\r\n    string: stringType,\r\n    symbol: symbolType,\r\n    transformer: effectsType,\r\n    tuple: tupleType,\r\n    'undefined': undefinedType,\r\n    union: unionType,\r\n    unknown: unknownType,\r\n    'void': voidType,\r\n    NEVER: NEVER,\r\n    ZodIssueCode: ZodIssueCode,\r\n    quotelessJson: quotelessJson,\r\n    ZodError: ZodError\r\n});\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvem9kL2xpYi9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsSUFBSTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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eUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxpREFBaUQ7QUFDdkY7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx5QkFBeUI7QUFDL0Q7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx1QkFBdUI7QUFDN0Q7QUFDQSxxQkFBcUI7QUFDckI7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akUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtB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QUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsY0FBYztBQUNqRjtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsdUJBQXVCLHNCQUFzQixjQUFjO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxh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O0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywrQkFBK0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUM0ckQiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTm90ZWJvb2tcXERvd25sb2Fkc1xcTkVYVC1KU1xcZmluYW5jZS1tYW5hZ2VyXFxub2RlX21vZHVsZXNcXHpvZFxcbGliXFxpbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHV0aWw7XHJcbihmdW5jdGlvbiAodXRpbCkge1xyXG4gICAgdXRpbC5hc3NlcnRFcXVhbCA9ICh2YWwpID0+IHZhbDtcclxuICAgIGZ1bmN0aW9uIGFzc2VydElzKF9hcmcpIHsgfVxyXG4gICAgdXRpbC5hc3NlcnRJcyA9IGFzc2VydElzO1xyXG4gICAgZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoX3gpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcclxuICAgIH1cclxuICAgIHV0aWwuYXNzZXJ0TmV2ZXIgPSBhc3NlcnROZXZlcjtcclxuICAgIHV0aWwuYXJyYXlUb0VudW0gPSAoaXRlbXMpID0+IHtcclxuICAgICAgICBjb25zdCBvYmogPSB7fTtcclxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcclxuICAgICAgICAgICAgb2JqW2l0ZW1dID0gaXRlbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH07XHJcbiAgICB1dGlsLmdldFZhbGlkRW51bVZhbHVlcyA9IChvYmopID0+IHtcclxuICAgICAgICBjb25zdCB2YWxpZEtleXMgPSB1dGlsLm9iamVjdEtleXMob2JqKS5maWx0ZXIoKGspID0+IHR5cGVvZiBvYmpbb2JqW2tdXSAhPT0gXCJudW1iZXJcIik7XHJcbiAgICAgICAgY29uc3QgZmlsdGVyZWQgPSB7fTtcclxuICAgICAgICBmb3IgKGNvbnN0IGsgb2YgdmFsaWRLZXlzKSB7XHJcbiAgICAgICAgICAgIGZpbHRlcmVkW2tdID0gb2JqW2tdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdXRpbC5vYmplY3RWYWx1ZXMoZmlsdGVyZWQpO1xyXG4gICAgfTtcclxuICAgIHV0aWwub2JqZWN0VmFsdWVzID0gKG9iaikgPT4ge1xyXG4gICAgICAgIHJldHVybiB1dGlsLm9iamVjdEtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9ialtlXTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICB1dGlsLm9iamVjdEtleXMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09IFwiZnVuY3Rpb25cIiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cclxuICAgICAgICA/IChvYmopID0+IE9iamVjdC5rZXlzKG9iaikgLy8gZXNsaW50LWRpc2FibGUtbGluZSBiYW4vYmFuXHJcbiAgICAgICAgOiAob2JqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBrZXlzO1xyXG4gICAgICAgIH07XHJcbiAgICB1dGlsLmZpbmQgPSAoYXJyLCBjaGVja2VyKSA9PiB7XHJcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGFycikge1xyXG4gICAgICAgICAgICBpZiAoY2hlY2tlcihpdGVtKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIHV0aWwuaXNJbnRlZ2VyID0gdHlwZW9mIE51bWJlci5pc0ludGVnZXIgPT09IFwiZnVuY3Rpb25cIlxyXG4gICAgICAgID8gKHZhbCkgPT4gTnVtYmVyLmlzSW50ZWdlcih2YWwpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYmFuL2JhblxyXG4gICAgICAgIDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZSh2YWwpICYmIE1hdGguZmxvb3IodmFsKSA9PT0gdmFsO1xyXG4gICAgZnVuY3Rpb24gam9pblZhbHVlcyhhcnJheSwgc2VwYXJhdG9yID0gXCIgfCBcIikge1xyXG4gICAgICAgIHJldHVybiBhcnJheVxyXG4gICAgICAgICAgICAubWFwKCh2YWwpID0+ICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiID8gYCcke3ZhbH0nYCA6IHZhbCkpXHJcbiAgICAgICAgICAgIC5qb2luKHNlcGFyYXRvcik7XHJcbiAgICB9XHJcbiAgICB1dGlsLmpvaW5WYWx1ZXMgPSBqb2luVmFsdWVzO1xyXG4gICAgdXRpbC5qc29uU3RyaW5naWZ5UmVwbGFjZXIgPSAoXywgdmFsdWUpID0+IHtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG59KSh1dGlsIHx8ICh1dGlsID0ge30pKTtcclxudmFyIG9iamVjdFV0aWw7XHJcbihmdW5jdGlvbiAob2JqZWN0VXRpbCkge1xyXG4gICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyA9IChmaXJzdCwgc2Vjb25kKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLi4uZmlyc3QsXHJcbiAgICAgICAgICAgIC4uLnNlY29uZCwgLy8gc2Vjb25kIG92ZXJ3cml0ZXMgZmlyc3RcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxufSkob2JqZWN0VXRpbCB8fCAob2JqZWN0VXRpbCA9IHt9KSk7XHJcbmNvbnN0IFpvZFBhcnNlZFR5cGUgPSB1dGlsLmFycmF5VG9FbnVtKFtcclxuICAgIFwic3RyaW5nXCIsXHJcbiAgICBcIm5hblwiLFxyXG4gICAgXCJudW1iZXJcIixcclxuICAgIFwiaW50ZWdlclwiLFxyXG4gICAgXCJmbG9hdFwiLFxyXG4gICAgXCJib29sZWFuXCIsXHJcbiAgICBcImRhdGVcIixcclxuICAgIFwiYmlnaW50XCIsXHJcbiAgICBcInN5bWJvbFwiLFxyXG4gICAgXCJmdW5jdGlvblwiLFxyXG4gICAgXCJ1bmRlZmluZWRcIixcclxuICAgIFwibnVsbFwiLFxyXG4gICAgXCJhcnJheVwiLFxyXG4gICAgXCJvYmplY3RcIixcclxuICAgIFwidW5rbm93blwiLFxyXG4gICAgXCJwcm9taXNlXCIsXHJcbiAgICBcInZvaWRcIixcclxuICAgIFwibmV2ZXJcIixcclxuICAgIFwibWFwXCIsXHJcbiAgICBcInNldFwiLFxyXG5dKTtcclxuY29uc3QgZ2V0UGFyc2VkVHlwZSA9IChkYXRhKSA9PiB7XHJcbiAgICBjb25zdCB0ID0gdHlwZW9mIGRhdGE7XHJcbiAgICBzd2l0Y2ggKHQpIHtcclxuICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZDtcclxuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnN0cmluZztcclxuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBpc05hTihkYXRhKSA/IFpvZFBhcnNlZFR5cGUubmFuIDogWm9kUGFyc2VkVHlwZS5udW1iZXI7XHJcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcclxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYm9vbGVhbjtcclxuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcclxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuZnVuY3Rpb247XHJcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxyXG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5iaWdpbnQ7XHJcbiAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxyXG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zeW1ib2w7XHJcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYXJyYXk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRhdGEudGhlbiAmJlxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIGRhdGEudGhlbiA9PT0gXCJmdW5jdGlvblwiICYmXHJcbiAgICAgICAgICAgICAgICBkYXRhLmNhdGNoICYmXHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgZGF0YS5jYXRjaCA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5wcm9taXNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgTWFwICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBNYXApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm1hcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIFNldCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgU2V0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBEYXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5kYXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm9iamVjdDtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS51bmtub3duO1xyXG4gICAgfVxyXG59O1xyXG5cclxuY29uc3QgWm9kSXNzdWVDb2RlID0gdXRpbC5hcnJheVRvRW51bShbXHJcbiAgICBcImludmFsaWRfdHlwZVwiLFxyXG4gICAgXCJpbnZhbGlkX2xpdGVyYWxcIixcclxuICAgIFwiY3VzdG9tXCIsXHJcbiAgICBcImludmFsaWRfdW5pb25cIixcclxuICAgIFwiaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yXCIsXHJcbiAgICBcImludmFsaWRfZW51bV92YWx1ZVwiLFxyXG4gICAgXCJ1bnJlY29nbml6ZWRfa2V5c1wiLFxyXG4gICAgXCJpbnZhbGlkX2FyZ3VtZW50c1wiLFxyXG4gICAgXCJpbnZhbGlkX3JldHVybl90eXBlXCIsXHJcbiAgICBcImludmFsaWRfZGF0ZVwiLFxyXG4gICAgXCJpbnZhbGlkX3N0cmluZ1wiLFxyXG4gICAgXCJ0b29fc21hbGxcIixcclxuICAgIFwidG9vX2JpZ1wiLFxyXG4gICAgXCJpbnZhbGlkX2ludGVyc2VjdGlvbl90eXBlc1wiLFxyXG4gICAgXCJub3RfbXVsdGlwbGVfb2ZcIixcclxuICAgIFwibm90X2Zpbml0ZVwiLFxyXG5dKTtcclxuY29uc3QgcXVvdGVsZXNzSnNvbiA9IChvYmopID0+IHtcclxuICAgIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeShvYmosIG51bGwsIDIpO1xyXG4gICAgcmV0dXJuIGpzb24ucmVwbGFjZSgvXCIoW15cIl0rKVwiOi9nLCBcIiQxOlwiKTtcclxufTtcclxuY2xhc3MgWm9kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBnZXQgZXJyb3JzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzc3VlcztcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKGlzc3Vlcykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pc3N1ZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmFkZElzc3VlID0gKHN1YikgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmlzc3VlcyA9IFsuLi50aGlzLmlzc3Vlcywgc3ViXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYWRkSXNzdWVzID0gKHN1YnMgPSBbXSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmlzc3VlcyA9IFsuLi50aGlzLmlzc3VlcywgLi4uc3Vic107XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBhY3R1YWxQcm90byA9IG5ldy50YXJnZXQucHJvdG90eXBlO1xyXG4gICAgICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGJhbi9iYW5cclxuICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIGFjdHVhbFByb3RvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX19wcm90b19fID0gYWN0dWFsUHJvdG87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubmFtZSA9IFwiWm9kRXJyb3JcIjtcclxuICAgICAgICB0aGlzLmlzc3VlcyA9IGlzc3VlcztcclxuICAgIH1cclxuICAgIGZvcm1hdChfbWFwcGVyKSB7XHJcbiAgICAgICAgY29uc3QgbWFwcGVyID0gX21hcHBlciB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoaXNzdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpc3N1ZS5tZXNzYWdlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGZpZWxkRXJyb3JzID0geyBfZXJyb3JzOiBbXSB9O1xyXG4gICAgICAgIGNvbnN0IHByb2Nlc3NFcnJvciA9IChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGVycm9yLmlzc3Vlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF91bmlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNzdWUudW5pb25FcnJvcnMubWFwKHByb2Nlc3NFcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfcmV0dXJuX3R5cGVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NFcnJvcihpc3N1ZS5yZXR1cm5UeXBlRXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX2FyZ3VtZW50c1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0Vycm9yKGlzc3VlLmFyZ3VtZW50c0Vycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnBhdGgubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGRFcnJvcnMuX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnIgPSBmaWVsZEVycm9ycztcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBpc3N1ZS5wYXRoLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbCA9IGlzc3VlLnBhdGhbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlcm1pbmFsID0gaSA9PT0gaXNzdWUucGF0aC5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRlcm1pbmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmICh0eXBlb2YgZWwgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB9IGVsc2UgaWYgKHR5cGVvZiBlbCA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjb25zdCBlcnJvckFycmF5OiBhbnkgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgZXJyb3JBcnJheS5fZXJyb3JzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgZXJyb3JBcnJheTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycltlbF0uX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnIgPSBjdXJyW2VsXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcHJvY2Vzc0Vycm9yKHRoaXMpO1xyXG4gICAgICAgIHJldHVybiBmaWVsZEVycm9ycztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3NlcnQodmFsdWUpIHtcclxuICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFpvZEVycm9yKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBhIFpvZEVycm9yOiAke3ZhbHVlfWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XHJcbiAgICB9XHJcbiAgICBnZXQgbWVzc2FnZSgpIHtcclxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5pc3N1ZXMsIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyLCAyKTtcclxuICAgIH1cclxuICAgIGdldCBpc0VtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzc3Vlcy5sZW5ndGggPT09IDA7XHJcbiAgICB9XHJcbiAgICBmbGF0dGVuKG1hcHBlciA9IChpc3N1ZSkgPT4gaXNzdWUubWVzc2FnZSkge1xyXG4gICAgICAgIGNvbnN0IGZpZWxkRXJyb3JzID0ge307XHJcbiAgICAgICAgY29uc3QgZm9ybUVycm9ycyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3Qgc3ViIG9mIHRoaXMuaXNzdWVzKSB7XHJcbiAgICAgICAgICAgIGlmIChzdWIucGF0aC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0gPSBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0gfHwgW107XHJcbiAgICAgICAgICAgICAgICBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0ucHVzaChtYXBwZXIoc3ViKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3JtRXJyb3JzLnB1c2gobWFwcGVyKHN1YikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IGZvcm1FcnJvcnMsIGZpZWxkRXJyb3JzIH07XHJcbiAgICB9XHJcbiAgICBnZXQgZm9ybUVycm9ycygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mbGF0dGVuKCk7XHJcbiAgICB9XHJcbn1cclxuWm9kRXJyb3IuY3JlYXRlID0gKGlzc3VlcykgPT4ge1xyXG4gICAgY29uc3QgZXJyb3IgPSBuZXcgWm9kRXJyb3IoaXNzdWVzKTtcclxuICAgIHJldHVybiBlcnJvcjtcclxufTtcclxuXHJcbmNvbnN0IGVycm9yTWFwID0gKGlzc3VlLCBfY3R4KSA9PiB7XHJcbiAgICBsZXQgbWVzc2FnZTtcclxuICAgIHN3aXRjaCAoaXNzdWUuY29kZSkge1xyXG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZTpcclxuICAgICAgICAgICAgaWYgKGlzc3VlLnJlY2VpdmVkID09PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiUmVxdWlyZWRcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgRXhwZWN0ZWQgJHtpc3N1ZS5leHBlY3RlZH0sIHJlY2VpdmVkICR7aXNzdWUucmVjZWl2ZWR9YDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWw6XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBsaXRlcmFsIHZhbHVlLCBleHBlY3RlZCAke0pTT04uc3RyaW5naWZ5KGlzc3VlLmV4cGVjdGVkLCB1dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlcil9YDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUudW5yZWNvZ25pemVkX2tleXM6XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVW5yZWNvZ25pemVkIGtleShzKSBpbiBvYmplY3Q6ICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLmtleXMsIFwiLCBcIil9YDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbjpcclxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0YDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yOlxyXG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZGlzY3JpbWluYXRvciB2YWx1ZS4gRXhwZWN0ZWQgJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUub3B0aW9ucyl9YDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlOlxyXG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZW51bSB2YWx1ZS4gRXhwZWN0ZWQgJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUub3B0aW9ucyl9LCByZWNlaXZlZCAnJHtpc3N1ZS5yZWNlaXZlZH0nYDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9hcmd1bWVudHM6XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBmdW5jdGlvbiBhcmd1bWVudHNgO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3JldHVybl90eXBlOlxyXG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZnVuY3Rpb24gcmV0dXJuIHR5cGVgO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2RhdGU6XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBkYXRlYDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmc6XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXNzdWUudmFsaWRhdGlvbiA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKFwiaW5jbHVkZXNcIiBpbiBpc3N1ZS52YWxpZGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IGluY2x1ZGUgXCIke2lzc3VlLnZhbGlkYXRpb24uaW5jbHVkZXN9XCJgO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXNzdWUudmFsaWRhdGlvbi5wb3NpdGlvbiA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYCR7bWVzc2FnZX0gYXQgb25lIG9yIG1vcmUgcG9zaXRpb25zIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAke2lzc3VlLnZhbGlkYXRpb24ucG9zaXRpb259YDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcInN0YXJ0c1dpdGhcIiBpbiBpc3N1ZS52YWxpZGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IHN0YXJ0IHdpdGggXCIke2lzc3VlLnZhbGlkYXRpb24uc3RhcnRzV2l0aH1cImA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcImVuZHNXaXRoXCIgaW4gaXNzdWUudmFsaWRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBlbmQgd2l0aCBcIiR7aXNzdWUudmFsaWRhdGlvbi5lbmRzV2l0aH1cImA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGlzc3VlLnZhbGlkYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnZhbGlkYXRpb24gIT09IFwicmVnZXhcIikge1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkICR7aXNzdWUudmFsaWRhdGlvbn1gO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLnRvb19zbWFsbDpcclxuICAgICAgICAgICAgaWYgKGlzc3VlLnR5cGUgPT09IFwiYXJyYXlcIilcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQXJyYXkgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBcImV4YWN0bHlcIiA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBsZWFzdGAgOiBgbW9yZSB0aGFuYH0gJHtpc3N1ZS5taW5pbXVtfSBlbGVtZW50KHMpYDtcclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJzdHJpbmdcIilcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgU3RyaW5nIG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gXCJleGFjdGx5XCIgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbGVhc3RgIDogYG92ZXJgfSAke2lzc3VlLm1pbmltdW19IGNoYXJhY3RlcihzKWA7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlICR7aXNzdWUuZXhhY3RcclxuICAgICAgICAgICAgICAgICAgICA/IGBleGFjdGx5IGVxdWFsIHRvIGBcclxuICAgICAgICAgICAgICAgICAgICA6IGlzc3VlLmluY2x1c2l2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBncmVhdGVyIHRoYW4gYH0ke2lzc3VlLm1pbmltdW19YDtcclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJkYXRlXCIpXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYERhdGUgbXVzdCBiZSAke2lzc3VlLmV4YWN0XHJcbiAgICAgICAgICAgICAgICAgICAgPyBgZXhhY3RseSBlcXVhbCB0byBgXHJcbiAgICAgICAgICAgICAgICAgICAgOiBpc3N1ZS5pbmNsdXNpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGBcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBgZ3JlYXRlciB0aGFuIGB9JHtuZXcgRGF0ZShOdW1iZXIoaXNzdWUubWluaW11bSkpfWA7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWQgaW5wdXRcIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUudG9vX2JpZzpcclxuICAgICAgICAgICAgaWYgKGlzc3VlLnR5cGUgPT09IFwiYXJyYXlcIilcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQXJyYXkgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbW9zdGAgOiBgbGVzcyB0aGFuYH0gJHtpc3N1ZS5tYXhpbXVtfSBlbGVtZW50KHMpYDtcclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJzdHJpbmdcIilcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgU3RyaW5nIG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHlgIDogaXNzdWUuaW5jbHVzaXZlID8gYGF0IG1vc3RgIDogYHVuZGVyYH0gJHtpc3N1ZS5tYXhpbXVtfSBjaGFyYWN0ZXIocylgO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcIm51bWJlclwiKVxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSAke2lzc3VlLmV4YWN0XHJcbiAgICAgICAgICAgICAgICAgICAgPyBgZXhhY3RseWBcclxuICAgICAgICAgICAgICAgICAgICA6IGlzc3VlLmluY2x1c2l2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGBsZXNzIHRoYW4gb3IgZXF1YWwgdG9gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYGxlc3MgdGhhbmB9ICR7aXNzdWUubWF4aW11bX1gO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcImJpZ2ludFwiKVxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBCaWdJbnQgbXVzdCBiZSAke2lzc3VlLmV4YWN0XHJcbiAgICAgICAgICAgICAgICAgICAgPyBgZXhhY3RseWBcclxuICAgICAgICAgICAgICAgICAgICA6IGlzc3VlLmluY2x1c2l2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGBsZXNzIHRoYW4gb3IgZXF1YWwgdG9gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYGxlc3MgdGhhbmB9ICR7aXNzdWUubWF4aW11bX1gO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcImRhdGVcIilcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgRGF0ZSBtdXN0IGJlICR7aXNzdWUuZXhhY3RcclxuICAgICAgICAgICAgICAgICAgICA/IGBleGFjdGx5YFxyXG4gICAgICAgICAgICAgICAgICAgIDogaXNzdWUuaW5jbHVzaXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYHNtYWxsZXIgdGhhbiBvciBlcXVhbCB0b2BcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBgc21hbGxlciB0aGFuYH0gJHtuZXcgRGF0ZShOdW1iZXIoaXNzdWUubWF4aW11bSkpfWA7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWQgaW5wdXRcIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuY3VzdG9tOlxyXG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXRgO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2ludGVyc2VjdGlvbl90eXBlczpcclxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnRlcnNlY3Rpb24gcmVzdWx0cyBjb3VsZCBub3QgYmUgbWVyZ2VkYDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mOlxyXG4gICAgICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgJHtpc3N1ZS5tdWx0aXBsZU9mfWA7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLm5vdF9maW5pdGU6XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIk51bWJlciBtdXN0IGJlIGZpbml0ZVwiO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBtZXNzYWdlID0gX2N0eC5kZWZhdWx0RXJyb3I7XHJcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoaXNzdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgbWVzc2FnZSB9O1xyXG59O1xyXG5cclxubGV0IG92ZXJyaWRlRXJyb3JNYXAgPSBlcnJvck1hcDtcclxuZnVuY3Rpb24gc2V0RXJyb3JNYXAobWFwKSB7XHJcbiAgICBvdmVycmlkZUVycm9yTWFwID0gbWFwO1xyXG59XHJcbmZ1bmN0aW9uIGdldEVycm9yTWFwKCkge1xyXG4gICAgcmV0dXJuIG92ZXJyaWRlRXJyb3JNYXA7XHJcbn1cclxuXHJcbmNvbnN0IG1ha2VJc3N1ZSA9IChwYXJhbXMpID0+IHtcclxuICAgIGNvbnN0IHsgZGF0YSwgcGF0aCwgZXJyb3JNYXBzLCBpc3N1ZURhdGEgfSA9IHBhcmFtcztcclxuICAgIGNvbnN0IGZ1bGxQYXRoID0gWy4uLnBhdGgsIC4uLihpc3N1ZURhdGEucGF0aCB8fCBbXSldO1xyXG4gICAgY29uc3QgZnVsbElzc3VlID0ge1xyXG4gICAgICAgIC4uLmlzc3VlRGF0YSxcclxuICAgICAgICBwYXRoOiBmdWxsUGF0aCxcclxuICAgIH07XHJcbiAgICBpZiAoaXNzdWVEYXRhLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC4uLmlzc3VlRGF0YSxcclxuICAgICAgICAgICAgcGF0aDogZnVsbFBhdGgsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IGlzc3VlRGF0YS5tZXNzYWdlLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBsZXQgZXJyb3JNZXNzYWdlID0gXCJcIjtcclxuICAgIGNvbnN0IG1hcHMgPSBlcnJvck1hcHNcclxuICAgICAgICAuZmlsdGVyKChtKSA9PiAhIW0pXHJcbiAgICAgICAgLnNsaWNlKClcclxuICAgICAgICAucmV2ZXJzZSgpO1xyXG4gICAgZm9yIChjb25zdCBtYXAgb2YgbWFwcykge1xyXG4gICAgICAgIGVycm9yTWVzc2FnZSA9IG1hcChmdWxsSXNzdWUsIHsgZGF0YSwgZGVmYXVsdEVycm9yOiBlcnJvck1lc3NhZ2UgfSkubWVzc2FnZTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgLi4uaXNzdWVEYXRhLFxyXG4gICAgICAgIHBhdGg6IGZ1bGxQYXRoLFxyXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yTWVzc2FnZSxcclxuICAgIH07XHJcbn07XHJcbmNvbnN0IEVNUFRZX1BBVEggPSBbXTtcclxuZnVuY3Rpb24gYWRkSXNzdWVUb0NvbnRleHQoY3R4LCBpc3N1ZURhdGEpIHtcclxuICAgIGNvbnN0IG92ZXJyaWRlTWFwID0gZ2V0RXJyb3JNYXAoKTtcclxuICAgIGNvbnN0IGlzc3VlID0gbWFrZUlzc3VlKHtcclxuICAgICAgICBpc3N1ZURhdGE6IGlzc3VlRGF0YSxcclxuICAgICAgICBkYXRhOiBjdHguZGF0YSxcclxuICAgICAgICBwYXRoOiBjdHgucGF0aCxcclxuICAgICAgICBlcnJvck1hcHM6IFtcclxuICAgICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsIC8vIGNvbnRleHR1YWwgZXJyb3IgbWFwIGlzIGZpcnN0IHByaW9yaXR5XHJcbiAgICAgICAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCwgLy8gdGhlbiBzY2hlbWEtYm91bmQgbWFwIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgICAgICBvdmVycmlkZU1hcCwgLy8gdGhlbiBnbG9iYWwgb3ZlcnJpZGUgbWFwXHJcbiAgICAgICAgICAgIG92ZXJyaWRlTWFwID09PSBlcnJvck1hcCA/IHVuZGVmaW5lZCA6IGVycm9yTWFwLCAvLyB0aGVuIGdsb2JhbCBkZWZhdWx0IG1hcFxyXG4gICAgICAgIF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxyXG4gICAgfSk7XHJcbiAgICBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKGlzc3VlKTtcclxufVxyXG5jbGFzcyBQYXJzZVN0YXR1cyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gXCJ2YWxpZFwiO1xyXG4gICAgfVxyXG4gICAgZGlydHkoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IFwidmFsaWRcIilcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiZGlydHlcIjtcclxuICAgIH1cclxuICAgIGFib3J0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLnZhbHVlICE9PSBcImFib3J0ZWRcIilcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiYWJvcnRlZFwiO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHRzKSB7XHJcbiAgICAgICAgY29uc3QgYXJyYXlWYWx1ZSA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgcyBvZiByZXN1bHRzKSB7XHJcbiAgICAgICAgICAgIGlmIChzLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICAgICAgaWYgKHMuc3RhdHVzID09PSBcImRpcnR5XCIpXHJcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgYXJyYXlWYWx1ZS5wdXNoKHMudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGFycmF5VmFsdWUgfTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBtZXJnZU9iamVjdEFzeW5jKHN0YXR1cywgcGFpcnMpIHtcclxuICAgICAgICBjb25zdCBzeW5jUGFpcnMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcGFpci52YWx1ZTtcclxuICAgICAgICAgICAgc3luY1BhaXJzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAga2V5LFxyXG4gICAgICAgICAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgc3luY1BhaXJzKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBtZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBwYWlycykge1xyXG4gICAgICAgIGNvbnN0IGZpbmFsT2JqZWN0ID0ge307XHJcbiAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gcGFpcjtcclxuICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIpXHJcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxyXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgIGlmIChrZXkudmFsdWUgIT09IFwiX19wcm90b19fXCIgJiZcclxuICAgICAgICAgICAgICAgICh0eXBlb2YgdmFsdWUudmFsdWUgIT09IFwidW5kZWZpbmVkXCIgfHwgcGFpci5hbHdheXNTZXQpKSB7XHJcbiAgICAgICAgICAgICAgICBmaW5hbE9iamVjdFtrZXkudmFsdWVdID0gdmFsdWUudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE9iamVjdCB9O1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IElOVkFMSUQgPSBPYmplY3QuZnJlZXplKHtcclxuICAgIHN0YXR1czogXCJhYm9ydGVkXCIsXHJcbn0pO1xyXG5jb25zdCBESVJUWSA9ICh2YWx1ZSkgPT4gKHsgc3RhdHVzOiBcImRpcnR5XCIsIHZhbHVlIH0pO1xyXG5jb25zdCBPSyA9ICh2YWx1ZSkgPT4gKHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlIH0pO1xyXG5jb25zdCBpc0Fib3J0ZWQgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiO1xyXG5jb25zdCBpc0RpcnR5ID0gKHgpID0+IHguc3RhdHVzID09PSBcImRpcnR5XCI7XHJcbmNvbnN0IGlzVmFsaWQgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwidmFsaWRcIjtcclxuY29uc3QgaXNBc3luYyA9ICh4KSA9PiB0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB4IGluc3RhbmNlb2YgUHJvbWlzZTtcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xyXG5cclxudmFyIGVycm9yVXRpbDtcclxuKGZ1bmN0aW9uIChlcnJvclV0aWwpIHtcclxuICAgIGVycm9yVXRpbC5lcnJUb09iaiA9IChtZXNzYWdlKSA9PiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZSB9IDogbWVzc2FnZSB8fCB7fTtcclxuICAgIGVycm9yVXRpbC50b1N0cmluZyA9IChtZXNzYWdlKSA9PiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IG1lc3NhZ2UgOiBtZXNzYWdlID09PSBudWxsIHx8IG1lc3NhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lc3NhZ2UubWVzc2FnZTtcclxufSkoZXJyb3JVdGlsIHx8IChlcnJvclV0aWwgPSB7fSkpO1xyXG5cclxudmFyIF9ab2RFbnVtX2NhY2hlLCBfWm9kTmF0aXZlRW51bV9jYWNoZTtcclxuY2xhc3MgUGFyc2VJbnB1dExhenlQYXRoIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgdmFsdWUsIHBhdGgsIGtleSkge1xyXG4gICAgICAgIHRoaXMuX2NhY2hlZFBhdGggPSBbXTtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICB0aGlzLmRhdGEgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLl9wYXRoID0gcGF0aDtcclxuICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XHJcbiAgICB9XHJcbiAgICBnZXQgcGF0aCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlZFBhdGgubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9rZXkgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVkUGF0aC5wdXNoKC4uLnRoaXMuX3BhdGgsIC4uLnRoaXMuX2tleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZWRQYXRoLnB1c2goLi4udGhpcy5fcGF0aCwgdGhpcy5fa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkUGF0aDtcclxuICAgIH1cclxufVxyXG5jb25zdCBoYW5kbGVSZXN1bHQgPSAoY3R4LCByZXN1bHQpID0+IHtcclxuICAgIGlmIChpc1ZhbGlkKHJlc3VsdCkpIHtcclxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiByZXN1bHQudmFsdWUgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmICghY3R4LmNvbW1vbi5pc3N1ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbGlkYXRpb24gZmFpbGVkIGJ1dCBubyBpc3N1ZXMgZGV0ZWN0ZWQuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICAgICAgZ2V0IGVycm9yKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Vycm9yKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yKGN0eC5jb21tb24uaXNzdWVzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gZXJyb3I7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gcHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpIHtcclxuICAgIGlmICghcGFyYW1zKVxyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIGNvbnN0IHsgZXJyb3JNYXAsIGludmFsaWRfdHlwZV9lcnJvciwgcmVxdWlyZWRfZXJyb3IsIGRlc2NyaXB0aW9uIH0gPSBwYXJhbXM7XHJcbiAgICBpZiAoZXJyb3JNYXAgJiYgKGludmFsaWRfdHlwZV9lcnJvciB8fCByZXF1aXJlZF9lcnJvcikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IHVzZSBcImludmFsaWRfdHlwZV9lcnJvclwiIG9yIFwicmVxdWlyZWRfZXJyb3JcIiBpbiBjb25qdW5jdGlvbiB3aXRoIGN1c3RvbSBlcnJvciBtYXAuYCk7XHJcbiAgICB9XHJcbiAgICBpZiAoZXJyb3JNYXApXHJcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JNYXA6IGVycm9yTWFwLCBkZXNjcmlwdGlvbiB9O1xyXG4gICAgY29uc3QgY3VzdG9tTWFwID0gKGlzcywgY3R4KSA9PiB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCB7IG1lc3NhZ2UgfSA9IHBhcmFtcztcclxuICAgICAgICBpZiAoaXNzLmNvZGUgPT09IFwiaW52YWxpZF9lbnVtX3ZhbHVlXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogY3R4LmRlZmF1bHRFcnJvciB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGN0eC5kYXRhID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IChfYSA9IG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6IHJlcXVpcmVkX2Vycm9yKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjdHguZGVmYXVsdEVycm9yIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc3MuY29kZSAhPT0gXCJpbnZhbGlkX3R5cGVcIilcclxuICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogY3R4LmRlZmF1bHRFcnJvciB9O1xyXG4gICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IChfYiA9IG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6IGludmFsaWRfdHlwZV9lcnJvcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY3R4LmRlZmF1bHRFcnJvciB9O1xyXG4gICAgfTtcclxuICAgIHJldHVybiB7IGVycm9yTWFwOiBjdXN0b21NYXAsIGRlc2NyaXB0aW9uIH07XHJcbn1cclxuY2xhc3MgWm9kVHlwZSB7XHJcbiAgICBnZXQgZGVzY3JpcHRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5kZXNjcmlwdGlvbjtcclxuICAgIH1cclxuICAgIF9nZXRUeXBlKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSk7XHJcbiAgICB9XHJcbiAgICBfZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCkge1xyXG4gICAgICAgIHJldHVybiAoY3R4IHx8IHtcclxuICAgICAgICAgICAgY29tbW9uOiBpbnB1dC5wYXJlbnQuY29tbW9uLFxyXG4gICAgICAgICAgICBkYXRhOiBpbnB1dC5kYXRhLFxyXG4gICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGlucHV0LmRhdGEpLFxyXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxyXG4gICAgICAgICAgICBwYXRoOiBpbnB1dC5wYXRoLFxyXG4gICAgICAgICAgICBwYXJlbnQ6IGlucHV0LnBhcmVudCxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdGF0dXM6IG5ldyBQYXJzZVN0YXR1cygpLFxyXG4gICAgICAgICAgICBjdHg6IHtcclxuICAgICAgICAgICAgICAgIGNvbW1vbjogaW5wdXQucGFyZW50LmNvbW1vbixcclxuICAgICAgICAgICAgICAgIGRhdGE6IGlucHV0LmRhdGEsXHJcbiAgICAgICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGlucHV0LmRhdGEpLFxyXG4gICAgICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcclxuICAgICAgICAgICAgICAgIHBhdGg6IGlucHV0LnBhdGgsXHJcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGlucHV0LnBhcmVudCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgX3BhcnNlU3luYyhpbnB1dCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlKGlucHV0KTtcclxuICAgICAgICBpZiAoaXNBc3luYyhyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN5bmNocm9ub3VzIHBhcnNlIGVuY291bnRlcmVkIHByb21pc2UuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgX3BhcnNlQXN5bmMoaW5wdXQpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZShpbnB1dCk7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgcGFyc2UoZGF0YSwgcGFyYW1zKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5zYWZlUGFyc2UoZGF0YSwgcGFyYW1zKTtcclxuICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcclxuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XHJcbiAgICB9XHJcbiAgICBzYWZlUGFyc2UoZGF0YSwgcGFyYW1zKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IGN0eCA9IHtcclxuICAgICAgICAgICAgY29tbW9uOiB7XHJcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgYXN5bmM6IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5hc3luYykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0dWFsRXJyb3JNYXA6IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5lcnJvck1hcCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcGF0aDogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5wYXRoKSB8fCBbXSxcclxuICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcclxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxyXG4gICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGRhdGEpLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2VTeW5jKHsgZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pO1xyXG4gICAgICAgIHJldHVybiBoYW5kbGVSZXN1bHQoY3R4LCByZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgXCJ+dmFsaWRhdGVcIihkYXRhKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCBjdHggPSB7XHJcbiAgICAgICAgICAgIGNvbW1vbjoge1xyXG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcclxuICAgICAgICAgICAgICAgIGFzeW5jOiAhIXRoaXNbXCJ+c3RhbmRhcmRcIl0uYXN5bmMsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHBhdGg6IFtdLFxyXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxyXG4gICAgICAgICAgICBwYXJlbnQ6IG51bGwsXHJcbiAgICAgICAgICAgIGRhdGEsXHJcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSksXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoIXRoaXNbXCJ+c3RhbmRhcmRcIl0uYXN5bmMpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlU3luYyh7IGRhdGEsIHBhdGg6IFtdLCBwYXJlbnQ6IGN0eCB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpc1ZhbGlkKHJlc3VsdClcclxuICAgICAgICAgICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlczogY3R4LmNvbW1vbi5pc3N1ZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKF9iID0gKF9hID0gZXJyID09PSBudWxsIHx8IGVyciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyLm1lc3NhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSgpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaW5jbHVkZXMoXCJlbmNvdW50ZXJlZFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbXCJ+c3RhbmRhcmRcIl0uYXN5bmMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3R4LmNvbW1vbiA9IHtcclxuICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VBc3luYyh7IGRhdGEsIHBhdGg6IFtdLCBwYXJlbnQ6IGN0eCB9KS50aGVuKChyZXN1bHQpID0+IGlzVmFsaWQocmVzdWx0KVxyXG4gICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQudmFsdWUsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgOiB7XHJcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IGN0eC5jb21tb24uaXNzdWVzLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGFzeW5jIHBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5zYWZlUGFyc2VBc3luYyhkYXRhLCBwYXJhbXMpO1xyXG4gICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcylcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xyXG4gICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcclxuICAgIH1cclxuICAgIGFzeW5jIHNhZmVQYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xyXG4gICAgICAgIGNvbnN0IGN0eCA9IHtcclxuICAgICAgICAgICAgY29tbW9uOiB7XHJcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgY29udGV4dHVhbEVycm9yTWFwOiBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuZXJyb3JNYXAsXHJcbiAgICAgICAgICAgICAgICBhc3luYzogdHJ1ZSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcGF0aDogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5wYXRoKSB8fCBbXSxcclxuICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcclxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxyXG4gICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGRhdGEpLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgbWF5YmVBc3luY1Jlc3VsdCA9IHRoaXMuX3BhcnNlKHsgZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IChpc0FzeW5jKG1heWJlQXN5bmNSZXN1bHQpXHJcbiAgICAgICAgICAgID8gbWF5YmVBc3luY1Jlc3VsdFxyXG4gICAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZShtYXliZUFzeW5jUmVzdWx0KSk7XHJcbiAgICAgICAgcmV0dXJuIGhhbmRsZVJlc3VsdChjdHgsIHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICByZWZpbmUoY2hlY2ssIG1lc3NhZ2UpIHtcclxuICAgICAgICBjb25zdCBnZXRJc3N1ZVByb3BlcnRpZXMgPSAodmFsKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgbWVzc2FnZSA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlKHZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQoKHZhbCwgY3R4KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZWNrKHZhbCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNldEVycm9yID0gKCkgPT4gY3R4LmFkZElzc3VlKHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5jdXN0b20sXHJcbiAgICAgICAgICAgICAgICAuLi5nZXRJc3N1ZVByb3BlcnRpZXModmFsKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiByZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oKGRhdGEpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RXJyb3IoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIHNldEVycm9yKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmVmaW5lbWVudChjaGVjaywgcmVmaW5lbWVudERhdGEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudCgodmFsLCBjdHgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFjaGVjayh2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICBjdHguYWRkSXNzdWUodHlwZW9mIHJlZmluZW1lbnREYXRhID09PSBcImZ1bmN0aW9uXCJcclxuICAgICAgICAgICAgICAgICAgICA/IHJlZmluZW1lbnREYXRhKHZhbCwgY3R4KVxyXG4gICAgICAgICAgICAgICAgICAgIDogcmVmaW5lbWVudERhdGEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9yZWZpbmVtZW50KHJlZmluZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xyXG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMsXHJcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcclxuICAgICAgICAgICAgZWZmZWN0OiB7IHR5cGU6IFwicmVmaW5lbWVudFwiLCByZWZpbmVtZW50IH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzdXBlclJlZmluZShyZWZpbmVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQocmVmaW5lbWVudCk7XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3RvcihkZWYpIHtcclxuICAgICAgICAvKiogQWxpYXMgb2Ygc2FmZVBhcnNlQXN5bmMgKi9cclxuICAgICAgICB0aGlzLnNwYSA9IHRoaXMuc2FmZVBhcnNlQXN5bmM7XHJcbiAgICAgICAgdGhpcy5fZGVmID0gZGVmO1xyXG4gICAgICAgIHRoaXMucGFyc2UgPSB0aGlzLnBhcnNlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zYWZlUGFyc2UgPSB0aGlzLnNhZmVQYXJzZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMucGFyc2VBc3luYyA9IHRoaXMucGFyc2VBc3luYy5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc2FmZVBhcnNlQXN5bmMgPSB0aGlzLnNhZmVQYXJzZUFzeW5jLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zcGEgPSB0aGlzLnNwYS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMucmVmaW5lID0gdGhpcy5yZWZpbmUuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnJlZmluZW1lbnQgPSB0aGlzLnJlZmluZW1lbnQuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnN1cGVyUmVmaW5lID0gdGhpcy5zdXBlclJlZmluZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMub3B0aW9uYWwgPSB0aGlzLm9wdGlvbmFsLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5udWxsYWJsZSA9IHRoaXMubnVsbGFibGUuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLm51bGxpc2ggPSB0aGlzLm51bGxpc2guYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmFycmF5ID0gdGhpcy5hcnJheS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMucHJvbWlzZSA9IHRoaXMucHJvbWlzZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMub3IgPSB0aGlzLm9yLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5hbmQgPSB0aGlzLmFuZC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm0uYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmJyYW5kID0gdGhpcy5icmFuZC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdCA9IHRoaXMuZGVmYXVsdC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuY2F0Y2ggPSB0aGlzLmNhdGNoLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5kZXNjcmliZSA9IHRoaXMuZGVzY3JpYmUuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnBpcGUgPSB0aGlzLnBpcGUuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnJlYWRvbmx5ID0gdGhpcy5yZWFkb25seS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaXNOdWxsYWJsZSA9IHRoaXMuaXNOdWxsYWJsZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaXNPcHRpb25hbCA9IHRoaXMuaXNPcHRpb25hbC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXNbXCJ+c3RhbmRhcmRcIl0gPSB7XHJcbiAgICAgICAgICAgIHZlcnNpb246IDEsXHJcbiAgICAgICAgICAgIHZlbmRvcjogXCJ6b2RcIixcclxuICAgICAgICAgICAgdmFsaWRhdGU6IChkYXRhKSA9PiB0aGlzW1wifnZhbGlkYXRlXCJdKGRhdGEpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBvcHRpb25hbCgpIHtcclxuICAgICAgICByZXR1cm4gWm9kT3B0aW9uYWwuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XHJcbiAgICB9XHJcbiAgICBudWxsYWJsZSgpIHtcclxuICAgICAgICByZXR1cm4gWm9kTnVsbGFibGUuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XHJcbiAgICB9XHJcbiAgICBudWxsaXNoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm51bGxhYmxlKCkub3B0aW9uYWwoKTtcclxuICAgIH1cclxuICAgIGFycmF5KCkge1xyXG4gICAgICAgIHJldHVybiBab2RBcnJheS5jcmVhdGUodGhpcyk7XHJcbiAgICB9XHJcbiAgICBwcm9taXNlKCkge1xyXG4gICAgICAgIHJldHVybiBab2RQcm9taXNlLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xyXG4gICAgfVxyXG4gICAgb3Iob3B0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgb3B0aW9uXSwgdGhpcy5fZGVmKTtcclxuICAgIH1cclxuICAgIGFuZChpbmNvbWluZykge1xyXG4gICAgICAgIHJldHVybiBab2RJbnRlcnNlY3Rpb24uY3JlYXRlKHRoaXMsIGluY29taW5nLCB0aGlzLl9kZWYpO1xyXG4gICAgfVxyXG4gICAgdHJhbnNmb3JtKHRyYW5zZm9ybSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XHJcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcclxuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLFxyXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXHJcbiAgICAgICAgICAgIGVmZmVjdDogeyB0eXBlOiBcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0gfSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGRlZmF1bHQoZGVmKSB7XHJcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlRnVuYyA9IHR5cGVvZiBkZWYgPT09IFwiZnVuY3Rpb25cIiA/IGRlZiA6ICgpID0+IGRlZjtcclxuICAgICAgICByZXR1cm4gbmV3IFpvZERlZmF1bHQoe1xyXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXHJcbiAgICAgICAgICAgIGlubmVyVHlwZTogdGhpcyxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBkZWZhdWx0VmFsdWVGdW5jLFxyXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERlZmF1bHQsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBicmFuZCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFpvZEJyYW5kZWQoe1xyXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJyYW5kZWQsXHJcbiAgICAgICAgICAgIHR5cGU6IHRoaXMsXHJcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNhdGNoKGRlZikge1xyXG4gICAgICAgIGNvbnN0IGNhdGNoVmFsdWVGdW5jID0gdHlwZW9mIGRlZiA9PT0gXCJmdW5jdGlvblwiID8gZGVmIDogKCkgPT4gZGVmO1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kQ2F0Y2goe1xyXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXHJcbiAgICAgICAgICAgIGlubmVyVHlwZTogdGhpcyxcclxuICAgICAgICAgICAgY2F0Y2hWYWx1ZTogY2F0Y2hWYWx1ZUZ1bmMsXHJcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQ2F0Y2gsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBkZXNjcmliZShkZXNjcmlwdGlvbikge1xyXG4gICAgICAgIGNvbnN0IFRoaXMgPSB0aGlzLmNvbnN0cnVjdG9yO1xyXG4gICAgICAgIHJldHVybiBuZXcgVGhpcyh7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBwaXBlKHRhcmdldCkge1xyXG4gICAgICAgIHJldHVybiBab2RQaXBlbGluZS5jcmVhdGUodGhpcywgdGFyZ2V0KTtcclxuICAgIH1cclxuICAgIHJlYWRvbmx5KCkge1xyXG4gICAgICAgIHJldHVybiBab2RSZWFkb25seS5jcmVhdGUodGhpcyk7XHJcbiAgICB9XHJcbiAgICBpc09wdGlvbmFsKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNhZmVQYXJzZSh1bmRlZmluZWQpLnN1Y2Nlc3M7XHJcbiAgICB9XHJcbiAgICBpc051bGxhYmxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNhZmVQYXJzZShudWxsKS5zdWNjZXNzO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGN1aWRSZWdleCA9IC9eY1teXFxzLV17OCx9JC9pO1xyXG5jb25zdCBjdWlkMlJlZ2V4ID0gL15bMC05YS16XSskLztcclxuY29uc3QgdWxpZFJlZ2V4ID0gL15bMC05QS1ISktNTlAtVFYtWl17MjZ9JC9pO1xyXG4vLyBjb25zdCB1dWlkUmVnZXggPVxyXG4vLyAgIC9eKFthLWYwLTldezh9LVthLWYwLTldezR9LVsxLTVdW2EtZjAtOV17M30tW2EtZjAtOV17NH0tW2EtZjAtOV17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7XHJcbmNvbnN0IHV1aWRSZWdleCA9IC9eWzAtOWEtZkEtRl17OH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17MTJ9JC9pO1xyXG5jb25zdCBuYW5vaWRSZWdleCA9IC9eW2EtejAtOV8tXXsyMX0kL2k7XHJcbmNvbnN0IGp3dFJlZ2V4ID0gL15bQS1aYS16MC05LV9dK1xcLltBLVphLXowLTktX10rXFwuW0EtWmEtejAtOS1fXSokLztcclxuY29uc3QgZHVyYXRpb25SZWdleCA9IC9eWy0rXT9QKD8hJCkoPzooPzpbLStdP1xcZCtZKXwoPzpbLStdP1xcZCtbLixdXFxkK1kkKSk/KD86KD86Wy0rXT9cXGQrTSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtNJCkpPyg/Oig/OlstK10/XFxkK1cpfCg/OlstK10/XFxkK1suLF1cXGQrVyQpKT8oPzooPzpbLStdP1xcZCtEKXwoPzpbLStdP1xcZCtbLixdXFxkK0QkKSk/KD86VCg/PVtcXGQrLV0pKD86KD86Wy0rXT9cXGQrSCl8KD86Wy0rXT9cXGQrWy4sXVxcZCtIJCkpPyg/Oig/OlstK10/XFxkK00pfCg/OlstK10/XFxkK1suLF1cXGQrTSQpKT8oPzpbLStdP1xcZCsoPzpbLixdXFxkKyk/Uyk/KT8/JC87XHJcbi8vIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ2MTgxLzE1NTAxNTVcclxuLy8gb2xkIHZlcnNpb246IHRvbyBzbG93LCBkaWRuJ3Qgc3VwcG9ydCB1bmljb2RlXHJcbi8vIGNvbnN0IGVtYWlsUmVnZXggPSAvXigoKFthLXpdfFxcZHxbISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5dfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSsoXFwuKFthLXpdfFxcZHxbISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5dfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSspKil8KChcXHgyMikoKCgoXFx4MjB8XFx4MDkpKihcXHgwZFxceDBhKSk/KFxceDIwfFxceDA5KSspPygoW1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4N2ZdfFxceDIxfFtcXHgyMy1cXHg1Yl18W1xceDVkLVxceDdlXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KFxcXFwoW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBkLVxceDdmXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKSkqKCgoXFx4MjB8XFx4MDkpKihcXHgwZFxceDBhKSk/KFxceDIwfFxceDA5KSspPyhcXHgyMikpKUAoKChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpXFwuKSsoKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSkkL2k7XHJcbi8vb2xkIGVtYWlsIHJlZ2V4XHJcbi8vIGNvbnN0IGVtYWlsUmVnZXggPSAvXigoW148PigpW1xcXS4sOzpcXHNAXCJdKyhcXC5bXjw+KClbXFxdLiw7Olxcc0BcIl0rKSopfChcIi4rXCIpKUAoKD8hLSkoW148PigpW1xcXS4sOzpcXHNAXCJdK1xcLikrW148PigpW1xcXS4sOzpcXHNAXCJdezEsfSlbXi08PigpW1xcXS4sOzpcXHNAXCJdJC9pO1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuLy8gY29uc3QgZW1haWxSZWdleCA9XHJcbi8vICAgL14oKFtePD4oKVtcXF1cXFxcLiw7Olxcc0BcXFwiXSsoXFwuW148PigpW1xcXVxcXFwuLDs6XFxzQFxcXCJdKykqKXwoXFxcIi4rXFxcIikpQCgoXFxbKCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFxdKXwoXFxbSVB2NjooKFthLWYwLTldezEsNH06KXs3fXw6OihbYS1mMC05XXsxLDR9Oil7MCw2fXwoW2EtZjAtOV17MSw0fTopezF9OihbYS1mMC05XXsxLDR9Oil7MCw1fXwoW2EtZjAtOV17MSw0fTopezJ9OihbYS1mMC05XXsxLDR9Oil7MCw0fXwoW2EtZjAtOV17MSw0fTopezN9OihbYS1mMC05XXsxLDR9Oil7MCwzfXwoW2EtZjAtOV17MSw0fTopezR9OihbYS1mMC05XXsxLDR9Oil7MCwyfXwoW2EtZjAtOV17MSw0fTopezV9OihbYS1mMC05XXsxLDR9Oil7MCwxfSkoW2EtZjAtOV17MSw0fXwoKCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXC4pezN9KCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSkpXFxdKXwoW0EtWmEtejAtOV0oW0EtWmEtejAtOS1dKltBLVphLXowLTldKSooXFwuW0EtWmEtel17Mix9KSspKSQvO1xyXG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cclxuLy8gICAvXlthLXpBLVowLTlcXC5cXCFcXCNcXCRcXCVcXCZcXCdcXCpcXCtcXC9cXD1cXD9cXF5cXF9cXGBcXHtcXHxcXH1cXH5cXC1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKiQvO1xyXG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cclxuLy8gICAvXig/OlthLXowLTkhIyQlJicqKy89P15fYHt8fX4tXSsoPzpcXC5bYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKSp8XCIoPzpbXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHgyMVxceDIzLVxceDViXFx4NWQtXFx4N2ZdfFxcXFxbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGUtXFx4N2ZdKSpcIilAKD86KD86W2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pP1xcLikrW2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pP3xcXFsoPzooPzoyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldP3xbYS16MC05LV0qW2EtejAtOV06KD86W1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4MjEtXFx4NWFcXHg1My1cXHg3Zl18XFxcXFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZS1cXHg3Zl0pKylcXF0pJC9pO1xyXG5jb25zdCBlbWFpbFJlZ2V4ID0gL14oPyFcXC4pKD8hLipcXC5cXC4pKFtBLVowLTlfJytcXC1cXC5dKilbQS1aMC05XystXUAoW0EtWjAtOV1bQS1aMC05XFwtXSpcXC4pK1tBLVpdezIsfSQvaTtcclxuLy8gY29uc3QgZW1haWxSZWdleCA9XHJcbi8vICAgL15bYS16MC05LiEjJCUm4oCZKisvPT9eX2B7fH1+LV0rQFthLXowLTktXSsoPzpcXC5bYS16MC05XFwtXSspKiQvaTtcclxuLy8gZnJvbSBodHRwczovL3RoZWtldmluc2NvdHQuY29tL2Vtb2ppcy1pbi1qYXZhc2NyaXB0LyN3cml0aW5nLWEtcmVndWxhci1leHByZXNzaW9uXHJcbmNvbnN0IF9lbW9qaVJlZ2V4ID0gYF4oXFxcXHB7RXh0ZW5kZWRfUGljdG9ncmFwaGljfXxcXFxccHtFbW9qaV9Db21wb25lbnR9KSskYDtcclxubGV0IGVtb2ppUmVnZXg7XHJcbi8vIGZhc3Rlciwgc2ltcGxlciwgc2FmZXJcclxuY29uc3QgaXB2NFJlZ2V4ID0gL14oPzooPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSkkLztcclxuY29uc3QgaXB2NENpZHJSZWdleCA9IC9eKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwvKDNbMC0yXXxbMTJdP1swLTldKSQvO1xyXG4vLyBjb25zdCBpcHY2UmVnZXggPVxyXG4vLyAvXigoW2EtZjAtOV17MSw0fTopezd9fDo6KFthLWYwLTldezEsNH06KXswLDZ9fChbYS1mMC05XXsxLDR9Oil7MX06KFthLWYwLTldezEsNH06KXswLDV9fChbYS1mMC05XXsxLDR9Oil7Mn06KFthLWYwLTldezEsNH06KXswLDR9fChbYS1mMC05XXsxLDR9Oil7M306KFthLWYwLTldezEsNH06KXswLDN9fChbYS1mMC05XXsxLDR9Oil7NH06KFthLWYwLTldezEsNH06KXswLDJ9fChbYS1mMC05XXsxLDR9Oil7NX06KFthLWYwLTldezEsNH06KXswLDF9KShbYS1mMC05XXsxLDR9fCgoKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcLil7M30oKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKSkkLztcclxuY29uc3QgaXB2NlJlZ2V4ID0gL14oKFswLTlhLWZBLUZdezEsNH06KXs3LDd9WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsN306fChbMC05YS1mQS1GXXsxLDR9Oil7MSw2fTpbMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw1fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwyfXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH0oOlswLTlhLWZBLUZdezEsNH0pezEsM318KFswLTlhLWZBLUZdezEsNH06KXsxLDN9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwyfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw1fXxbMC05YS1mQS1GXXsxLDR9OigoOlswLTlhLWZBLUZdezEsNH0pezEsNn0pfDooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDd9fDopfGZlODA6KDpbMC05YS1mQS1GXXswLDR9KXswLDR9JVswLTlhLXpBLVpdezEsfXw6OihmZmZmKDowezEsNH0pezAsMX06KXswLDF9KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pfChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fTooKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSkpJC87XHJcbmNvbnN0IGlwdjZDaWRyUmVnZXggPSAvXigoWzAtOWEtZkEtRl17MSw0fTopezcsN31bMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw3fTp8KFswLTlhLWZBLUZdezEsNH06KXsxLDZ9OlswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDV9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDJ9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwzfXwoWzAtOWEtZkEtRl17MSw0fTopezEsM30oOlswLTlhLWZBLUZdezEsNH0pezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDJ9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDV9fFswLTlhLWZBLUZdezEsNH06KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw2fSl8OigoOlswLTlhLWZBLUZdezEsNH0pezEsN318Oil8ZmU4MDooOlswLTlhLWZBLUZdezAsNH0pezAsNH0lWzAtOWEtekEtWl17MSx9fDo6KGZmZmYoOjB7MSw0fSl7MCwxfTopezAsMX0oKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSl8KFswLTlhLWZBLUZdezEsNH06KXsxLDR9OigoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKSlcXC8oMTJbMC04XXwxWzAxXVswLTldfFsxLTldP1swLTldKSQvO1xyXG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83ODYwMzkyL2RldGVybWluZS1pZi1zdHJpbmctaXMtaW4tYmFzZTY0LXVzaW5nLWphdmFzY3JpcHRcclxuY29uc3QgYmFzZTY0UmVnZXggPSAvXihbMC05YS16QS1aKy9dezR9KSooKFswLTlhLXpBLVorL117Mn09PSl8KFswLTlhLXpBLVorL117M309KSk/JC87XHJcbi8vIGh0dHBzOi8vYmFzZTY0Lmd1cnUvc3RhbmRhcmRzL2Jhc2U2NHVybFxyXG5jb25zdCBiYXNlNjR1cmxSZWdleCA9IC9eKFswLTlhLXpBLVotX117NH0pKigoWzAtOWEtekEtWi1fXXsyfSg9PSk/KXwoWzAtOWEtekEtWi1fXXszfSg9KT8pKT8kLztcclxuLy8gc2ltcGxlXHJcbi8vIGNvbnN0IGRhdGVSZWdleFNvdXJjZSA9IGBcXFxcZHs0fS1cXFxcZHsyfS1cXFxcZHsyfWA7XHJcbi8vIG5vIGxlYXAgeWVhciB2YWxpZGF0aW9uXHJcbi8vIGNvbnN0IGRhdGVSZWdleFNvdXJjZSA9IGBcXFxcZHs0fS0oKDBbMTM1NzhdfDEwfDEyKS0zMXwoMFsxMy05XXwxWzAtMl0pLTMwfCgwWzEtOV18MVswLTJdKS0oMFsxLTldfDFcXFxcZHwyXFxcXGQpKWA7XHJcbi8vIHdpdGggbGVhcCB5ZWFyIHZhbGlkYXRpb25cclxuY29uc3QgZGF0ZVJlZ2V4U291cmNlID0gYCgoXFxcXGRcXFxcZFsyNDY4XVswNDhdfFxcXFxkXFxcXGRbMTM1NzldWzI2XXxcXFxcZFxcXFxkMFs0OF18WzAyNDY4XVswNDhdMDB8WzEzNTc5XVsyNl0wMCktMDItMjl8XFxcXGR7NH0tKCgwWzEzNTc4XXwxWzAyXSktKDBbMS05XXxbMTJdXFxcXGR8M1swMV0pfCgwWzQ2OV18MTEpLSgwWzEtOV18WzEyXVxcXFxkfDMwKXwoMDIpLSgwWzEtOV18MVxcXFxkfDJbMC04XSkpKWA7XHJcbmNvbnN0IGRhdGVSZWdleCA9IG5ldyBSZWdFeHAoYF4ke2RhdGVSZWdleFNvdXJjZX0kYCk7XHJcbmZ1bmN0aW9uIHRpbWVSZWdleFNvdXJjZShhcmdzKSB7XHJcbiAgICAvLyBsZXQgcmVnZXggPSBgXFxcXGR7Mn06XFxcXGR7Mn06XFxcXGR7Mn1gO1xyXG4gICAgbGV0IHJlZ2V4ID0gYChbMDFdXFxcXGR8MlswLTNdKTpbMC01XVxcXFxkOlswLTVdXFxcXGRgO1xyXG4gICAgaWYgKGFyZ3MucHJlY2lzaW9uKSB7XHJcbiAgICAgICAgcmVnZXggPSBgJHtyZWdleH1cXFxcLlxcXFxkeyR7YXJncy5wcmVjaXNpb259fWA7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChhcmdzLnByZWNpc2lvbiA9PSBudWxsKSB7XHJcbiAgICAgICAgcmVnZXggPSBgJHtyZWdleH0oXFxcXC5cXFxcZCspP2A7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVnZXg7XHJcbn1cclxuZnVuY3Rpb24gdGltZVJlZ2V4KGFyZ3MpIHtcclxuICAgIHJldHVybiBuZXcgUmVnRXhwKGBeJHt0aW1lUmVnZXhTb3VyY2UoYXJncyl9JGApO1xyXG59XHJcbi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzE0MzIzMVxyXG5mdW5jdGlvbiBkYXRldGltZVJlZ2V4KGFyZ3MpIHtcclxuICAgIGxldCByZWdleCA9IGAke2RhdGVSZWdleFNvdXJjZX1UJHt0aW1lUmVnZXhTb3VyY2UoYXJncyl9YDtcclxuICAgIGNvbnN0IG9wdHMgPSBbXTtcclxuICAgIG9wdHMucHVzaChhcmdzLmxvY2FsID8gYFo/YCA6IGBaYCk7XHJcbiAgICBpZiAoYXJncy5vZmZzZXQpXHJcbiAgICAgICAgb3B0cy5wdXNoKGAoWystXVxcXFxkezJ9Oj9cXFxcZHsyfSlgKTtcclxuICAgIHJlZ2V4ID0gYCR7cmVnZXh9KCR7b3B0cy5qb2luKFwifFwiKX0pYDtcclxuICAgIHJldHVybiBuZXcgUmVnRXhwKGBeJHtyZWdleH0kYCk7XHJcbn1cclxuZnVuY3Rpb24gaXNWYWxpZElQKGlwLCB2ZXJzaW9uKSB7XHJcbiAgICBpZiAoKHZlcnNpb24gPT09IFwidjRcIiB8fCAhdmVyc2lvbikgJiYgaXB2NFJlZ2V4LnRlc3QoaXApKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoKHZlcnNpb24gPT09IFwidjZcIiB8fCAhdmVyc2lvbikgJiYgaXB2NlJlZ2V4LnRlc3QoaXApKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gaXNWYWxpZEpXVChqd3QsIGFsZykge1xyXG4gICAgaWYgKCFqd3RSZWdleC50ZXN0KGp3dCkpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBbaGVhZGVyXSA9IGp3dC5zcGxpdChcIi5cIik7XHJcbiAgICAgICAgLy8gQ29udmVydCBiYXNlNjR1cmwgdG8gYmFzZTY0XHJcbiAgICAgICAgY29uc3QgYmFzZTY0ID0gaGVhZGVyXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC8tL2csIFwiK1wiKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvXy9nLCBcIi9cIilcclxuICAgICAgICAgICAgLnBhZEVuZChoZWFkZXIubGVuZ3RoICsgKCg0IC0gKGhlYWRlci5sZW5ndGggJSA0KSkgJSA0KSwgXCI9XCIpO1xyXG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSBKU09OLnBhcnNlKGF0b2IoYmFzZTY0KSk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBkZWNvZGVkICE9PSBcIm9iamVjdFwiIHx8IGRlY29kZWQgPT09IG51bGwpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAoIWRlY29kZWQudHlwIHx8ICFkZWNvZGVkLmFsZylcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmIChhbGcgJiYgZGVjb2RlZC5hbGcgIT09IGFsZylcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzVmFsaWRDaWRyKGlwLCB2ZXJzaW9uKSB7XHJcbiAgICBpZiAoKHZlcnNpb24gPT09IFwidjRcIiB8fCAhdmVyc2lvbikgJiYgaXB2NENpZHJSZWdleC50ZXN0KGlwKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKCh2ZXJzaW9uID09PSBcInY2XCIgfHwgIXZlcnNpb24pICYmIGlwdjZDaWRyUmVnZXgudGVzdChpcCkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5jbGFzcyBab2RTdHJpbmcgZXh0ZW5kcyBab2RUeXBlIHtcclxuICAgIF9wYXJzZShpbnB1dCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XHJcbiAgICAgICAgICAgIGlucHV0LmRhdGEgPSBTdHJpbmcoaW5wdXQuZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcclxuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zdHJpbmcpIHtcclxuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xyXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXHJcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5zdHJpbmcsXHJcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XHJcbiAgICAgICAgbGV0IGN0eCA9IHVuZGVmaW5lZDtcclxuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcclxuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmxlbmd0aCA8IGNoZWNrLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5sZW5ndGggPiBjaGVjay52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibGVuZ3RoXCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGlucHV0LmRhdGEubGVuZ3RoID4gY2hlY2sudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0b29TbWFsbCA9IGlucHV0LmRhdGEubGVuZ3RoIDwgY2hlY2sudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9vQmlnIHx8IHRvb1NtYWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvb0JpZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG9vU21hbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJlbWFpbFwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWVtYWlsUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImVtYWlsXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImVtb2ppXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZW1vamlSZWdleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVtb2ppUmVnZXggPSBuZXcgUmVnRXhwKF9lbW9qaVJlZ2V4LCBcInVcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWVtb2ppUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImVtb2ppXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInV1aWRcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF1dWlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInV1aWRcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibmFub2lkXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghbmFub2lkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcIm5hbm9pZFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjdWlkXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghY3VpZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJjdWlkXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImN1aWQyXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghY3VpZDJSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiY3VpZDJcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidWxpZFwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXVsaWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidWxpZFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1cmxcIikge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBuZXcgVVJMKGlucHV0LmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidXJsXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInJlZ2V4XCIpIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrLnJlZ2V4Lmxhc3RJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0UmVzdWx0ID0gY2hlY2sucmVnZXgudGVzdChpbnB1dC5kYXRhKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGVzdFJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInJlZ2V4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRyaW1cIikge1xyXG4gICAgICAgICAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudHJpbSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiaW5jbHVkZXNcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5kYXRhLmluY2x1ZGVzKGNoZWNrLnZhbHVlLCBjaGVjay5wb3NpdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IGluY2x1ZGVzOiBjaGVjay52YWx1ZSwgcG9zaXRpb246IGNoZWNrLnBvc2l0aW9uIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0b0xvd2VyQ2FzZVwiKSB7XHJcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gaW5wdXQuZGF0YS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidG9VcHBlckNhc2VcIikge1xyXG4gICAgICAgICAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudG9VcHBlckNhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInN0YXJ0c1dpdGhcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5kYXRhLnN0YXJ0c1dpdGgoY2hlY2sudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogeyBzdGFydHNXaXRoOiBjaGVjay52YWx1ZSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW5kc1dpdGhcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5kYXRhLmVuZHNXaXRoKGNoZWNrLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IHsgZW5kc1dpdGg6IGNoZWNrLnZhbHVlIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJkYXRldGltZVwiKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IGRhdGV0aW1lUmVnZXgoY2hlY2spO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJkYXRldGltZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZGF0ZVwiKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IGRhdGVSZWdleDtcclxuICAgICAgICAgICAgICAgIGlmICghcmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZGF0ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidGltZVwiKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IHRpbWVSZWdleChjaGVjayk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInRpbWVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImR1cmF0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZHVyYXRpb25SZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZHVyYXRpb25cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiaXBcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkSVAoaW5wdXQuZGF0YSwgY2hlY2sudmVyc2lvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJpcFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJqd3RcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkSldUKGlucHV0LmRhdGEsIGNoZWNrLmFsZykpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJqd3RcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiY2lkclwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRDaWRyKGlucHV0LmRhdGEsIGNoZWNrLnZlcnNpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiY2lkclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJiYXNlNjRcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFiYXNlNjRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiYmFzZTY0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImJhc2U2NHVybFwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWJhc2U2NHVybFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJiYXNlNjR1cmxcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbnB1dC5kYXRhIH07XHJcbiAgICB9XHJcbiAgICBfcmVnZXgocmVnZXgsIHZhbGlkYXRpb24sIG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWZpbmVtZW50KChkYXRhKSA9PiByZWdleC50ZXN0KGRhdGEpLCB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRpb24sXHJcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcclxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVtYWlsKG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImVtYWlsXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcclxuICAgIH1cclxuICAgIHVybChtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1cmxcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xyXG4gICAgfVxyXG4gICAgZW1vamkobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZW1vamlcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xyXG4gICAgfVxyXG4gICAgdXVpZChtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1dWlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcclxuICAgIH1cclxuICAgIG5hbm9pZChtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJuYW5vaWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xyXG4gICAgfVxyXG4gICAgY3VpZChtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJjdWlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcclxuICAgIH1cclxuICAgIGN1aWQyKG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImN1aWQyXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcclxuICAgIH1cclxuICAgIHVsaWQobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidWxpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XHJcbiAgICB9XHJcbiAgICBiYXNlNjQobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiYmFzZTY0XCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcclxuICAgIH1cclxuICAgIGJhc2U2NHVybChtZXNzYWdlKSB7XHJcbiAgICAgICAgLy8gYmFzZTY0dXJsIGVuY29kaW5nIGlzIGEgbW9kaWZpY2F0aW9uIG9mIGJhc2U2NCB0aGF0IGNhbiBzYWZlbHkgYmUgdXNlZCBpbiBVUkxzIGFuZCBmaWxlbmFtZXNcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xyXG4gICAgICAgICAgICBraW5kOiBcImJhc2U2NHVybFwiLFxyXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBqd3Qob3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiand0XCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zKSB9KTtcclxuICAgIH1cclxuICAgIGlwKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImlwXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zKSB9KTtcclxuICAgIH1cclxuICAgIGNpZHIob3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiY2lkclwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucykgfSk7XHJcbiAgICB9XHJcbiAgICBkYXRldGltZShvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcclxuICAgICAgICAgICAgICAgIGtpbmQ6IFwiZGF0ZXRpbWVcIixcclxuICAgICAgICAgICAgICAgIHByZWNpc2lvbjogbnVsbCxcclxuICAgICAgICAgICAgICAgIG9mZnNldDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBsb2NhbDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcclxuICAgICAgICAgICAga2luZDogXCJkYXRldGltZVwiLFxyXG4gICAgICAgICAgICBwcmVjaXNpb246IHR5cGVvZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZWNpc2lvbikgPT09IFwidW5kZWZpbmVkXCIgPyBudWxsIDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZWNpc2lvbixcclxuICAgICAgICAgICAgb2Zmc2V0OiAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub2Zmc2V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZSxcclxuICAgICAgICAgICAgbG9jYWw6IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2NhbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2UsXHJcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWVzc2FnZSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBkYXRlKG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImRhdGVcIiwgbWVzc2FnZSB9KTtcclxuICAgIH1cclxuICAgIHRpbWUob3B0aW9ucykge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xyXG4gICAgICAgICAgICAgICAga2luZDogXCJ0aW1lXCIsXHJcbiAgICAgICAgICAgICAgICBwcmVjaXNpb246IG51bGwsXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcclxuICAgICAgICAgICAga2luZDogXCJ0aW1lXCIsXHJcbiAgICAgICAgICAgIHByZWNpc2lvbjogdHlwZW9mIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJlY2lzaW9uKSA9PT0gXCJ1bmRlZmluZWRcIiA/IG51bGwgOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJlY2lzaW9uLFxyXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZHVyYXRpb24obWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZHVyYXRpb25cIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xyXG4gICAgfVxyXG4gICAgcmVnZXgocmVnZXgsIG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xyXG4gICAgICAgICAgICBraW5kOiBcInJlZ2V4XCIsXHJcbiAgICAgICAgICAgIHJlZ2V4OiByZWdleCxcclxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaW5jbHVkZXModmFsdWUsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xyXG4gICAgICAgICAgICBraW5kOiBcImluY2x1ZGVzXCIsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgcG9zaXRpb246IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wb3NpdGlvbixcclxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tZXNzYWdlKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHN0YXJ0c1dpdGgodmFsdWUsIG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xyXG4gICAgICAgICAgICBraW5kOiBcInN0YXJ0c1dpdGhcIixcclxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbmRzV2l0aCh2YWx1ZSwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XHJcbiAgICAgICAgICAgIGtpbmQ6IFwiZW5kc1dpdGhcIixcclxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBtaW4obWluTGVuZ3RoLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcclxuICAgICAgICAgICAga2luZDogXCJtaW5cIixcclxuICAgICAgICAgICAgdmFsdWU6IG1pbkxlbmd0aCxcclxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbWF4KG1heExlbmd0aCwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XHJcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXHJcbiAgICAgICAgICAgIHZhbHVlOiBtYXhMZW5ndGgsXHJcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGxlbmd0aChsZW4sIG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xyXG4gICAgICAgICAgICBraW5kOiBcImxlbmd0aFwiLFxyXG4gICAgICAgICAgICB2YWx1ZTogbGVuLFxyXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVxdWl2YWxlbnQgdG8gYC5taW4oMSlgXHJcbiAgICAgKi9cclxuICAgIG5vbmVtcHR5KG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5taW4oMSwgZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpKTtcclxuICAgIH1cclxuICAgIHRyaW0oKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIHsga2luZDogXCJ0cmltXCIgfV0sXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB0b0xvd2VyQ2FzZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRvTG93ZXJDYXNlXCIgfV0sXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB0b1VwcGVyQ2FzZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRvVXBwZXJDYXNlXCIgfV0sXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNEYXRldGltZSgpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImRhdGV0aW1lXCIpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzRGF0ZSgpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImRhdGVcIik7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNUaW1lKCkge1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidGltZVwiKTtcclxuICAgIH1cclxuICAgIGdldCBpc0R1cmF0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZHVyYXRpb25cIik7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNFbWFpbCgpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImVtYWlsXCIpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzVVJMKCkge1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidXJsXCIpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzRW1vamkoKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJlbW9qaVwiKTtcclxuICAgIH1cclxuICAgIGdldCBpc1VVSUQoKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1dWlkXCIpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzTkFOT0lEKCkge1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwibmFub2lkXCIpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzQ1VJRCgpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImN1aWRcIik7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNDVUlEMigpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImN1aWQyXCIpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzVUxJRCgpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInVsaWRcIik7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNJUCgpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImlwXCIpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzQ0lEUigpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImNpZHJcIik7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNCYXNlNjQoKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJiYXNlNjRcIik7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNCYXNlNjR1cmwoKSB7XHJcbiAgICAgICAgLy8gYmFzZTY0dXJsIGVuY29kaW5nIGlzIGEgbW9kaWZpY2F0aW9uIG9mIGJhc2U2NCB0aGF0IGNhbiBzYWZlbHkgYmUgdXNlZCBpbiBVUkxzIGFuZCBmaWxlbmFtZXNcclxuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImJhc2U2NHVybFwiKTtcclxuICAgIH1cclxuICAgIGdldCBtaW5MZW5ndGgoKSB7XHJcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XHJcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XHJcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxyXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtaW47XHJcbiAgICB9XHJcbiAgICBnZXQgbWF4TGVuZ3RoKCkge1xyXG4gICAgICAgIGxldCBtYXggPSBudWxsO1xyXG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xyXG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcclxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF4O1xyXG4gICAgfVxyXG59XHJcblpvZFN0cmluZy5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XHJcbiAgICAgICAgY2hlY2tzOiBbXSxcclxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFN0cmluZyxcclxuICAgICAgICBjb2VyY2U6IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zOTY2NDg0L3doeS1kb2VzLW1vZHVsdXMtb3BlcmF0b3ItcmV0dXJuLWZyYWN0aW9uYWwtbnVtYmVyLWluLWphdmFzY3JpcHQvMzE3MTEwMzQjMzE3MTEwMzRcclxuZnVuY3Rpb24gZmxvYXRTYWZlUmVtYWluZGVyKHZhbCwgc3RlcCkge1xyXG4gICAgY29uc3QgdmFsRGVjQ291bnQgPSAodmFsLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aDtcclxuICAgIGNvbnN0IHN0ZXBEZWNDb3VudCA9IChzdGVwLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aDtcclxuICAgIGNvbnN0IGRlY0NvdW50ID0gdmFsRGVjQ291bnQgPiBzdGVwRGVjQ291bnQgPyB2YWxEZWNDb3VudCA6IHN0ZXBEZWNDb3VudDtcclxuICAgIGNvbnN0IHZhbEludCA9IHBhcnNlSW50KHZhbC50b0ZpeGVkKGRlY0NvdW50KS5yZXBsYWNlKFwiLlwiLCBcIlwiKSk7XHJcbiAgICBjb25zdCBzdGVwSW50ID0gcGFyc2VJbnQoc3RlcC50b0ZpeGVkKGRlY0NvdW50KS5yZXBsYWNlKFwiLlwiLCBcIlwiKSk7XHJcbiAgICByZXR1cm4gKHZhbEludCAlIHN0ZXBJbnQpIC8gTWF0aC5wb3coMTAsIGRlY0NvdW50KTtcclxufVxyXG5jbGFzcyBab2ROdW1iZXIgZXh0ZW5kcyBab2RUeXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5taW4gPSB0aGlzLmd0ZTtcclxuICAgICAgICB0aGlzLm1heCA9IHRoaXMubHRlO1xyXG4gICAgICAgIHRoaXMuc3RlcCA9IHRoaXMubXVsdGlwbGVPZjtcclxuICAgIH1cclxuICAgIF9wYXJzZShpbnB1dCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XHJcbiAgICAgICAgICAgIGlucHV0LmRhdGEgPSBOdW1iZXIoaW5wdXQuZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcclxuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5udW1iZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xyXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXHJcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5udW1iZXIsXHJcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGN0eCA9IHVuZGVmaW5lZDtcclxuICAgICAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXMoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcclxuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwiaW50XCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdXRpbC5pc0ludGVnZXIoaW5wdXQuZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiaW50ZWdlclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlZDogXCJmbG9hdFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gY2hlY2suaW5jbHVzaXZlXHJcbiAgICAgICAgICAgICAgICAgICAgPyBpbnB1dC5kYXRhIDwgY2hlY2sudmFsdWVcclxuICAgICAgICAgICAgICAgICAgICA6IGlucHV0LmRhdGEgPD0gY2hlY2sudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9vU21hbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gY2hlY2suaW5jbHVzaXZlXHJcbiAgICAgICAgICAgICAgICAgICAgPyBpbnB1dC5kYXRhID4gY2hlY2sudmFsdWVcclxuICAgICAgICAgICAgICAgICAgICA6IGlucHV0LmRhdGEgPj0gY2hlY2sudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9vQmlnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm11bHRpcGxlT2ZcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZsb2F0U2FmZVJlbWFpbmRlcihpbnB1dC5kYXRhLCBjaGVjay52YWx1ZSkgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGVPZjogY2hlY2sudmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJmaW5pdGVcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoaW5wdXQuZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLm5vdF9maW5pdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcclxuICAgIH1cclxuICAgIGd0ZSh2YWx1ZSwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xyXG4gICAgfVxyXG4gICAgZ3QodmFsdWUsIG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XHJcbiAgICB9XHJcbiAgICBsdGUodmFsdWUsIG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcclxuICAgIH1cclxuICAgIGx0KHZhbHVlLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xyXG4gICAgfVxyXG4gICAgc2V0TGltaXQoa2luZCwgdmFsdWUsIGluY2x1c2l2ZSwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcclxuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxyXG4gICAgICAgICAgICBjaGVja3M6IFtcclxuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2RlZi5jaGVja3MsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAga2luZCxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmUsXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9hZGRDaGVjayhjaGVjaykge1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcclxuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxyXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja10sXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpbnQobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XHJcbiAgICAgICAgICAgIGtpbmQ6IFwiaW50XCIsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHBvc2l0aXZlKG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xyXG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxyXG4gICAgICAgICAgICB2YWx1ZTogMCxcclxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcclxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbmVnYXRpdmUobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XHJcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXHJcbiAgICAgICAgICAgIHZhbHVlOiAwLFxyXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBub25wb3NpdGl2ZShtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcclxuICAgICAgICAgICAga2luZDogXCJtYXhcIixcclxuICAgICAgICAgICAgdmFsdWU6IDAsXHJcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcclxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbm9ubmVnYXRpdmUobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XHJcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXHJcbiAgICAgICAgICAgIHZhbHVlOiAwLFxyXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIG11bHRpcGxlT2YodmFsdWUsIG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xyXG4gICAgICAgICAgICBraW5kOiBcIm11bHRpcGxlT2ZcIixcclxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmaW5pdGUobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XHJcbiAgICAgICAgICAgIGtpbmQ6IFwiZmluaXRlXCIsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHNhZmUobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XHJcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXHJcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXHJcbiAgICAgICAgfSkuX2FkZENoZWNrKHtcclxuICAgICAgICAgICAga2luZDogXCJtYXhcIixcclxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldCBtaW5WYWx1ZSgpIHtcclxuICAgICAgICBsZXQgbWluID0gbnVsbDtcclxuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcclxuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXHJcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1pbjtcclxuICAgIH1cclxuICAgIGdldCBtYXhWYWx1ZSgpIHtcclxuICAgICAgICBsZXQgbWF4ID0gbnVsbDtcclxuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcclxuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1heDtcclxuICAgIH1cclxuICAgIGdldCBpc0ludCgpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImludFwiIHx8XHJcbiAgICAgICAgICAgIChjaC5raW5kID09PSBcIm11bHRpcGxlT2ZcIiAmJiB1dGlsLmlzSW50ZWdlcihjaC52YWx1ZSkpKTtcclxuICAgIH1cclxuICAgIGdldCBpc0Zpbml0ZSgpIHtcclxuICAgICAgICBsZXQgbWF4ID0gbnVsbCwgbWluID0gbnVsbDtcclxuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcclxuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwiZmluaXRlXCIgfHxcclxuICAgICAgICAgICAgICAgIGNoLmtpbmQgPT09IFwiaW50XCIgfHxcclxuICAgICAgICAgICAgICAgIGNoLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxyXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShtaW4pICYmIE51bWJlci5pc0Zpbml0ZShtYXgpO1xyXG4gICAgfVxyXG59XHJcblpvZE51bWJlci5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XHJcbiAgICByZXR1cm4gbmV3IFpvZE51bWJlcih7XHJcbiAgICAgICAgY2hlY2tzOiBbXSxcclxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bWJlcixcclxuICAgICAgICBjb2VyY2U6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29lcmNlKSB8fCBmYWxzZSxcclxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXHJcbiAgICB9KTtcclxufTtcclxuY2xhc3MgWm9kQmlnSW50IGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMubWluID0gdGhpcy5ndGU7XHJcbiAgICAgICAgdGhpcy5tYXggPSB0aGlzLmx0ZTtcclxuICAgIH1cclxuICAgIF9wYXJzZShpbnB1dCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gQmlnSW50KGlucHV0LmRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEludmFsaWRJbnB1dChpbnB1dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xyXG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmJpZ2ludCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SW52YWxpZElucHV0KGlucHV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGN0eCA9IHVuZGVmaW5lZDtcclxuICAgICAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXMoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcclxuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gY2hlY2suaW5jbHVzaXZlXHJcbiAgICAgICAgICAgICAgICAgICAgPyBpbnB1dC5kYXRhIDwgY2hlY2sudmFsdWVcclxuICAgICAgICAgICAgICAgICAgICA6IGlucHV0LmRhdGEgPD0gY2hlY2sudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9vU21hbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJiaWdpbnRcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGNoZWNrLmluY2x1c2l2ZVxyXG4gICAgICAgICAgICAgICAgICAgID8gaW5wdXQuZGF0YSA+IGNoZWNrLnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgOiBpbnB1dC5kYXRhID49IGNoZWNrLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvb0JpZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJiaWdpbnRcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YSAlIGNoZWNrLnZhbHVlICE9PSBCaWdJbnQoMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGVPZjogY2hlY2sudmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcclxuICAgIH1cclxuICAgIF9nZXRJbnZhbGlkSW5wdXQoaW5wdXQpIHtcclxuICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XHJcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXHJcbiAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmJpZ2ludCxcclxuICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgfVxyXG4gICAgZ3RlKHZhbHVlLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XHJcbiAgICB9XHJcbiAgICBndCh2YWx1ZSwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcclxuICAgIH1cclxuICAgIGx0ZSh2YWx1ZSwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xyXG4gICAgfVxyXG4gICAgbHQodmFsdWUsIG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XHJcbiAgICB9XHJcbiAgICBzZXRMaW1pdChraW5kLCB2YWx1ZSwgaW5jbHVzaXZlLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RCaWdJbnQoe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIGNoZWNrczogW1xyXG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLmNoZWNrcyxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBraW5kLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZSxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RCaWdJbnQoe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHBvc2l0aXZlKG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xyXG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxyXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxyXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBuZWdhdGl2ZShtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcclxuICAgICAgICAgICAga2luZDogXCJtYXhcIixcclxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcclxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcclxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbm9ucG9zaXRpdmUobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XHJcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXHJcbiAgICAgICAgICAgIHZhbHVlOiBCaWdJbnQoMCksXHJcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcclxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbm9ubmVnYXRpdmUobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XHJcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXHJcbiAgICAgICAgICAgIHZhbHVlOiBCaWdJbnQoMCksXHJcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcclxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbXVsdGlwbGVPZih2YWx1ZSwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XHJcbiAgICAgICAgICAgIGtpbmQ6IFwibXVsdGlwbGVPZlwiLFxyXG4gICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0IG1pblZhbHVlKCkge1xyXG4gICAgICAgIGxldCBtaW4gPSBudWxsO1xyXG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xyXG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcclxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWluO1xyXG4gICAgfVxyXG4gICAgZ2V0IG1heFZhbHVlKCkge1xyXG4gICAgICAgIGxldCBtYXggPSBudWxsO1xyXG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xyXG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcclxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF4O1xyXG4gICAgfVxyXG59XHJcblpvZEJpZ0ludC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XHJcbiAgICAgICAgY2hlY2tzOiBbXSxcclxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJpZ0ludCxcclxuICAgICAgICBjb2VyY2U6IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2RCb29sZWFuIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xyXG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gQm9vbGVhbihpbnB1dC5kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xyXG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmJvb2xlYW4pIHtcclxuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xyXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXHJcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5ib29sZWFuLFxyXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcclxuICAgIH1cclxufVxyXG5ab2RCb29sZWFuLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kQm9vbGVhbih7XHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCb29sZWFuLFxyXG4gICAgICAgIGNvZXJjZTogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpIHx8IGZhbHNlLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2REYXRlIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xyXG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gbmV3IERhdGUoaW5wdXQuZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcclxuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5kYXRlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcclxuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxyXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuZGF0ZSxcclxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNOYU4oaW5wdXQuZGF0YS5nZXRUaW1lKCkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcclxuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9kYXRlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xyXG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5nZXRUaW1lKCkgPCBjaGVjay52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZGF0ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmdldFRpbWUoKSA+IGNoZWNrLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZGF0ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMudmFsdWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgRGF0ZShpbnB1dC5kYXRhLmdldFRpbWUoKSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIF9hZGRDaGVjayhjaGVjaykge1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kRGF0ZSh7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbWluKG1pbkRhdGUsIG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xyXG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxyXG4gICAgICAgICAgICB2YWx1ZTogbWluRGF0ZS5nZXRUaW1lKCksXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIG1heChtYXhEYXRlLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcclxuICAgICAgICAgICAga2luZDogXCJtYXhcIixcclxuICAgICAgICAgICAgdmFsdWU6IG1heERhdGUuZ2V0VGltZSgpLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXQgbWluRGF0ZSgpIHtcclxuICAgICAgICBsZXQgbWluID0gbnVsbDtcclxuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcclxuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXHJcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1pbiAhPSBudWxsID8gbmV3IERhdGUobWluKSA6IG51bGw7XHJcbiAgICB9XHJcbiAgICBnZXQgbWF4RGF0ZSgpIHtcclxuICAgICAgICBsZXQgbWF4ID0gbnVsbDtcclxuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcclxuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1heCAhPSBudWxsID8gbmV3IERhdGUobWF4KSA6IG51bGw7XHJcbiAgICB9XHJcbn1cclxuWm9kRGF0ZS5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XHJcbiAgICByZXR1cm4gbmV3IFpvZERhdGUoe1xyXG4gICAgICAgIGNoZWNrczogW10sXHJcbiAgICAgICAgY29lcmNlOiAocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvZXJjZSkgfHwgZmFsc2UsXHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REYXRlLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2RTeW1ib2wgZXh0ZW5kcyBab2RUeXBlIHtcclxuICAgIF9wYXJzZShpbnB1dCkge1xyXG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcclxuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zeW1ib2wpIHtcclxuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xyXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXHJcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5zeW1ib2wsXHJcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xyXG4gICAgfVxyXG59XHJcblpvZFN5bWJvbC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XHJcbiAgICByZXR1cm4gbmV3IFpvZFN5bWJvbCh7XHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTeW1ib2wsXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcbmNsYXNzIFpvZFVuZGVmaW5lZCBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xyXG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcclxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XHJcbiAgICB9XHJcbn1cclxuWm9kVW5kZWZpbmVkLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kVW5kZWZpbmVkKHtcclxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVuZGVmaW5lZCxcclxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXHJcbiAgICB9KTtcclxufTtcclxuY2xhc3MgWm9kTnVsbCBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xyXG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm51bGwpIHtcclxuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xyXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXHJcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5udWxsLFxyXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcclxuICAgIH1cclxufVxyXG5ab2ROdWxsLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kTnVsbCh7XHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdWxsLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2RBbnkgZXh0ZW5kcyBab2RUeXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgLy8gdG8gcHJldmVudCBpbnN0YW5jZXMgb2Ygb3RoZXIgY2xhc3NlcyBmcm9tIGV4dGVuZGluZyBab2RBbnkuIHRoaXMgY2F1c2VzIGlzc3VlcyB3aXRoIGNhdGNoYWxsIGluIFpvZE9iamVjdC5cclxuICAgICAgICB0aGlzLl9hbnkgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xyXG4gICAgfVxyXG59XHJcblpvZEFueS5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XHJcbiAgICByZXR1cm4gbmV3IFpvZEFueSh7XHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RBbnksXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcbmNsYXNzIFpvZFVua25vd24gZXh0ZW5kcyBab2RUeXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgLy8gcmVxdWlyZWRcclxuICAgICAgICB0aGlzLl91bmtub3duID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIF9wYXJzZShpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcclxuICAgIH1cclxufVxyXG5ab2RVbmtub3duLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kVW5rbm93bih7XHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmtub3duLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2ROZXZlciBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xyXG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxyXG4gICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5uZXZlcixcclxuICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgfVxyXG59XHJcblpvZE5ldmVyLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kTmV2ZXIoe1xyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmV2ZXIsXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcbmNsYXNzIFpvZFZvaWQgZXh0ZW5kcyBab2RUeXBlIHtcclxuICAgIF9wYXJzZShpbnB1dCkge1xyXG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcclxuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xyXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXHJcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS52b2lkLFxyXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcclxuICAgIH1cclxufVxyXG5ab2RWb2lkLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kVm9pZCh7XHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RWb2lkLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2RBcnJheSBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgeyBjdHgsIHN0YXR1cyB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcclxuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLl9kZWY7XHJcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcclxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmFycmF5LFxyXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZWYuZXhhY3RMZW5ndGggIT09IG51bGwpIHtcclxuICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gY3R4LmRhdGEubGVuZ3RoID4gZGVmLmV4YWN0TGVuZ3RoLnZhbHVlO1xyXG4gICAgICAgICAgICBjb25zdCB0b29TbWFsbCA9IGN0eC5kYXRhLmxlbmd0aCA8IGRlZi5leGFjdExlbmd0aC52YWx1ZTtcclxuICAgICAgICAgICAgaWYgKHRvb0JpZyB8fCB0b29TbWFsbCkge1xyXG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZTogdG9vQmlnID8gWm9kSXNzdWVDb2RlLnRvb19iaWcgOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06ICh0b29TbWFsbCA/IGRlZi5leGFjdExlbmd0aC52YWx1ZSA6IHVuZGVmaW5lZCksXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogKHRvb0JpZyA/IGRlZi5leGFjdExlbmd0aC52YWx1ZSA6IHVuZGVmaW5lZCksXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYuZXhhY3RMZW5ndGgubWVzc2FnZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlZi5taW5MZW5ndGggIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA8IGRlZi5taW5MZW5ndGgudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXHJcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogZGVmLm1pbkxlbmd0aC52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWluTGVuZ3RoLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZWYubWF4TGVuZ3RoICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPiBkZWYubWF4TGVuZ3RoLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcclxuICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBkZWYubWF4TGVuZ3RoLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcclxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5tYXhMZW5ndGgubWVzc2FnZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmLnR5cGUuX3BhcnNlQXN5bmMobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpKSk7XHJcbiAgICAgICAgICAgIH0pKS50aGVuKChyZXN1bHQpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBkZWYudHlwZS5fcGFyc2VTeW5jKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcclxuICAgIH1cclxuICAgIGdldCBlbGVtZW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcclxuICAgIH1cclxuICAgIG1pbihtaW5MZW5ndGgsIG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcclxuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxyXG4gICAgICAgICAgICBtaW5MZW5ndGg6IHsgdmFsdWU6IG1pbkxlbmd0aCwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBtYXgobWF4TGVuZ3RoLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAgICAgbWF4TGVuZ3RoOiB7IHZhbHVlOiBtYXhMZW5ndGgsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbGVuZ3RoKGxlbiwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIGV4YWN0TGVuZ3RoOiB7IHZhbHVlOiBsZW4sIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbm9uZW1wdHkobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1pbigxLCBtZXNzYWdlKTtcclxuICAgIH1cclxufVxyXG5ab2RBcnJheS5jcmVhdGUgPSAoc2NoZW1hLCBwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xyXG4gICAgICAgIHR5cGU6IHNjaGVtYSxcclxuICAgICAgICBtaW5MZW5ndGg6IG51bGwsXHJcbiAgICAgICAgbWF4TGVuZ3RoOiBudWxsLFxyXG4gICAgICAgIGV4YWN0TGVuZ3RoOiBudWxsLFxyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQXJyYXksXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcbmZ1bmN0aW9uIGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYSkge1xyXG4gICAgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZE9iamVjdCkge1xyXG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hLnNoYXBlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gc2NoZW1hLnNoYXBlW2tleV07XHJcbiAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBab2RPcHRpb25hbC5jcmVhdGUoZGVlcFBhcnRpYWxpZnkoZmllbGRTY2hlbWEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xyXG4gICAgICAgICAgICAuLi5zY2hlbWEuX2RlZixcclxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kQXJyYXkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcclxuICAgICAgICAgICAgLi4uc2NoZW1hLl9kZWYsXHJcbiAgICAgICAgICAgIHR5cGU6IGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS5lbGVtZW50KSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZE9wdGlvbmFsKSB7XHJcbiAgICAgICAgcmV0dXJuIFpvZE9wdGlvbmFsLmNyZWF0ZShkZWVwUGFydGlhbGlmeShzY2hlbWEudW53cmFwKCkpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZE51bGxhYmxlKSB7XHJcbiAgICAgICAgcmV0dXJuIFpvZE51bGxhYmxlLmNyZWF0ZShkZWVwUGFydGlhbGlmeShzY2hlbWEudW53cmFwKCkpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZFR1cGxlKSB7XHJcbiAgICAgICAgcmV0dXJuIFpvZFR1cGxlLmNyZWF0ZShzY2hlbWEuaXRlbXMubWFwKChpdGVtKSA9PiBkZWVwUGFydGlhbGlmeShpdGVtKSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBab2RPYmplY3QgZXh0ZW5kcyBab2RUeXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5fY2FjaGVkID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBJbiBtb3N0IGNhc2VzLCB0aGlzIGlzIG5vIGxvbmdlciBuZWVkZWQgLSB1bmtub3duIHByb3BlcnRpZXMgYXJlIG5vdyBzaWxlbnRseSBzdHJpcHBlZC5cclxuICAgICAgICAgKiBJZiB5b3Ugd2FudCB0byBwYXNzIHRocm91Z2ggdW5rbm93biBwcm9wZXJ0aWVzLCB1c2UgYC5wYXNzdGhyb3VnaCgpYCBpbnN0ZWFkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubm9uc3RyaWN0ID0gdGhpcy5wYXNzdGhyb3VnaDtcclxuICAgICAgICAvLyBleHRlbmQ8XHJcbiAgICAgICAgLy8gICBBdWdtZW50YXRpb24gZXh0ZW5kcyBab2RSYXdTaGFwZSxcclxuICAgICAgICAvLyAgIE5ld091dHB1dCBleHRlbmRzIHV0aWwuZmxhdHRlbjx7XHJcbiAgICAgICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIE91dHB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cclxuICAgICAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9vdXRwdXRcIl1cclxuICAgICAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBPdXRwdXRcclxuICAgICAgICAvLyAgICAgICA/IE91dHB1dFtrXVxyXG4gICAgICAgIC8vICAgICAgIDogbmV2ZXI7XHJcbiAgICAgICAgLy8gICB9PixcclxuICAgICAgICAvLyAgIE5ld0lucHV0IGV4dGVuZHMgdXRpbC5mbGF0dGVuPHtcclxuICAgICAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgSW5wdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXHJcbiAgICAgICAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfaW5wdXRcIl1cclxuICAgICAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBJbnB1dFxyXG4gICAgICAgIC8vICAgICAgID8gSW5wdXRba11cclxuICAgICAgICAvLyAgICAgICA6IG5ldmVyO1xyXG4gICAgICAgIC8vICAgfT5cclxuICAgICAgICAvLyA+KFxyXG4gICAgICAgIC8vICAgYXVnbWVudGF0aW9uOiBBdWdtZW50YXRpb25cclxuICAgICAgICAvLyApOiBab2RPYmplY3Q8XHJcbiAgICAgICAgLy8gICBleHRlbmRTaGFwZTxULCBBdWdtZW50YXRpb24+LFxyXG4gICAgICAgIC8vICAgVW5rbm93bktleXMsXHJcbiAgICAgICAgLy8gICBDYXRjaGFsbCxcclxuICAgICAgICAvLyAgIE5ld091dHB1dCxcclxuICAgICAgICAvLyAgIE5ld0lucHV0XHJcbiAgICAgICAgLy8gPiB7XHJcbiAgICAgICAgLy8gICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XHJcbiAgICAgICAgLy8gICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAvLyAgICAgc2hhcGU6ICgpID0+ICh7XHJcbiAgICAgICAgLy8gICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXHJcbiAgICAgICAgLy8gICAgICAgLi4uYXVnbWVudGF0aW9uLFxyXG4gICAgICAgIC8vICAgICB9KSxcclxuICAgICAgICAvLyAgIH0pIGFzIGFueTtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIGAuZXh0ZW5kYCBpbnN0ZWFkXHJcbiAgICAgICAgICogICovXHJcbiAgICAgICAgdGhpcy5hdWdtZW50ID0gdGhpcy5leHRlbmQ7XHJcbiAgICB9XHJcbiAgICBfZ2V0Q2FjaGVkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jYWNoZWQgIT09IG51bGwpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWQ7XHJcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB0aGlzLl9kZWYuc2hhcGUoKTtcclxuICAgICAgICBjb25zdCBrZXlzID0gdXRpbC5vYmplY3RLZXlzKHNoYXBlKTtcclxuICAgICAgICByZXR1cm4gKHRoaXMuX2NhY2hlZCA9IHsgc2hhcGUsIGtleXMgfSk7XHJcbiAgICB9XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XHJcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcclxuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxyXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxyXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XHJcbiAgICAgICAgY29uc3QgeyBzaGFwZSwga2V5czogc2hhcGVLZXlzIH0gPSB0aGlzLl9nZXRDYWNoZWQoKTtcclxuICAgICAgICBjb25zdCBleHRyYUtleXMgPSBbXTtcclxuICAgICAgICBpZiAoISh0aGlzLl9kZWYuY2F0Y2hhbGwgaW5zdGFuY2VvZiBab2ROZXZlciAmJlxyXG4gICAgICAgICAgICB0aGlzLl9kZWYudW5rbm93bktleXMgPT09IFwic3RyaXBcIikpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3R4LmRhdGEpIHtcclxuICAgICAgICAgICAgICAgIGlmICghc2hhcGVLZXlzLmluY2x1ZGVzKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHRyYUtleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhaXJzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Ygc2hhcGVLZXlzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleVZhbGlkYXRvciA9IHNoYXBlW2tleV07XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3R4LmRhdGFba2V5XTtcclxuICAgICAgICAgICAgcGFpcnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBrZXkgfSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBrZXlWYWxpZGF0b3IuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkpLFxyXG4gICAgICAgICAgICAgICAgYWx3YXlzU2V0OiBrZXkgaW4gY3R4LmRhdGEsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fZGVmLmNhdGNoYWxsIGluc3RhbmNlb2YgWm9kTmV2ZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgdW5rbm93bktleXMgPSB0aGlzLl9kZWYudW5rbm93bktleXM7XHJcbiAgICAgICAgICAgIGlmICh1bmtub3duS2V5cyA9PT0gXCJwYXNzdGhyb3VnaFwiKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBleHRyYUtleXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYWlycy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogY3R4LmRhdGFba2V5XSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHVua25vd25LZXlzID09PSBcInN0cmljdFwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmFLZXlzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnVucmVjb2duaXplZF9rZXlzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiBleHRyYUtleXMsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodW5rbm93bktleXMgPT09IFwic3RyaXBcIikgO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW50ZXJuYWwgWm9kT2JqZWN0IGVycm9yOiBpbnZhbGlkIHVua25vd25LZXlzIHZhbHVlLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBydW4gY2F0Y2hhbGwgdmFsaWRhdGlvblxyXG4gICAgICAgICAgICBjb25zdCBjYXRjaGFsbCA9IHRoaXMuX2RlZi5jYXRjaGFsbDtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZXh0cmFLZXlzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGN0eC5kYXRhW2tleV07XHJcbiAgICAgICAgICAgICAgICBwYWlycy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBrZXkgfSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2F0Y2hhbGwuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkgLy8sIGN0eC5jaGlsZChrZXkpLCB2YWx1ZSwgZ2V0UGFyc2VkVHlwZSh2YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgICAgIGFsd2F5c1NldDoga2V5IGluIGN0eC5kYXRhLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXHJcbiAgICAgICAgICAgICAgICAudGhlbihhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzeW5jUGFpcnMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHBhaXIua2V5O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcGFpci52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBzeW5jUGFpcnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsd2F5c1NldDogcGFpci5hbHdheXNTZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3luY1BhaXJzO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKHN5bmNQYWlycykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHN5bmNQYWlycyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgc2hhcGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zaGFwZSgpO1xyXG4gICAgfVxyXG4gICAgc3RyaWN0KG1lc3NhZ2UpIHtcclxuICAgICAgICBlcnJvclV0aWwuZXJyVG9PYmo7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBcInN0cmljdFwiLFxyXG4gICAgICAgICAgICAuLi4obWVzc2FnZSAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvck1hcDogKGlzc3VlLCBjdHgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWZhdWx0RXJyb3IgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLl9kZWYpLmVycm9yTWFwKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgaXNzdWUsIGN0eCkubWVzc2FnZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogY3R4LmRlZmF1bHRFcnJvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzc3VlLmNvZGUgPT09IFwidW5yZWNvZ25pemVkX2tleXNcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogKF9kID0gZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLm1lc3NhZ2UpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGRlZmF1bHRFcnJvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWZhdWx0RXJyb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIDoge30pLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc3RyaXAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBwYXNzdGhyb3VnaCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAgICAgdW5rbm93bktleXM6IFwicGFzc3Rocm91Z2hcIixcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIGNvbnN0IEF1Z21lbnRGYWN0b3J5ID1cclxuICAgIC8vICAgPERlZiBleHRlbmRzIFpvZE9iamVjdERlZj4oZGVmOiBEZWYpID0+XHJcbiAgICAvLyAgIDxBdWdtZW50YXRpb24gZXh0ZW5kcyBab2RSYXdTaGFwZT4oXHJcbiAgICAvLyAgICAgYXVnbWVudGF0aW9uOiBBdWdtZW50YXRpb25cclxuICAgIC8vICAgKTogWm9kT2JqZWN0PFxyXG4gICAgLy8gICAgIGV4dGVuZFNoYXBlPFJldHVyblR5cGU8RGVmW1wic2hhcGVcIl0+LCBBdWdtZW50YXRpb24+LFxyXG4gICAgLy8gICAgIERlZltcInVua25vd25LZXlzXCJdLFxyXG4gICAgLy8gICAgIERlZltcImNhdGNoYWxsXCJdXHJcbiAgICAvLyAgID4gPT4ge1xyXG4gICAgLy8gICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcclxuICAgIC8vICAgICAgIC4uLmRlZixcclxuICAgIC8vICAgICAgIHNoYXBlOiAoKSA9PiAoe1xyXG4gICAgLy8gICAgICAgICAuLi5kZWYuc2hhcGUoKSxcclxuICAgIC8vICAgICAgICAgLi4uYXVnbWVudGF0aW9uLFxyXG4gICAgLy8gICAgICAgfSksXHJcbiAgICAvLyAgICAgfSkgYXMgYW55O1xyXG4gICAgLy8gICB9O1xyXG4gICAgZXh0ZW5kKGF1Z21lbnRhdGlvbikge1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcclxuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxyXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gKHtcclxuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxyXG4gICAgICAgICAgICAgICAgLi4uYXVnbWVudGF0aW9uLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJpb3IgdG8gem9kQDEuMC4xMiB0aGVyZSB3YXMgYSBidWcgaW4gdGhlXHJcbiAgICAgKiBpbmZlcnJlZCB0eXBlIG9mIG1lcmdlZCBvYmplY3RzLiBQbGVhc2VcclxuICAgICAqIHVwZ3JhZGUgaWYgeW91IGFyZSBleHBlcmllbmNpbmcgaXNzdWVzLlxyXG4gICAgICovXHJcbiAgICBtZXJnZShtZXJnaW5nKSB7XHJcbiAgICAgICAgY29uc3QgbWVyZ2VkID0gbmV3IFpvZE9iamVjdCh7XHJcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXHJcbiAgICAgICAgICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXHJcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXHJcbiAgICAgICAgICAgICAgICAuLi5tZXJnaW5nLl9kZWYuc2hhcGUoKSxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBtZXJnZWQ7XHJcbiAgICB9XHJcbiAgICAvLyBtZXJnZTxcclxuICAgIC8vICAgSW5jb21pbmcgZXh0ZW5kcyBBbnlab2RPYmplY3QsXHJcbiAgICAvLyAgIEF1Z21lbnRhdGlvbiBleHRlbmRzIEluY29taW5nW1wic2hhcGVcIl0sXHJcbiAgICAvLyAgIE5ld091dHB1dCBleHRlbmRzIHtcclxuICAgIC8vICAgICBbayBpbiBrZXlvZiBBdWdtZW50YXRpb24gfCBrZXlvZiBPdXRwdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXHJcbiAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9vdXRwdXRcIl1cclxuICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIE91dHB1dFxyXG4gICAgLy8gICAgICAgPyBPdXRwdXRba11cclxuICAgIC8vICAgICAgIDogbmV2ZXI7XHJcbiAgICAvLyAgIH0sXHJcbiAgICAvLyAgIE5ld0lucHV0IGV4dGVuZHMge1xyXG4gICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIElucHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxyXG4gICAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfaW5wdXRcIl1cclxuICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIElucHV0XHJcbiAgICAvLyAgICAgICA/IElucHV0W2tdXHJcbiAgICAvLyAgICAgICA6IG5ldmVyO1xyXG4gICAgLy8gICB9XHJcbiAgICAvLyA+KFxyXG4gICAgLy8gICBtZXJnaW5nOiBJbmNvbWluZ1xyXG4gICAgLy8gKTogWm9kT2JqZWN0PFxyXG4gICAgLy8gICBleHRlbmRTaGFwZTxULCBSZXR1cm5UeXBlPEluY29taW5nW1wiX2RlZlwiXVtcInNoYXBlXCJdPj4sXHJcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcInVua25vd25LZXlzXCJdLFxyXG4gICAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJjYXRjaGFsbFwiXSxcclxuICAgIC8vICAgTmV3T3V0cHV0LFxyXG4gICAgLy8gICBOZXdJbnB1dFxyXG4gICAgLy8gPiB7XHJcbiAgICAvLyAgIGNvbnN0IG1lcmdlZDogYW55ID0gbmV3IFpvZE9iamVjdCh7XHJcbiAgICAvLyAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcclxuICAgIC8vICAgICBjYXRjaGFsbDogbWVyZ2luZy5fZGVmLmNhdGNoYWxsLFxyXG4gICAgLy8gICAgIHNoYXBlOiAoKSA9PlxyXG4gICAgLy8gICAgICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyh0aGlzLl9kZWYuc2hhcGUoKSwgbWVyZ2luZy5fZGVmLnNoYXBlKCkpLFxyXG4gICAgLy8gICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxyXG4gICAgLy8gICB9KSBhcyBhbnk7XHJcbiAgICAvLyAgIHJldHVybiBtZXJnZWQ7XHJcbiAgICAvLyB9XHJcbiAgICBzZXRLZXkoa2V5LCBzY2hlbWEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hdWdtZW50KHsgW2tleV06IHNjaGVtYSB9KTtcclxuICAgIH1cclxuICAgIC8vIG1lcmdlPEluY29taW5nIGV4dGVuZHMgQW55Wm9kT2JqZWN0PihcclxuICAgIC8vICAgbWVyZ2luZzogSW5jb21pbmdcclxuICAgIC8vICk6IC8vWm9kT2JqZWN0PFQgJiBJbmNvbWluZ1tcIl9zaGFwZVwiXSwgVW5rbm93bktleXMsIENhdGNoYWxsPiA9IChtZXJnaW5nKSA9PiB7XHJcbiAgICAvLyBab2RPYmplY3Q8XHJcbiAgICAvLyAgIGV4dGVuZFNoYXBlPFQsIFJldHVyblR5cGU8SW5jb21pbmdbXCJfZGVmXCJdW1wic2hhcGVcIl0+PixcclxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1widW5rbm93bktleXNcIl0sXHJcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcImNhdGNoYWxsXCJdXHJcbiAgICAvLyA+IHtcclxuICAgIC8vICAgLy8gY29uc3QgbWVyZ2VkU2hhcGUgPSBvYmplY3RVdGlsLm1lcmdlU2hhcGVzKFxyXG4gICAgLy8gICAvLyAgIHRoaXMuX2RlZi5zaGFwZSgpLFxyXG4gICAgLy8gICAvLyAgIG1lcmdpbmcuX2RlZi5zaGFwZSgpXHJcbiAgICAvLyAgIC8vICk7XHJcbiAgICAvLyAgIGNvbnN0IG1lcmdlZDogYW55ID0gbmV3IFpvZE9iamVjdCh7XHJcbiAgICAvLyAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcclxuICAgIC8vICAgICBjYXRjaGFsbDogbWVyZ2luZy5fZGVmLmNhdGNoYWxsLFxyXG4gICAgLy8gICAgIHNoYXBlOiAoKSA9PlxyXG4gICAgLy8gICAgICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyh0aGlzLl9kZWYuc2hhcGUoKSwgbWVyZ2luZy5fZGVmLnNoYXBlKCkpLFxyXG4gICAgLy8gICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxyXG4gICAgLy8gICB9KSBhcyBhbnk7XHJcbiAgICAvLyAgIHJldHVybiBtZXJnZWQ7XHJcbiAgICAvLyB9XHJcbiAgICBjYXRjaGFsbChpbmRleCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcclxuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxyXG4gICAgICAgICAgICBjYXRjaGFsbDogaW5kZXgsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBwaWNrKG1hc2spIHtcclxuICAgICAgICBjb25zdCBzaGFwZSA9IHt9O1xyXG4gICAgICAgIHV0aWwub2JqZWN0S2V5cyhtYXNrKS5mb3JFYWNoKChrZXkpID0+IHtcclxuICAgICAgICAgICAgaWYgKG1hc2tba2V5XSAmJiB0aGlzLnNoYXBlW2tleV0pIHtcclxuICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgb21pdChtYXNrKSB7XHJcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB7fTtcclxuICAgICAgICB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghbWFza1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqL1xyXG4gICAgZGVlcFBhcnRpYWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZXBQYXJ0aWFsaWZ5KHRoaXMpO1xyXG4gICAgfVxyXG4gICAgcGFydGlhbChtYXNrKSB7XHJcbiAgICAgICAgY29uc3QgbmV3U2hhcGUgPSB7fTtcclxuICAgICAgICB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gdGhpcy5zaGFwZVtrZXldO1xyXG4gICAgICAgICAgICBpZiAobWFzayAmJiAhbWFza1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gZmllbGRTY2hlbWE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gZmllbGRTY2hlbWEub3B0aW9uYWwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcclxuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxyXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGUsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXF1aXJlZChtYXNrKSB7XHJcbiAgICAgICAgY29uc3QgbmV3U2hhcGUgPSB7fTtcclxuICAgICAgICB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChtYXNrICYmICFtYXNrW2tleV0pIHtcclxuICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFNjaGVtYSA9IHRoaXMuc2hhcGVba2V5XTtcclxuICAgICAgICAgICAgICAgIGxldCBuZXdGaWVsZCA9IGZpZWxkU2NoZW1hO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKG5ld0ZpZWxkIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdGaWVsZCA9IG5ld0ZpZWxkLl9kZWYuaW5uZXJUeXBlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IG5ld0ZpZWxkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGtleW9mKCkge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVab2RFbnVtKHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKSk7XHJcbiAgICB9XHJcbn1cclxuWm9kT2JqZWN0LmNyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XHJcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XHJcbiAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxyXG4gICAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXHJcbiAgICAgICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5ab2RPYmplY3Quc3RyaWN0Q3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcclxuICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXHJcbiAgICAgICAgdW5rbm93bktleXM6IFwic3RyaWN0XCIsXHJcbiAgICAgICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5ab2RPYmplY3QubGF6eWNyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XHJcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XHJcbiAgICAgICAgc2hhcGUsXHJcbiAgICAgICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcclxuICAgICAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcbmNsYXNzIFpvZFVuaW9uIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcclxuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fZGVmLm9wdGlvbnM7XHJcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlUmVzdWx0cyhyZXN1bHRzKSB7XHJcbiAgICAgICAgICAgIC8vIHJldHVybiBmaXJzdCBpc3N1ZS1mcmVlIHZhbGlkYXRpb24gaWYgaXQgZXhpc3RzXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgaXNzdWVzIGZyb20gZGlydHkgb3B0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5pc3N1ZXMucHVzaCguLi5yZXN1bHQuY3R4LmNvbW1vbi5pc3N1ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHJldHVybiBpbnZhbGlkXHJcbiAgICAgICAgICAgIGNvbnN0IHVuaW9uRXJyb3JzID0gcmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4gbmV3IFpvZEVycm9yKHJlc3VsdC5jdHguY29tbW9uLmlzc3VlcykpO1xyXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uLFxyXG4gICAgICAgICAgICAgICAgdW5pb25FcnJvcnMsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKG9wdGlvbnMubWFwKGFzeW5jIChvcHRpb24pID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQ3R4ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLmN0eCxcclxuICAgICAgICAgICAgICAgICAgICBjb21tb246IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3R4LmNvbW1vbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogbnVsbCxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogYXdhaXQgb3B0aW9uLl9wYXJzZUFzeW5jKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGNoaWxkQ3R4LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIGN0eDogY2hpbGRDdHgsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KSkudGhlbihoYW5kbGVSZXN1bHRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBkaXJ0eSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgY29uc3QgaXNzdWVzID0gW107XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQ3R4ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLmN0eCxcclxuICAgICAgICAgICAgICAgICAgICBjb21tb246IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3R4LmNvbW1vbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogbnVsbCxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBvcHRpb24uX3BhcnNlU3luYyh7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjaGlsZEN0eCxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIgJiYgIWRpcnR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlydHkgPSB7IHJlc3VsdCwgY3R4OiBjaGlsZEN0eCB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkQ3R4LmNvbW1vbi5pc3N1ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNzdWVzLnB1c2goY2hpbGRDdHguY29tbW9uLmlzc3Vlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRpcnR5KSB7XHJcbiAgICAgICAgICAgICAgICBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKC4uLmRpcnR5LmN0eC5jb21tb24uaXNzdWVzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkaXJ0eS5yZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdW5pb25FcnJvcnMgPSBpc3N1ZXMubWFwKChpc3N1ZXMpID0+IG5ldyBab2RFcnJvcihpc3N1ZXMpKTtcclxuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbixcclxuICAgICAgICAgICAgICAgIHVuaW9uRXJyb3JzLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IG9wdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vcHRpb25zO1xyXG4gICAgfVxyXG59XHJcblpvZFVuaW9uLmNyZWF0ZSA9ICh0eXBlcywgcGFyYW1zKSA9PiB7XHJcbiAgICByZXR1cm4gbmV3IFpvZFVuaW9uKHtcclxuICAgICAgICBvcHRpb25zOiB0eXBlcyxcclxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVuaW9uLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLy8vLy8vLy8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xyXG4vLy8vLy8vLy8vICAgICAgWm9kRGlzY3JpbWluYXRlZFVuaW9uICAgICAgLy8vLy8vLy8vL1xyXG4vLy8vLy8vLy8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5jb25zdCBnZXREaXNjcmltaW5hdG9yID0gKHR5cGUpID0+IHtcclxuICAgIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTGF6eSkge1xyXG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuc2NoZW1hKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RFZmZlY3RzKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5pbm5lclR5cGUoKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTGl0ZXJhbCkge1xyXG4gICAgICAgIHJldHVybiBbdHlwZS52YWx1ZV07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRW51bSkge1xyXG4gICAgICAgIHJldHVybiB0eXBlLm9wdGlvbnM7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTmF0aXZlRW51bSkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBiYW4vYmFuXHJcbiAgICAgICAgcmV0dXJuIHV0aWwub2JqZWN0VmFsdWVzKHR5cGUuZW51bSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRGVmYXVsdCkge1xyXG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuX2RlZi5pbm5lclR5cGUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZFVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBbdW5kZWZpbmVkXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2ROdWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIFtudWxsXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xyXG4gICAgICAgIHJldHVybiBbdW5kZWZpbmVkLCAuLi5nZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2ROdWxsYWJsZSkge1xyXG4gICAgICAgIHJldHVybiBbbnVsbCwgLi4uZ2V0RGlzY3JpbWluYXRvcih0eXBlLnVud3JhcCgpKV07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kQnJhbmRlZCkge1xyXG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZFJlYWRvbmx5KSB7XHJcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kQ2F0Y2gpIHtcclxuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLl9kZWYuaW5uZXJUeXBlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxufTtcclxuY2xhc3MgWm9kRGlzY3JpbWluYXRlZFVuaW9uIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcclxuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcclxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm9iamVjdCxcclxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gdGhpcy5kaXNjcmltaW5hdG9yO1xyXG4gICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JWYWx1ZSA9IGN0eC5kYXRhW2Rpc2NyaW1pbmF0b3JdO1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IHRoaXMub3B0aW9uc01hcC5nZXQoZGlzY3JpbWluYXRvclZhbHVlKTtcclxuICAgICAgICBpZiAoIW9wdGlvbikge1xyXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3IsXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBBcnJheS5mcm9tKHRoaXMub3B0aW9uc01hcC5rZXlzKCkpLFxyXG4gICAgICAgICAgICAgICAgcGF0aDogW2Rpc2NyaW1pbmF0b3JdLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvcHRpb24uX3BhcnNlQXN5bmMoe1xyXG4gICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXHJcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcclxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvcHRpb24uX3BhcnNlU3luYyh7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcclxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxyXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBkaXNjcmltaW5hdG9yKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuZGlzY3JpbWluYXRvcjtcclxuICAgIH1cclxuICAgIGdldCBvcHRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9ucztcclxuICAgIH1cclxuICAgIGdldCBvcHRpb25zTWFwKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9uc01hcDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBkaXNjcmltaW5hdGVkIHVuaW9uIHNjaGVtYS4gSXRzIGJlaGF2aW91ciBpcyB2ZXJ5IHNpbWlsYXIgdG8gdGhhdCBvZiB0aGUgbm9ybWFsIHoudW5pb24oKSBjb25zdHJ1Y3Rvci5cclxuICAgICAqIEhvd2V2ZXIsIGl0IG9ubHkgYWxsb3dzIGEgdW5pb24gb2Ygb2JqZWN0cywgYWxsIG9mIHdoaWNoIG5lZWQgdG8gc2hhcmUgYSBkaXNjcmltaW5hdG9yIHByb3BlcnR5LiBUaGlzIHByb3BlcnR5IG11c3RcclxuICAgICAqIGhhdmUgYSBkaWZmZXJlbnQgdmFsdWUgZm9yIGVhY2ggb2JqZWN0IGluIHRoZSB1bmlvbi5cclxuICAgICAqIEBwYXJhbSBkaXNjcmltaW5hdG9yIHRoZSBuYW1lIG9mIHRoZSBkaXNjcmltaW5hdG9yIHByb3BlcnR5XHJcbiAgICAgKiBAcGFyYW0gdHlwZXMgYW4gYXJyYXkgb2Ygb2JqZWN0IHNjaGVtYXNcclxuICAgICAqIEBwYXJhbSBwYXJhbXNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZShkaXNjcmltaW5hdG9yLCBvcHRpb25zLCBwYXJhbXMpIHtcclxuICAgICAgICAvLyBHZXQgYWxsIHRoZSB2YWxpZCBkaXNjcmltaW5hdG9yIHZhbHVlc1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnNNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgLy8gdHJ5IHtcclxuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2Ygb3B0aW9ucykge1xyXG4gICAgICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWVzID0gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnNoYXBlW2Rpc2NyaW1pbmF0b3JdKTtcclxuICAgICAgICAgICAgaWYgKCFkaXNjcmltaW5hdG9yVmFsdWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIGRpc2NyaW1pbmF0b3IgdmFsdWUgZm9yIGtleSBcXGAke2Rpc2NyaW1pbmF0b3J9XFxgIGNvdWxkIG5vdCBiZSBleHRyYWN0ZWQgZnJvbSBhbGwgc2NoZW1hIG9wdGlvbnNgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGRpc2NyaW1pbmF0b3JWYWx1ZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zTWFwLmhhcyh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpc2NyaW1pbmF0b3IgcHJvcGVydHkgJHtTdHJpbmcoZGlzY3JpbWluYXRvcil9IGhhcyBkdXBsaWNhdGUgdmFsdWUgJHtTdHJpbmcodmFsdWUpfWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3B0aW9uc01hcC5zZXQodmFsdWUsIHR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgWm9kRGlzY3JpbWluYXRlZFVuaW9uKHtcclxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REaXNjcmltaW5hdGVkVW5pb24sXHJcbiAgICAgICAgICAgIGRpc2NyaW1pbmF0b3IsXHJcbiAgICAgICAgICAgIG9wdGlvbnMsXHJcbiAgICAgICAgICAgIG9wdGlvbnNNYXAsXHJcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBtZXJnZVZhbHVlcyhhLCBiKSB7XHJcbiAgICBjb25zdCBhVHlwZSA9IGdldFBhcnNlZFR5cGUoYSk7XHJcbiAgICBjb25zdCBiVHlwZSA9IGdldFBhcnNlZFR5cGUoYik7XHJcbiAgICBpZiAoYSA9PT0gYikge1xyXG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChhVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5vYmplY3QgJiYgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XHJcbiAgICAgICAgY29uc3QgYktleXMgPSB1dGlsLm9iamVjdEtleXMoYik7XHJcbiAgICAgICAgY29uc3Qgc2hhcmVkS2V5cyA9IHV0aWxcclxuICAgICAgICAgICAgLm9iamVjdEtleXMoYSlcclxuICAgICAgICAgICAgLmZpbHRlcigoa2V5KSA9PiBiS2V5cy5pbmRleE9mKGtleSkgIT09IC0xKTtcclxuICAgICAgICBjb25zdCBuZXdPYmogPSB7IC4uLmEsIC4uLmIgfTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBzaGFyZWRLZXlzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoYVtrZXldLCBiW2tleV0pO1xyXG4gICAgICAgICAgICBpZiAoIXNoYXJlZFZhbHVlLnZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuZXdPYmpba2V5XSA9IHNoYXJlZFZhbHVlLmRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBuZXdPYmogfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLmFycmF5ICYmIGJUeXBlID09PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XHJcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmV3QXJyYXkgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYS5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgY29uc3QgaXRlbUEgPSBhW2luZGV4XTtcclxuICAgICAgICAgICAgY29uc3QgaXRlbUIgPSBiW2luZGV4XTtcclxuICAgICAgICAgICAgY29uc3Qgc2hhcmVkVmFsdWUgPSBtZXJnZVZhbHVlcyhpdGVtQSwgaXRlbUIpO1xyXG4gICAgICAgICAgICBpZiAoIXNoYXJlZFZhbHVlLnZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuZXdBcnJheS5wdXNoKHNoYXJlZFZhbHVlLmRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogbmV3QXJyYXkgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLmRhdGUgJiZcclxuICAgICAgICBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5kYXRlICYmXHJcbiAgICAgICAgK2EgPT09ICtiKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IGEgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFpvZEludGVyc2VjdGlvbiBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcclxuICAgICAgICBjb25zdCBoYW5kbGVQYXJzZWQgPSAocGFyc2VkTGVmdCwgcGFyc2VkUmlnaHQpID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzQWJvcnRlZChwYXJzZWRMZWZ0KSB8fCBpc0Fib3J0ZWQocGFyc2VkUmlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSBtZXJnZVZhbHVlcyhwYXJzZWRMZWZ0LnZhbHVlLCBwYXJzZWRSaWdodC52YWx1ZSk7XHJcbiAgICAgICAgICAgIGlmICghbWVyZ2VkLnZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXMsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc0RpcnR5KHBhcnNlZExlZnQpIHx8IGlzRGlydHkocGFyc2VkUmlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IG1lcmdlZC5kYXRhIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVmLmxlZnQuX3BhcnNlQXN5bmMoe1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWYucmlnaHQuX3BhcnNlQXN5bmMoe1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIF0pLnRoZW4oKFtsZWZ0LCByaWdodF0pID0+IGhhbmRsZVBhcnNlZChsZWZ0LCByaWdodCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVBhcnNlZCh0aGlzLl9kZWYubGVmdC5fcGFyc2VTeW5jKHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxyXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXHJcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcclxuICAgICAgICAgICAgfSksIHRoaXMuX2RlZi5yaWdodC5fcGFyc2VTeW5jKHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxyXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXHJcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5ab2RJbnRlcnNlY3Rpb24uY3JlYXRlID0gKGxlZnQsIHJpZ2h0LCBwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kSW50ZXJzZWN0aW9uKHtcclxuICAgICAgICBsZWZ0OiBsZWZ0LFxyXG4gICAgICAgIHJpZ2h0OiByaWdodCxcclxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEludGVyc2VjdGlvbixcclxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXHJcbiAgICB9KTtcclxufTtcclxuY2xhc3MgWm9kVHVwbGUgZXh0ZW5kcyBab2RUeXBlIHtcclxuICAgIF9wYXJzZShpbnB1dCkge1xyXG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XHJcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcclxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmFycmF5LFxyXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPCB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcclxuICAgICAgICAgICAgICAgIG1pbmltdW06IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdCA9IHRoaXMuX2RlZi5yZXN0O1xyXG4gICAgICAgIGlmICghcmVzdCAmJiBjdHguZGF0YS5sZW5ndGggPiB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXHJcbiAgICAgICAgICAgICAgICBtYXhpbXVtOiB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGl0ZW1zID0gWy4uLmN0eC5kYXRhXVxyXG4gICAgICAgICAgICAubWFwKChpdGVtLCBpdGVtSW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5fZGVmLml0ZW1zW2l0ZW1JbmRleF0gfHwgdGhpcy5fZGVmLnJlc3Q7XHJcbiAgICAgICAgICAgIGlmICghc2NoZW1hKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWEuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaXRlbUluZGV4KSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLmZpbHRlcigoeCkgPT4gISF4KTsgLy8gZmlsdGVyIG51bGxzXHJcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGl0ZW1zKS50aGVuKChyZXN1bHRzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdHMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgaXRlbXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBpdGVtcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLml0ZW1zO1xyXG4gICAgfVxyXG4gICAgcmVzdChyZXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RUdXBsZSh7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAgICAgcmVzdCxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5ab2RUdXBsZS5jcmVhdGUgPSAoc2NoZW1hcywgcGFyYW1zKSA9PiB7XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hcykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGFuIGFycmF5IG9mIHNjaGVtYXMgdG8gei50dXBsZShbIC4uLiBdKVwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgWm9kVHVwbGUoe1xyXG4gICAgICAgIGl0ZW1zOiBzY2hlbWFzLFxyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVHVwbGUsXHJcbiAgICAgICAgcmVzdDogbnVsbCxcclxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXHJcbiAgICB9KTtcclxufTtcclxuY2xhc3MgWm9kUmVjb3JkIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBnZXQga2V5U2NoZW1hKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcclxuICAgIH1cclxuICAgIGdldCB2YWx1ZVNjaGVtYSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcclxuICAgIH1cclxuICAgIF9wYXJzZShpbnB1dCkge1xyXG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XHJcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xyXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXHJcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXHJcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGFpcnMgPSBbXTtcclxuICAgICAgICBjb25zdCBrZXlUeXBlID0gdGhpcy5fZGVmLmtleVR5cGU7XHJcbiAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjdHguZGF0YSkge1xyXG4gICAgICAgICAgICBwYWlycy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGtleToga2V5VHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGtleSwgY3R4LnBhdGgsIGtleSkpLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGN0eC5kYXRhW2tleV0sIGN0eC5wYXRoLCBrZXkpKSxcclxuICAgICAgICAgICAgICAgIGFsd2F5c1NldDoga2V5IGluIGN0eC5kYXRhLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0QXN5bmMoc3RhdHVzLCBwYWlycyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBlbGVtZW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVUeXBlO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNyZWF0ZShmaXJzdCwgc2Vjb25kLCB0aGlyZCkge1xyXG4gICAgICAgIGlmIChzZWNvbmQgaW5zdGFuY2VvZiBab2RUeXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgWm9kUmVjb3JkKHtcclxuICAgICAgICAgICAgICAgIGtleVR5cGU6IGZpcnN0LFxyXG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlOiBzZWNvbmQsXHJcbiAgICAgICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFJlY29yZCxcclxuICAgICAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcmQpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RSZWNvcmQoe1xyXG4gICAgICAgICAgICBrZXlUeXBlOiBab2RTdHJpbmcuY3JlYXRlKCksXHJcbiAgICAgICAgICAgIHZhbHVlVHlwZTogZmlyc3QsXHJcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVjb3JkLFxyXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHNlY29uZCksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgWm9kTWFwIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBnZXQga2V5U2NoZW1hKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcclxuICAgIH1cclxuICAgIGdldCB2YWx1ZVNjaGVtYSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcclxuICAgIH1cclxuICAgIF9wYXJzZShpbnB1dCkge1xyXG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XHJcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm1hcCkge1xyXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXHJcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5tYXAsXHJcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qga2V5VHlwZSA9IHRoaXMuX2RlZi5rZXlUeXBlO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XHJcbiAgICAgICAgY29uc3QgcGFpcnMgPSBbLi4uY3R4LmRhdGEuZW50cmllcygpXS5tYXAoKFtrZXksIHZhbHVlXSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGtleToga2V5VHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGtleSwgY3R4LnBhdGgsIFtpbmRleCwgXCJrZXlcIl0pKSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIFtpbmRleCwgXCJ2YWx1ZVwiXSkpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBwYWlyLmtleTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHBhaXIudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsTWFwLnNldChrZXkudmFsdWUsIHZhbHVlLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogZmluYWxNYXAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBmaW5hbE1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBwYWlyLmtleTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFpci52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaW5hbE1hcC5zZXQoa2V5LnZhbHVlLCB2YWx1ZS52YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE1hcCB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5ab2RNYXAuY3JlYXRlID0gKGtleVR5cGUsIHZhbHVlVHlwZSwgcGFyYW1zKSA9PiB7XHJcbiAgICByZXR1cm4gbmV3IFpvZE1hcCh7XHJcbiAgICAgICAgdmFsdWVUeXBlLFxyXG4gICAgICAgIGtleVR5cGUsXHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RNYXAsXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcbmNsYXNzIFpvZFNldCBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcclxuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc2V0KSB7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcclxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnNldCxcclxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLl9kZWY7XHJcbiAgICAgICAgaWYgKGRlZi5taW5TaXplICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5zaXplIDwgZGVmLm1pblNpemUudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXHJcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogZGVmLm1pblNpemUudmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIixcclxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5taW5TaXplLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZWYubWF4U2l6ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoY3R4LmRhdGEuc2l6ZSA+IGRlZi5tYXhTaXplLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcclxuICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBkZWYubWF4U2l6ZS52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInNldFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLm1heFNpemUubWVzc2FnZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcclxuICAgICAgICBmdW5jdGlvbiBmaW5hbGl6ZVNldChlbGVtZW50cykge1xyXG4gICAgICAgICAgICBjb25zdCBwYXJzZWRTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgcGFyc2VkU2V0LmFkZChlbGVtZW50LnZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IHBhcnNlZFNldCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBlbGVtZW50cyA9IFsuLi5jdHguZGF0YS52YWx1ZXMoKV0ubWFwKChpdGVtLCBpKSA9PiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpKTtcclxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZWxlbWVudHMpLnRoZW4oKGVsZW1lbnRzKSA9PiBmaW5hbGl6ZVNldChlbGVtZW50cykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZpbmFsaXplU2V0KGVsZW1lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBtaW4obWluU2l6ZSwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kU2V0KHtcclxuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxyXG4gICAgICAgICAgICBtaW5TaXplOiB7IHZhbHVlOiBtaW5TaXplLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIG1heChtYXhTaXplLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTZXQoe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIG1heFNpemU6IHsgdmFsdWU6IG1heFNpemUsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc2l6ZShzaXplLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKHNpemUsIG1lc3NhZ2UpLm1heChzaXplLCBtZXNzYWdlKTtcclxuICAgIH1cclxuICAgIG5vbmVtcHR5KG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5taW4oMSwgbWVzc2FnZSk7XHJcbiAgICB9XHJcbn1cclxuWm9kU2V0LmNyZWF0ZSA9ICh2YWx1ZVR5cGUsIHBhcmFtcykgPT4ge1xyXG4gICAgcmV0dXJuIG5ldyBab2RTZXQoe1xyXG4gICAgICAgIHZhbHVlVHlwZSxcclxuICAgICAgICBtaW5TaXplOiBudWxsLFxyXG4gICAgICAgIG1heFNpemU6IG51bGwsXHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTZXQsXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcbmNsYXNzIFpvZEZ1bmN0aW9uIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMudmFsaWRhdGUgPSB0aGlzLmltcGxlbWVudDtcclxuICAgIH1cclxuICAgIF9wYXJzZShpbnB1dCkge1xyXG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xyXG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5mdW5jdGlvbikge1xyXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXHJcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5mdW5jdGlvbixcclxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBtYWtlQXJnc0lzc3VlKGFyZ3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtYWtlSXNzdWUoe1xyXG4gICAgICAgICAgICAgICAgZGF0YTogYXJncyxcclxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxyXG4gICAgICAgICAgICAgICAgZXJyb3JNYXBzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LnNjaGVtYUVycm9yTWFwLFxyXG4gICAgICAgICAgICAgICAgICAgIGdldEVycm9yTWFwKCksXHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNYXAsXHJcbiAgICAgICAgICAgICAgICBdLmZpbHRlcigoeCkgPT4gISF4KSxcclxuICAgICAgICAgICAgICAgIGlzc3VlRGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2FyZ3VtZW50cyxcclxuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNFcnJvcjogZXJyb3IsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gbWFrZVJldHVybnNJc3N1ZShyZXR1cm5zLCBlcnJvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbWFrZUlzc3VlKHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IHJldHVybnMsXHJcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcclxuICAgICAgICAgICAgICAgIGVycm9yTWFwczogW1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLFxyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCxcclxuICAgICAgICAgICAgICAgICAgICBnZXRFcnJvck1hcCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWFwLFxyXG4gICAgICAgICAgICAgICAgXS5maWx0ZXIoKHgpID0+ICEheCksXHJcbiAgICAgICAgICAgICAgICBpc3N1ZURhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9yZXR1cm5fdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlRXJyb3I6IGVycm9yLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHsgZXJyb3JNYXA6IGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwIH07XHJcbiAgICAgICAgY29uc3QgZm4gPSBjdHguZGF0YTtcclxuICAgICAgICBpZiAodGhpcy5fZGVmLnJldHVybnMgaW5zdGFuY2VvZiBab2RQcm9taXNlKSB7XHJcbiAgICAgICAgICAgIC8vIFdvdWxkIGxvdmUgYSB3YXkgdG8gYXZvaWQgZGlzYWJsaW5nIHRoaXMgcnVsZSwgYnV0IHdlIG5lZWRcclxuICAgICAgICAgICAgLy8gYW4gYWxpYXMgKHVzaW5nIGFuIGFycm93IGZ1bmN0aW9uIHdhcyB3aGF0IGNhdXNlZCAyNjUxKS5cclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXHJcbiAgICAgICAgICAgIGNvbnN0IG1lID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIE9LKGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihbXSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRBcmdzID0gYXdhaXQgbWUuX2RlZi5hcmdzXHJcbiAgICAgICAgICAgICAgICAgICAgLnBhcnNlQXN5bmMoYXJncywgcGFyYW1zKVxyXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZElzc3VlKG1ha2VBcmdzSXNzdWUoYXJncywgZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBSZWZsZWN0LmFwcGx5KGZuLCB0aGlzLCBwYXJzZWRBcmdzKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJldHVybnMgPSBhd2FpdCBtZS5fZGVmLnJldHVybnMuX2RlZi50eXBlXHJcbiAgICAgICAgICAgICAgICAgICAgLnBhcnNlQXN5bmMocmVzdWx0LCBwYXJhbXMpXHJcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuYWRkSXNzdWUobWFrZVJldHVybnNJc3N1ZShyZXN1bHQsIGUpKTtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZFJldHVybnM7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gV291bGQgbG92ZSBhIHdheSB0byBhdm9pZCBkaXNhYmxpbmcgdGhpcyBydWxlLCBidXQgd2UgbmVlZFxyXG4gICAgICAgICAgICAvLyBhbiBhbGlhcyAodXNpbmcgYW4gYXJyb3cgZnVuY3Rpb24gd2FzIHdoYXQgY2F1c2VkIDI2NTEpLlxyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcclxuICAgICAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gT0soZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFyZ3MgPSBtZS5fZGVmLmFyZ3Muc2FmZVBhcnNlKGFyZ3MsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZEFyZ3Muc3VjY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBab2RFcnJvcihbbWFrZUFyZ3NJc3N1ZShhcmdzLCBwYXJzZWRBcmdzLmVycm9yKV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5hcHBseShmbiwgdGhpcywgcGFyc2VkQXJncy5kYXRhKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJldHVybnMgPSBtZS5fZGVmLnJldHVybnMuc2FmZVBhcnNlKHJlc3VsdCwgcGFyYW1zKTtcclxuICAgICAgICAgICAgICAgIGlmICghcGFyc2VkUmV0dXJucy5zdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFpvZEVycm9yKFttYWtlUmV0dXJuc0lzc3VlKHJlc3VsdCwgcGFyc2VkUmV0dXJucy5lcnJvcildKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWRSZXR1cm5zLmRhdGE7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHBhcmFtZXRlcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5hcmdzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuVHlwZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnJldHVybnM7XHJcbiAgICB9XHJcbiAgICBhcmdzKC4uLml0ZW1zKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAgICAgYXJnczogWm9kVHVwbGUuY3JlYXRlKGl0ZW1zKS5yZXN0KFpvZFVua25vd24uY3JlYXRlKCkpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJucyhyZXR1cm5UeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAgICAgcmV0dXJuczogcmV0dXJuVHlwZSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGltcGxlbWVudChmdW5jKSB7XHJcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkRnVuYyA9IHRoaXMucGFyc2UoZnVuYyk7XHJcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlZEZ1bmM7XHJcbiAgICB9XHJcbiAgICBzdHJpY3RJbXBsZW1lbnQoZnVuYykge1xyXG4gICAgICAgIGNvbnN0IHZhbGlkYXRlZEZ1bmMgPSB0aGlzLnBhcnNlKGZ1bmMpO1xyXG4gICAgICAgIHJldHVybiB2YWxpZGF0ZWRGdW5jO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNyZWF0ZShhcmdzLCByZXR1cm5zLCBwYXJhbXMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFpvZEZ1bmN0aW9uKHtcclxuICAgICAgICAgICAgYXJnczogKGFyZ3NcclxuICAgICAgICAgICAgICAgID8gYXJnc1xyXG4gICAgICAgICAgICAgICAgOiBab2RUdXBsZS5jcmVhdGUoW10pLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSkpLFxyXG4gICAgICAgICAgICByZXR1cm5zOiByZXR1cm5zIHx8IFpvZFVua25vd24uY3JlYXRlKCksXHJcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRnVuY3Rpb24sXHJcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBab2RMYXp5IGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBnZXQgc2NoZW1hKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuZ2V0dGVyKCk7XHJcbiAgICB9XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcclxuICAgICAgICBjb25zdCBsYXp5U2NoZW1hID0gdGhpcy5fZGVmLmdldHRlcigpO1xyXG4gICAgICAgIHJldHVybiBsYXp5U2NoZW1hLl9wYXJzZSh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XHJcbiAgICB9XHJcbn1cclxuWm9kTGF6eS5jcmVhdGUgPSAoZ2V0dGVyLCBwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kTGF6eSh7XHJcbiAgICAgICAgZ2V0dGVyOiBnZXR0ZXIsXHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RMYXp5LFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2RMaXRlcmFsIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBpZiAoaW5wdXQuZGF0YSAhPT0gdGhpcy5fZGVmLnZhbHVlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcclxuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LmRhdGEsXHJcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9saXRlcmFsLFxyXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHRoaXMuX2RlZi52YWx1ZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGlucHV0LmRhdGEgfTtcclxuICAgIH1cclxuICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlO1xyXG4gICAgfVxyXG59XHJcblpvZExpdGVyYWwuY3JlYXRlID0gKHZhbHVlLCBwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kTGl0ZXJhbCh7XHJcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTGl0ZXJhbCxcclxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXHJcbiAgICB9KTtcclxufTtcclxuZnVuY3Rpb24gY3JlYXRlWm9kRW51bSh2YWx1ZXMsIHBhcmFtcykge1xyXG4gICAgcmV0dXJuIG5ldyBab2RFbnVtKHtcclxuICAgICAgICB2YWx1ZXMsXHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFbnVtLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59XHJcbmNsYXNzIFpvZEVudW0gZXh0ZW5kcyBab2RUeXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgX1pvZEVudW1fY2FjaGUuc2V0KHRoaXMsIHZvaWQgMCk7XHJcbiAgICB9XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGlucHV0LmRhdGEgIT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xyXG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHRoaXMuX2RlZi52YWx1ZXM7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHV0aWwuam9pblZhbHVlcyhleHBlY3RlZFZhbHVlcyksXHJcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXHJcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfWm9kRW51bV9jYWNoZSwgXCJmXCIpKSB7XHJcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1pvZEVudW1fY2FjaGUsIG5ldyBTZXQodGhpcy5fZGVmLnZhbHVlcyksIFwiZlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9ab2RFbnVtX2NhY2hlLCBcImZcIikuaGFzKGlucHV0LmRhdGEpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcclxuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB0aGlzLl9kZWYudmFsdWVzO1xyXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWUsXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBleHBlY3RlZFZhbHVlcyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XHJcbiAgICB9XHJcbiAgICBnZXQgb3B0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlcztcclxuICAgIH1cclxuICAgIGdldCBlbnVtKCkge1xyXG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcclxuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XHJcbiAgICAgICAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XHJcbiAgICB9XHJcbiAgICBnZXQgVmFsdWVzKCkge1xyXG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcclxuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XHJcbiAgICAgICAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XHJcbiAgICB9XHJcbiAgICBnZXQgRW51bSgpIHtcclxuICAgICAgICBjb25zdCBlbnVtVmFsdWVzID0ge307XHJcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xyXG4gICAgICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xyXG4gICAgfVxyXG4gICAgZXh0cmFjdCh2YWx1ZXMsIG5ld0RlZiA9IHRoaXMuX2RlZikge1xyXG4gICAgICAgIHJldHVybiBab2RFbnVtLmNyZWF0ZSh2YWx1ZXMsIHtcclxuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxyXG4gICAgICAgICAgICAuLi5uZXdEZWYsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBleGNsdWRlKHZhbHVlcywgbmV3RGVmID0gdGhpcy5fZGVmKSB7XHJcbiAgICAgICAgcmV0dXJuIFpvZEVudW0uY3JlYXRlKHRoaXMub3B0aW9ucy5maWx0ZXIoKG9wdCkgPT4gIXZhbHVlcy5pbmNsdWRlcyhvcHQpKSwge1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIC4uLm5ld0RlZixcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5fWm9kRW51bV9jYWNoZSA9IG5ldyBXZWFrTWFwKCk7XHJcblpvZEVudW0uY3JlYXRlID0gY3JlYXRlWm9kRW51bTtcclxuY2xhc3MgWm9kTmF0aXZlRW51bSBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICBfWm9kTmF0aXZlRW51bV9jYWNoZS5zZXQodGhpcywgdm9pZCAwKTtcclxuICAgIH1cclxuICAgIF9wYXJzZShpbnB1dCkge1xyXG4gICAgICAgIGNvbnN0IG5hdGl2ZUVudW1WYWx1ZXMgPSB1dGlsLmdldFZhbGlkRW51bVZhbHVlcyh0aGlzLl9kZWYudmFsdWVzKTtcclxuICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XHJcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnN0cmluZyAmJlxyXG4gICAgICAgICAgICBjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5udW1iZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB1dGlsLm9iamVjdFZhbHVlcyhuYXRpdmVFbnVtVmFsdWVzKTtcclxuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdXRpbC5qb2luVmFsdWVzKGV4cGVjdGVkVmFsdWVzKSxcclxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9ab2ROYXRpdmVFbnVtX2NhY2hlLCBcImZcIikpIHtcclxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfWm9kTmF0aXZlRW51bV9jYWNoZSwgbmV3IFNldCh1dGlsLmdldFZhbGlkRW51bVZhbHVlcyh0aGlzLl9kZWYudmFsdWVzKSksIFwiZlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9ab2ROYXRpdmVFbnVtX2NhY2hlLCBcImZcIikuaGFzKGlucHV0LmRhdGEpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdXRpbC5vYmplY3RWYWx1ZXMobmF0aXZlRW51bVZhbHVlcyk7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfZW51bV92YWx1ZSxcclxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4cGVjdGVkVmFsdWVzLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcclxuICAgIH1cclxuICAgIGdldCBlbnVtKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xyXG4gICAgfVxyXG59XHJcbl9ab2ROYXRpdmVFbnVtX2NhY2hlID0gbmV3IFdlYWtNYXAoKTtcclxuWm9kTmF0aXZlRW51bS5jcmVhdGUgPSAodmFsdWVzLCBwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kTmF0aXZlRW51bSh7XHJcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROYXRpdmVFbnVtLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2RQcm9taXNlIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICB1bndyYXAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlO1xyXG4gICAgfVxyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XHJcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnByb21pc2UgJiZcclxuICAgICAgICAgICAgY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxyXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUucHJvbWlzZSxcclxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwcm9taXNpZmllZCA9IGN0eC5wYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLnByb21pc2VcclxuICAgICAgICAgICAgPyBjdHguZGF0YVxyXG4gICAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZShjdHguZGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIE9LKHByb21pc2lmaWVkLnRoZW4oKGRhdGEpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlLnBhcnNlQXN5bmMoZGF0YSwge1xyXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXHJcbiAgICAgICAgICAgICAgICBlcnJvck1hcDogY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxufVxyXG5ab2RQcm9taXNlLmNyZWF0ZSA9IChzY2hlbWEsIHBhcmFtcykgPT4ge1xyXG4gICAgcmV0dXJuIG5ldyBab2RQcm9taXNlKHtcclxuICAgICAgICB0eXBlOiBzY2hlbWEsXHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQcm9taXNlLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2RFZmZlY3RzIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBpbm5lclR5cGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWE7XHJcbiAgICB9XHJcbiAgICBzb3VyY2VUeXBlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9kZWYudHlwZU5hbWUgPT09IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzXHJcbiAgICAgICAgICAgID8gdGhpcy5fZGVmLnNjaGVtYS5zb3VyY2VUeXBlKClcclxuICAgICAgICAgICAgOiB0aGlzLl9kZWYuc2NoZW1hO1xyXG4gICAgfVxyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcclxuICAgICAgICBjb25zdCBlZmZlY3QgPSB0aGlzLl9kZWYuZWZmZWN0IHx8IG51bGw7XHJcbiAgICAgICAgY29uc3QgY2hlY2tDdHggPSB7XHJcbiAgICAgICAgICAgIGFkZElzc3VlOiAoYXJnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIGFyZyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJnLmZhdGFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZ2V0IHBhdGgoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4LnBhdGg7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjaGVja0N0eC5hZGRJc3N1ZSA9IGNoZWNrQ3R4LmFkZElzc3VlLmJpbmQoY2hlY2tDdHgpO1xyXG4gICAgICAgIGlmIChlZmZlY3QudHlwZSA9PT0gXCJwcmVwcm9jZXNzXCIpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gZWZmZWN0LnRyYW5zZm9ybShjdHguZGF0YSwgY2hlY2tDdHgpO1xyXG4gICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwcm9jZXNzZWQpLnRoZW4oYXN5bmMgKHByb2Nlc3NlZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiYWJvcnRlZFwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZUFzeW5jKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcHJvY2Vzc2VkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImRpcnR5XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiYWJvcnRlZFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBwcm9jZXNzZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERJUlRZKHJlc3VsdC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImRpcnR5XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERJUlRZKHJlc3VsdC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlZmZlY3QudHlwZSA9PT0gXCJyZWZpbmVtZW50XCIpIHtcclxuICAgICAgICAgICAgY29uc3QgZXhlY3V0ZVJlZmluZW1lbnQgPSAoYWNjKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBlZmZlY3QucmVmaW5lbWVudChhY2MsIGNoZWNrQ3R4KTtcclxuICAgICAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3luYyByZWZpbmVtZW50IGVuY291bnRlcmVkIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZSBvcGVyYXRpb24uIFVzZSAucGFyc2VBc3luYyBpbnN0ZWFkLlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5uZXIgPSB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoe1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICAgICAgICAgIGlmIChpbm5lci5zdGF0dXMgPT09IFwiZGlydHlcIilcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIC8vIHJldHVybiB2YWx1ZSBpcyBpZ25vcmVkXHJcbiAgICAgICAgICAgICAgICBleGVjdXRlUmVmaW5lbWVudChpbm5lci52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlubmVyLnZhbHVlIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYVxyXG4gICAgICAgICAgICAgICAgICAgIC5fcGFyc2VBc3luYyh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbigoaW5uZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhlY3V0ZVJlZmluZW1lbnQoaW5uZXIudmFsdWUpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlubmVyLnZhbHVlIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwidHJhbnNmb3JtXCIpIHtcclxuICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKGJhc2UpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZWZmZWN0LnRyYW5zZm9ybShiYXNlLnZhbHVlLCBjaGVja0N0eCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXN5bmNocm9ub3VzIHRyYW5zZm9ybSBlbmNvdW50ZXJlZCBkdXJpbmcgc3luY2hyb25vdXMgcGFyc2Ugb3BlcmF0aW9uLiBVc2UgLnBhcnNlQXN5bmMgaW5zdGVhZC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcmVzdWx0IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYVxyXG4gICAgICAgICAgICAgICAgICAgIC5fcGFyc2VBc3luYyh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbigoYmFzZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZChiYXNlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShlZmZlY3QudHJhbnNmb3JtKGJhc2UudmFsdWUsIGNoZWNrQ3R4KSkudGhlbigocmVzdWx0KSA9PiAoeyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IHJlc3VsdCB9KSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGVmZmVjdCk7XHJcbiAgICB9XHJcbn1cclxuWm9kRWZmZWN0cy5jcmVhdGUgPSAoc2NoZW1hLCBlZmZlY3QsIHBhcmFtcykgPT4ge1xyXG4gICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcclxuICAgICAgICBzY2hlbWEsXHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxyXG4gICAgICAgIGVmZmVjdCxcclxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXHJcbiAgICB9KTtcclxufTtcclxuWm9kRWZmZWN0cy5jcmVhdGVXaXRoUHJlcHJvY2VzcyA9IChwcmVwcm9jZXNzLCBzY2hlbWEsIHBhcmFtcykgPT4ge1xyXG4gICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcclxuICAgICAgICBzY2hlbWEsXHJcbiAgICAgICAgZWZmZWN0OiB7IHR5cGU6IFwicHJlcHJvY2Vzc1wiLCB0cmFuc2Zvcm06IHByZXByb2Nlc3MgfSxcclxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcbmNsYXNzIFpvZE9wdGlvbmFsIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XHJcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPSyh1bmRlZmluZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xyXG4gICAgfVxyXG4gICAgdW53cmFwKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xyXG4gICAgfVxyXG59XHJcblpvZE9wdGlvbmFsLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kT3B0aW9uYWwoe1xyXG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcclxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9wdGlvbmFsLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2ROdWxsYWJsZSBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xyXG4gICAgICAgIGlmIChwYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLm51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9LKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xyXG4gICAgfVxyXG4gICAgdW53cmFwKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xyXG4gICAgfVxyXG59XHJcblpvZE51bGxhYmxlLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kTnVsbGFibGUoe1xyXG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcclxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bGxhYmxlLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2REZWZhdWx0IGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcclxuICAgICAgICBsZXQgZGF0YSA9IGN0eC5kYXRhO1xyXG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZGF0YSA9IHRoaXMuX2RlZi5kZWZhdWx0VmFsdWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcclxuICAgICAgICAgICAgZGF0YSxcclxuICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXHJcbiAgICAgICAgICAgIHBhcmVudDogY3R4LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlRGVmYXVsdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcclxuICAgIH1cclxufVxyXG5ab2REZWZhdWx0LmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XHJcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGVmYXVsdCxcclxuICAgICAgICBkZWZhdWx0VmFsdWU6IHR5cGVvZiBwYXJhbXMuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiXHJcbiAgICAgICAgICAgID8gcGFyYW1zLmRlZmF1bHRcclxuICAgICAgICAgICAgOiAoKSA9PiBwYXJhbXMuZGVmYXVsdCxcclxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXHJcbiAgICB9KTtcclxufTtcclxuY2xhc3MgWm9kQ2F0Y2ggZXh0ZW5kcyBab2RUeXBlIHtcclxuICAgIF9wYXJzZShpbnB1dCkge1xyXG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xyXG4gICAgICAgIC8vIG5ld0N0eCBpcyB1c2VkIHRvIG5vdCBjb2xsZWN0IGlzc3VlcyBmcm9tIGlubmVyIHR5cGVzIGluIGN0eFxyXG4gICAgICAgIGNvbnN0IG5ld0N0eCA9IHtcclxuICAgICAgICAgICAgLi4uY3R4LFxyXG4gICAgICAgICAgICBjb21tb246IHtcclxuICAgICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXHJcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2Uoe1xyXG4gICAgICAgICAgICBkYXRhOiBuZXdDdHguZGF0YSxcclxuICAgICAgICAgICAgcGF0aDogbmV3Q3R4LnBhdGgsXHJcbiAgICAgICAgICAgIHBhcmVudDoge1xyXG4gICAgICAgICAgICAgICAgLi4ubmV3Q3R4LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChpc0FzeW5jKHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBcInZhbGlkXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlc3VsdC52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2RlZi5jYXRjaFZhbHVlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBlcnJvcigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFpvZEVycm9yKG5ld0N0eC5jb21tb24uaXNzdWVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogbmV3Q3R4LmRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBcInZhbGlkXCIsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiXHJcbiAgICAgICAgICAgICAgICAgICAgPyByZXN1bHQudmFsdWVcclxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2RlZi5jYXRjaFZhbHVlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGVycm9yKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RFcnJvcihuZXdDdHguY29tbW9uLmlzc3Vlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBuZXdDdHguZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW1vdmVDYXRjaCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcclxuICAgIH1cclxufVxyXG5ab2RDYXRjaC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XHJcbiAgICByZXR1cm4gbmV3IFpvZENhdGNoKHtcclxuICAgICAgICBpbm5lclR5cGU6IHR5cGUsXHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RDYXRjaCxcclxuICAgICAgICBjYXRjaFZhbHVlOiB0eXBlb2YgcGFyYW1zLmNhdGNoID09PSBcImZ1bmN0aW9uXCIgPyBwYXJhbXMuY2F0Y2ggOiAoKSA9PiBwYXJhbXMuY2F0Y2gsXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcbmNsYXNzIFpvZE5hTiBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xyXG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm5hbikge1xyXG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcclxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm5hbixcclxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGlucHV0LmRhdGEgfTtcclxuICAgIH1cclxufVxyXG5ab2ROYU4uY3JlYXRlID0gKHBhcmFtcykgPT4ge1xyXG4gICAgcmV0dXJuIG5ldyBab2ROYU4oe1xyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmFOLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jb25zdCBCUkFORCA9IFN5bWJvbChcInpvZF9icmFuZFwiKTtcclxuY2xhc3MgWm9kQnJhbmRlZCBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGN0eC5kYXRhO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZS5fcGFyc2Uoe1xyXG4gICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcclxuICAgICAgICAgICAgcGFyZW50OiBjdHgsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB1bndyYXAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFpvZFBpcGVsaW5lIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xyXG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUFzeW5jID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5SZXN1bHQgPSBhd2FpdCB0aGlzLl9kZWYuaW4uX3BhcnNlQXN5bmMoe1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICAgICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShpblJlc3VsdC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm91dC5fcGFyc2VBc3luYyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGluUmVzdWx0LnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVBc3luYygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaW5SZXN1bHQgPSB0aGlzLl9kZWYuaW4uX3BhcnNlU3luYyh7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcclxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxyXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcclxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwiZGlydHlcIixcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaW5SZXN1bHQudmFsdWUsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vdXQuX3BhcnNlU3luYyh7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogaW5SZXN1bHQudmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBjcmVhdGUoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kUGlwZWxpbmUoe1xyXG4gICAgICAgICAgICBpbjogYSxcclxuICAgICAgICAgICAgb3V0OiBiLFxyXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFBpcGVsaW5lLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFpvZFJlYWRvbmx5IGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZShpbnB1dCk7XHJcbiAgICAgICAgY29uc3QgZnJlZXplID0gKGRhdGEpID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzVmFsaWQoZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgIGRhdGEudmFsdWUgPSBPYmplY3QuZnJlZXplKGRhdGEudmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGlzQXN5bmMocmVzdWx0KVxyXG4gICAgICAgICAgICA/IHJlc3VsdC50aGVuKChkYXRhKSA9PiBmcmVlemUoZGF0YSkpXHJcbiAgICAgICAgICAgIDogZnJlZXplKHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICB1bndyYXAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XHJcbiAgICB9XHJcbn1cclxuWm9kUmVhZG9ubHkuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xyXG4gICAgcmV0dXJuIG5ldyBab2RSZWFkb25seSh7XHJcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVhZG9ubHksXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLy8vLy8vLy8vICAgICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vXHJcbi8vLy8vLy8vLy8gICAgICB6LmN1c3RvbSAgICAgIC8vLy8vLy8vLy9cclxuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuZnVuY3Rpb24gY2xlYW5QYXJhbXMocGFyYW1zLCBkYXRhKSB7XHJcbiAgICBjb25zdCBwID0gdHlwZW9mIHBhcmFtcyA9PT0gXCJmdW5jdGlvblwiXHJcbiAgICAgICAgPyBwYXJhbXMoZGF0YSlcclxuICAgICAgICA6IHR5cGVvZiBwYXJhbXMgPT09IFwic3RyaW5nXCJcclxuICAgICAgICAgICAgPyB7IG1lc3NhZ2U6IHBhcmFtcyB9XHJcbiAgICAgICAgICAgIDogcGFyYW1zO1xyXG4gICAgY29uc3QgcDIgPSB0eXBlb2YgcCA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZTogcCB9IDogcDtcclxuICAgIHJldHVybiBwMjtcclxufVxyXG5mdW5jdGlvbiBjdXN0b20oY2hlY2ssIF9wYXJhbXMgPSB7fSwgXHJcbi8qKlxyXG4gKiBAZGVwcmVjYXRlZFxyXG4gKlxyXG4gKiBQYXNzIGBmYXRhbGAgaW50byB0aGUgcGFyYW1zIG9iamVjdCBpbnN0ZWFkOlxyXG4gKlxyXG4gKiBgYGB0c1xyXG4gKiB6LnN0cmluZygpLmN1c3RvbSgodmFsKSA9PiB2YWwubGVuZ3RoID4gNSwgeyBmYXRhbDogZmFsc2UgfSlcclxuICogYGBgXHJcbiAqXHJcbiAqL1xyXG5mYXRhbCkge1xyXG4gICAgaWYgKGNoZWNrKVxyXG4gICAgICAgIHJldHVybiBab2RBbnkuY3JlYXRlKCkuc3VwZXJSZWZpbmUoKGRhdGEsIGN0eCkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgICAgICBjb25zdCByID0gY2hlY2soZGF0YSk7XHJcbiAgICAgICAgICAgIGlmIChyIGluc3RhbmNlb2YgUHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHIudGhlbigocikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGNsZWFuUGFyYW1zKF9wYXJhbXMsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBfZmF0YWwgPSAoX2IgPSAoX2EgPSBwYXJhbXMuZmF0YWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhdGFsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYWRkSXNzdWUoeyBjb2RlOiBcImN1c3RvbVwiLCAuLi5wYXJhbXMsIGZhdGFsOiBfZmF0YWwgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBjbGVhblBhcmFtcyhfcGFyYW1zLCBkYXRhKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IF9mYXRhbCA9IChfYiA9IChfYSA9IHBhcmFtcy5mYXRhbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmF0YWwpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjdHguYWRkSXNzdWUoeyBjb2RlOiBcImN1c3RvbVwiLCAuLi5wYXJhbXMsIGZhdGFsOiBfZmF0YWwgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH0pO1xyXG4gICAgcmV0dXJuIFpvZEFueS5jcmVhdGUoKTtcclxufVxyXG5jb25zdCBsYXRlID0ge1xyXG4gICAgb2JqZWN0OiBab2RPYmplY3QubGF6eWNyZWF0ZSxcclxufTtcclxudmFyIFpvZEZpcnN0UGFydHlUeXBlS2luZDtcclxuKGZ1bmN0aW9uIChab2RGaXJzdFBhcnR5VHlwZUtpbmQpIHtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFN0cmluZ1wiXSA9IFwiWm9kU3RyaW5nXCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdW1iZXJcIl0gPSBcIlpvZE51bWJlclwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTmFOXCJdID0gXCJab2ROYU5cIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEJpZ0ludFwiXSA9IFwiWm9kQmlnSW50XCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RCb29sZWFuXCJdID0gXCJab2RCb29sZWFuXCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REYXRlXCJdID0gXCJab2REYXRlXCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RTeW1ib2xcIl0gPSBcIlpvZFN5bWJvbFwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVW5kZWZpbmVkXCJdID0gXCJab2RVbmRlZmluZWRcIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE51bGxcIl0gPSBcIlpvZE51bGxcIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEFueVwiXSA9IFwiWm9kQW55XCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RVbmtub3duXCJdID0gXCJab2RVbmtub3duXCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROZXZlclwiXSA9IFwiWm9kTmV2ZXJcIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFZvaWRcIl0gPSBcIlpvZFZvaWRcIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEFycmF5XCJdID0gXCJab2RBcnJheVwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kT2JqZWN0XCJdID0gXCJab2RPYmplY3RcIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFVuaW9uXCJdID0gXCJab2RVbmlvblwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGlzY3JpbWluYXRlZFVuaW9uXCJdID0gXCJab2REaXNjcmltaW5hdGVkVW5pb25cIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEludGVyc2VjdGlvblwiXSA9IFwiWm9kSW50ZXJzZWN0aW9uXCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RUdXBsZVwiXSA9IFwiWm9kVHVwbGVcIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFJlY29yZFwiXSA9IFwiWm9kUmVjb3JkXCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RNYXBcIl0gPSBcIlpvZE1hcFwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kU2V0XCJdID0gXCJab2RTZXRcIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEZ1bmN0aW9uXCJdID0gXCJab2RGdW5jdGlvblwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTGF6eVwiXSA9IFwiWm9kTGF6eVwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTGl0ZXJhbFwiXSA9IFwiWm9kTGl0ZXJhbFwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRW51bVwiXSA9IFwiWm9kRW51bVwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRWZmZWN0c1wiXSA9IFwiWm9kRWZmZWN0c1wiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTmF0aXZlRW51bVwiXSA9IFwiWm9kTmF0aXZlRW51bVwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kT3B0aW9uYWxcIl0gPSBcIlpvZE9wdGlvbmFsXCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdWxsYWJsZVwiXSA9IFwiWm9kTnVsbGFibGVcIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZERlZmF1bHRcIl0gPSBcIlpvZERlZmF1bHRcIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZENhdGNoXCJdID0gXCJab2RDYXRjaFwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUHJvbWlzZVwiXSA9IFwiWm9kUHJvbWlzZVwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQnJhbmRlZFwiXSA9IFwiWm9kQnJhbmRlZFwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUGlwZWxpbmVcIl0gPSBcIlpvZFBpcGVsaW5lXCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RSZWFkb25seVwiXSA9IFwiWm9kUmVhZG9ubHlcIjtcclxufSkoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kIHx8IChab2RGaXJzdFBhcnR5VHlwZUtpbmQgPSB7fSkpO1xyXG5jb25zdCBpbnN0YW5jZU9mVHlwZSA9IChcclxuLy8gY29uc3QgaW5zdGFuY2VPZlR5cGUgPSA8VCBleHRlbmRzIG5ldyAoLi4uYXJnczogYW55W10pID0+IGFueT4oXHJcbmNscywgcGFyYW1zID0ge1xyXG4gICAgbWVzc2FnZTogYElucHV0IG5vdCBpbnN0YW5jZSBvZiAke2Nscy5uYW1lfWAsXHJcbn0pID0+IGN1c3RvbSgoZGF0YSkgPT4gZGF0YSBpbnN0YW5jZW9mIGNscywgcGFyYW1zKTtcclxuY29uc3Qgc3RyaW5nVHlwZSA9IFpvZFN0cmluZy5jcmVhdGU7XHJcbmNvbnN0IG51bWJlclR5cGUgPSBab2ROdW1iZXIuY3JlYXRlO1xyXG5jb25zdCBuYW5UeXBlID0gWm9kTmFOLmNyZWF0ZTtcclxuY29uc3QgYmlnSW50VHlwZSA9IFpvZEJpZ0ludC5jcmVhdGU7XHJcbmNvbnN0IGJvb2xlYW5UeXBlID0gWm9kQm9vbGVhbi5jcmVhdGU7XHJcbmNvbnN0IGRhdGVUeXBlID0gWm9kRGF0ZS5jcmVhdGU7XHJcbmNvbnN0IHN5bWJvbFR5cGUgPSBab2RTeW1ib2wuY3JlYXRlO1xyXG5jb25zdCB1bmRlZmluZWRUeXBlID0gWm9kVW5kZWZpbmVkLmNyZWF0ZTtcclxuY29uc3QgbnVsbFR5cGUgPSBab2ROdWxsLmNyZWF0ZTtcclxuY29uc3QgYW55VHlwZSA9IFpvZEFueS5jcmVhdGU7XHJcbmNvbnN0IHVua25vd25UeXBlID0gWm9kVW5rbm93bi5jcmVhdGU7XHJcbmNvbnN0IG5ldmVyVHlwZSA9IFpvZE5ldmVyLmNyZWF0ZTtcclxuY29uc3Qgdm9pZFR5cGUgPSBab2RWb2lkLmNyZWF0ZTtcclxuY29uc3QgYXJyYXlUeXBlID0gWm9kQXJyYXkuY3JlYXRlO1xyXG5jb25zdCBvYmplY3RUeXBlID0gWm9kT2JqZWN0LmNyZWF0ZTtcclxuY29uc3Qgc3RyaWN0T2JqZWN0VHlwZSA9IFpvZE9iamVjdC5zdHJpY3RDcmVhdGU7XHJcbmNvbnN0IHVuaW9uVHlwZSA9IFpvZFVuaW9uLmNyZWF0ZTtcclxuY29uc3QgZGlzY3JpbWluYXRlZFVuaW9uVHlwZSA9IFpvZERpc2NyaW1pbmF0ZWRVbmlvbi5jcmVhdGU7XHJcbmNvbnN0IGludGVyc2VjdGlvblR5cGUgPSBab2RJbnRlcnNlY3Rpb24uY3JlYXRlO1xyXG5jb25zdCB0dXBsZVR5cGUgPSBab2RUdXBsZS5jcmVhdGU7XHJcbmNvbnN0IHJlY29yZFR5cGUgPSBab2RSZWNvcmQuY3JlYXRlO1xyXG5jb25zdCBtYXBUeXBlID0gWm9kTWFwLmNyZWF0ZTtcclxuY29uc3Qgc2V0VHlwZSA9IFpvZFNldC5jcmVhdGU7XHJcbmNvbnN0IGZ1bmN0aW9uVHlwZSA9IFpvZEZ1bmN0aW9uLmNyZWF0ZTtcclxuY29uc3QgbGF6eVR5cGUgPSBab2RMYXp5LmNyZWF0ZTtcclxuY29uc3QgbGl0ZXJhbFR5cGUgPSBab2RMaXRlcmFsLmNyZWF0ZTtcclxuY29uc3QgZW51bVR5cGUgPSBab2RFbnVtLmNyZWF0ZTtcclxuY29uc3QgbmF0aXZlRW51bVR5cGUgPSBab2ROYXRpdmVFbnVtLmNyZWF0ZTtcclxuY29uc3QgcHJvbWlzZVR5cGUgPSBab2RQcm9taXNlLmNyZWF0ZTtcclxuY29uc3QgZWZmZWN0c1R5cGUgPSBab2RFZmZlY3RzLmNyZWF0ZTtcclxuY29uc3Qgb3B0aW9uYWxUeXBlID0gWm9kT3B0aW9uYWwuY3JlYXRlO1xyXG5jb25zdCBudWxsYWJsZVR5cGUgPSBab2ROdWxsYWJsZS5jcmVhdGU7XHJcbmNvbnN0IHByZXByb2Nlc3NUeXBlID0gWm9kRWZmZWN0cy5jcmVhdGVXaXRoUHJlcHJvY2VzcztcclxuY29uc3QgcGlwZWxpbmVUeXBlID0gWm9kUGlwZWxpbmUuY3JlYXRlO1xyXG5jb25zdCBvc3RyaW5nID0gKCkgPT4gc3RyaW5nVHlwZSgpLm9wdGlvbmFsKCk7XHJcbmNvbnN0IG9udW1iZXIgPSAoKSA9PiBudW1iZXJUeXBlKCkub3B0aW9uYWwoKTtcclxuY29uc3Qgb2Jvb2xlYW4gPSAoKSA9PiBib29sZWFuVHlwZSgpLm9wdGlvbmFsKCk7XHJcbmNvbnN0IGNvZXJjZSA9IHtcclxuICAgIHN0cmluZzogKChhcmcpID0+IFpvZFN0cmluZy5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXHJcbiAgICBudW1iZXI6ICgoYXJnKSA9PiBab2ROdW1iZXIuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSkpLFxyXG4gICAgYm9vbGVhbjogKChhcmcpID0+IFpvZEJvb2xlYW4uY3JlYXRlKHtcclxuICAgICAgICAuLi5hcmcsXHJcbiAgICAgICAgY29lcmNlOiB0cnVlLFxyXG4gICAgfSkpLFxyXG4gICAgYmlnaW50OiAoKGFyZykgPT4gWm9kQmlnSW50LmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcclxuICAgIGRhdGU6ICgoYXJnKSA9PiBab2REYXRlLmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcclxufTtcclxuY29uc3QgTkVWRVIgPSBJTlZBTElEO1xyXG5cclxudmFyIHogPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XHJcbiAgICBfX3Byb3RvX186IG51bGwsXHJcbiAgICBkZWZhdWx0RXJyb3JNYXA6IGVycm9yTWFwLFxyXG4gICAgc2V0RXJyb3JNYXA6IHNldEVycm9yTWFwLFxyXG4gICAgZ2V0RXJyb3JNYXA6IGdldEVycm9yTWFwLFxyXG4gICAgbWFrZUlzc3VlOiBtYWtlSXNzdWUsXHJcbiAgICBFTVBUWV9QQVRIOiBFTVBUWV9QQVRILFxyXG4gICAgYWRkSXNzdWVUb0NvbnRleHQ6IGFkZElzc3VlVG9Db250ZXh0LFxyXG4gICAgUGFyc2VTdGF0dXM6IFBhcnNlU3RhdHVzLFxyXG4gICAgSU5WQUxJRDogSU5WQUxJRCxcclxuICAgIERJUlRZOiBESVJUWSxcclxuICAgIE9LOiBPSyxcclxuICAgIGlzQWJvcnRlZDogaXNBYm9ydGVkLFxyXG4gICAgaXNEaXJ0eTogaXNEaXJ0eSxcclxuICAgIGlzVmFsaWQ6IGlzVmFsaWQsXHJcbiAgICBpc0FzeW5jOiBpc0FzeW5jLFxyXG4gICAgZ2V0IHV0aWwgKCkgeyByZXR1cm4gdXRpbDsgfSxcclxuICAgIGdldCBvYmplY3RVdGlsICgpIHsgcmV0dXJuIG9iamVjdFV0aWw7IH0sXHJcbiAgICBab2RQYXJzZWRUeXBlOiBab2RQYXJzZWRUeXBlLFxyXG4gICAgZ2V0UGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZSxcclxuICAgIFpvZFR5cGU6IFpvZFR5cGUsXHJcbiAgICBkYXRldGltZVJlZ2V4OiBkYXRldGltZVJlZ2V4LFxyXG4gICAgWm9kU3RyaW5nOiBab2RTdHJpbmcsXHJcbiAgICBab2ROdW1iZXI6IFpvZE51bWJlcixcclxuICAgIFpvZEJpZ0ludDogWm9kQmlnSW50LFxyXG4gICAgWm9kQm9vbGVhbjogWm9kQm9vbGVhbixcclxuICAgIFpvZERhdGU6IFpvZERhdGUsXHJcbiAgICBab2RTeW1ib2w6IFpvZFN5bWJvbCxcclxuICAgIFpvZFVuZGVmaW5lZDogWm9kVW5kZWZpbmVkLFxyXG4gICAgWm9kTnVsbDogWm9kTnVsbCxcclxuICAgIFpvZEFueTogWm9kQW55LFxyXG4gICAgWm9kVW5rbm93bjogWm9kVW5rbm93bixcclxuICAgIFpvZE5ldmVyOiBab2ROZXZlcixcclxuICAgIFpvZFZvaWQ6IFpvZFZvaWQsXHJcbiAgICBab2RBcnJheTogWm9kQXJyYXksXHJcbiAgICBab2RPYmplY3Q6IFpvZE9iamVjdCxcclxuICAgIFpvZFVuaW9uOiBab2RVbmlvbixcclxuICAgIFpvZERpc2NyaW1pbmF0ZWRVbmlvbjogWm9kRGlzY3JpbWluYXRlZFVuaW9uLFxyXG4gICAgWm9kSW50ZXJzZWN0aW9uOiBab2RJbnRlcnNlY3Rpb24sXHJcbiAgICBab2RUdXBsZTogWm9kVHVwbGUsXHJcbiAgICBab2RSZWNvcmQ6IFpvZFJlY29yZCxcclxuICAgIFpvZE1hcDogWm9kTWFwLFxyXG4gICAgWm9kU2V0OiBab2RTZXQsXHJcbiAgICBab2RGdW5jdGlvbjogWm9kRnVuY3Rpb24sXHJcbiAgICBab2RMYXp5OiBab2RMYXp5LFxyXG4gICAgWm9kTGl0ZXJhbDogWm9kTGl0ZXJhbCxcclxuICAgIFpvZEVudW06IFpvZEVudW0sXHJcbiAgICBab2ROYXRpdmVFbnVtOiBab2ROYXRpdmVFbnVtLFxyXG4gICAgWm9kUHJvbWlzZTogWm9kUHJvbWlzZSxcclxuICAgIFpvZEVmZmVjdHM6IFpvZEVmZmVjdHMsXHJcbiAgICBab2RUcmFuc2Zvcm1lcjogWm9kRWZmZWN0cyxcclxuICAgIFpvZE9wdGlvbmFsOiBab2RPcHRpb25hbCxcclxuICAgIFpvZE51bGxhYmxlOiBab2ROdWxsYWJsZSxcclxuICAgIFpvZERlZmF1bHQ6IFpvZERlZmF1bHQsXHJcbiAgICBab2RDYXRjaDogWm9kQ2F0Y2gsXHJcbiAgICBab2ROYU46IFpvZE5hTixcclxuICAgIEJSQU5EOiBCUkFORCxcclxuICAgIFpvZEJyYW5kZWQ6IFpvZEJyYW5kZWQsXHJcbiAgICBab2RQaXBlbGluZTogWm9kUGlwZWxpbmUsXHJcbiAgICBab2RSZWFkb25seTogWm9kUmVhZG9ubHksXHJcbiAgICBjdXN0b206IGN1c3RvbSxcclxuICAgIFNjaGVtYTogWm9kVHlwZSxcclxuICAgIFpvZFNjaGVtYTogWm9kVHlwZSxcclxuICAgIGxhdGU6IGxhdGUsXHJcbiAgICBnZXQgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kICgpIHsgcmV0dXJuIFpvZEZpcnN0UGFydHlUeXBlS2luZDsgfSxcclxuICAgIGNvZXJjZTogY29lcmNlLFxyXG4gICAgYW55OiBhbnlUeXBlLFxyXG4gICAgYXJyYXk6IGFycmF5VHlwZSxcclxuICAgIGJpZ2ludDogYmlnSW50VHlwZSxcclxuICAgIGJvb2xlYW46IGJvb2xlYW5UeXBlLFxyXG4gICAgZGF0ZTogZGF0ZVR5cGUsXHJcbiAgICBkaXNjcmltaW5hdGVkVW5pb246IGRpc2NyaW1pbmF0ZWRVbmlvblR5cGUsXHJcbiAgICBlZmZlY3Q6IGVmZmVjdHNUeXBlLFxyXG4gICAgJ2VudW0nOiBlbnVtVHlwZSxcclxuICAgICdmdW5jdGlvbic6IGZ1bmN0aW9uVHlwZSxcclxuICAgICdpbnN0YW5jZW9mJzogaW5zdGFuY2VPZlR5cGUsXHJcbiAgICBpbnRlcnNlY3Rpb246IGludGVyc2VjdGlvblR5cGUsXHJcbiAgICBsYXp5OiBsYXp5VHlwZSxcclxuICAgIGxpdGVyYWw6IGxpdGVyYWxUeXBlLFxyXG4gICAgbWFwOiBtYXBUeXBlLFxyXG4gICAgbmFuOiBuYW5UeXBlLFxyXG4gICAgbmF0aXZlRW51bTogbmF0aXZlRW51bVR5cGUsXHJcbiAgICBuZXZlcjogbmV2ZXJUeXBlLFxyXG4gICAgJ251bGwnOiBudWxsVHlwZSxcclxuICAgIG51bGxhYmxlOiBudWxsYWJsZVR5cGUsXHJcbiAgICBudW1iZXI6IG51bWJlclR5cGUsXHJcbiAgICBvYmplY3Q6IG9iamVjdFR5cGUsXHJcbiAgICBvYm9vbGVhbjogb2Jvb2xlYW4sXHJcbiAgICBvbnVtYmVyOiBvbnVtYmVyLFxyXG4gICAgb3B0aW9uYWw6IG9wdGlvbmFsVHlwZSxcclxuICAgIG9zdHJpbmc6IG9zdHJpbmcsXHJcbiAgICBwaXBlbGluZTogcGlwZWxpbmVUeXBlLFxyXG4gICAgcHJlcHJvY2VzczogcHJlcHJvY2Vzc1R5cGUsXHJcbiAgICBwcm9taXNlOiBwcm9taXNlVHlwZSxcclxuICAgIHJlY29yZDogcmVjb3JkVHlwZSxcclxuICAgIHNldDogc2V0VHlwZSxcclxuICAgIHN0cmljdE9iamVjdDogc3RyaWN0T2JqZWN0VHlwZSxcclxuICAgIHN0cmluZzogc3RyaW5nVHlwZSxcclxuICAgIHN5bWJvbDogc3ltYm9sVHlwZSxcclxuICAgIHRyYW5zZm9ybWVyOiBlZmZlY3RzVHlwZSxcclxuICAgIHR1cGxlOiB0dXBsZVR5cGUsXHJcbiAgICAndW5kZWZpbmVkJzogdW5kZWZpbmVkVHlwZSxcclxuICAgIHVuaW9uOiB1bmlvblR5cGUsXHJcbiAgICB1bmtub3duOiB1bmtub3duVHlwZSxcclxuICAgICd2b2lkJzogdm9pZFR5cGUsXHJcbiAgICBORVZFUjogTkVWRVIsXHJcbiAgICBab2RJc3N1ZUNvZGU6IFpvZElzc3VlQ29kZSxcclxuICAgIHF1b3RlbGVzc0pzb246IHF1b3RlbGVzc0pzb24sXHJcbiAgICBab2RFcnJvcjogWm9kRXJyb3JcclxufSk7XHJcblxyXG5leHBvcnQgeyBCUkFORCwgRElSVFksIEVNUFRZX1BBVEgsIElOVkFMSUQsIE5FVkVSLCBPSywgUGFyc2VTdGF0dXMsIFpvZFR5cGUgYXMgU2NoZW1hLCBab2RBbnksIFpvZEFycmF5LCBab2RCaWdJbnQsIFpvZEJvb2xlYW4sIFpvZEJyYW5kZWQsIFpvZENhdGNoLCBab2REYXRlLCBab2REZWZhdWx0LCBab2REaXNjcmltaW5hdGVkVW5pb24sIFpvZEVmZmVjdHMsIFpvZEVudW0sIFpvZEVycm9yLCBab2RGaXJzdFBhcnR5VHlwZUtpbmQsIFpvZEZ1bmN0aW9uLCBab2RJbnRlcnNlY3Rpb24sIFpvZElzc3VlQ29kZSwgWm9kTGF6eSwgWm9kTGl0ZXJhbCwgWm9kTWFwLCBab2ROYU4sIFpvZE5hdGl2ZUVudW0sIFpvZE5ldmVyLCBab2ROdWxsLCBab2ROdWxsYWJsZSwgWm9kTnVtYmVyLCBab2RPYmplY3QsIFpvZE9wdGlvbmFsLCBab2RQYXJzZWRUeXBlLCBab2RQaXBlbGluZSwgWm9kUHJvbWlzZSwgWm9kUmVhZG9ubHksIFpvZFJlY29yZCwgWm9kVHlwZSBhcyBab2RTY2hlbWEsIFpvZFNldCwgWm9kU3RyaW5nLCBab2RTeW1ib2wsIFpvZEVmZmVjdHMgYXMgWm9kVHJhbnNmb3JtZXIsIFpvZFR1cGxlLCBab2RUeXBlLCBab2RVbmRlZmluZWQsIFpvZFVuaW9uLCBab2RVbmtub3duLCBab2RWb2lkLCBhZGRJc3N1ZVRvQ29udGV4dCwgYW55VHlwZSBhcyBhbnksIGFycmF5VHlwZSBhcyBhcnJheSwgYmlnSW50VHlwZSBhcyBiaWdpbnQsIGJvb2xlYW5UeXBlIGFzIGJvb2xlYW4sIGNvZXJjZSwgY3VzdG9tLCBkYXRlVHlwZSBhcyBkYXRlLCBkYXRldGltZVJlZ2V4LCB6IGFzIGRlZmF1bHQsIGVycm9yTWFwIGFzIGRlZmF1bHRFcnJvck1hcCwgZGlzY3JpbWluYXRlZFVuaW9uVHlwZSBhcyBkaXNjcmltaW5hdGVkVW5pb24sIGVmZmVjdHNUeXBlIGFzIGVmZmVjdCwgZW51bVR5cGUgYXMgZW51bSwgZnVuY3Rpb25UeXBlIGFzIGZ1bmN0aW9uLCBnZXRFcnJvck1hcCwgZ2V0UGFyc2VkVHlwZSwgaW5zdGFuY2VPZlR5cGUgYXMgaW5zdGFuY2VvZiwgaW50ZXJzZWN0aW9uVHlwZSBhcyBpbnRlcnNlY3Rpb24sIGlzQWJvcnRlZCwgaXNBc3luYywgaXNEaXJ0eSwgaXNWYWxpZCwgbGF0ZSwgbGF6eVR5cGUgYXMgbGF6eSwgbGl0ZXJhbFR5cGUgYXMgbGl0ZXJhbCwgbWFrZUlzc3VlLCBtYXBUeXBlIGFzIG1hcCwgbmFuVHlwZSBhcyBuYW4sIG5hdGl2ZUVudW1UeXBlIGFzIG5hdGl2ZUVudW0sIG5ldmVyVHlwZSBhcyBuZXZlciwgbnVsbFR5cGUgYXMgbnVsbCwgbnVsbGFibGVUeXBlIGFzIG51bGxhYmxlLCBudW1iZXJUeXBlIGFzIG51bWJlciwgb2JqZWN0VHlwZSBhcyBvYmplY3QsIG9iamVjdFV0aWwsIG9ib29sZWFuLCBvbnVtYmVyLCBvcHRpb25hbFR5cGUgYXMgb3B0aW9uYWwsIG9zdHJpbmcsIHBpcGVsaW5lVHlwZSBhcyBwaXBlbGluZSwgcHJlcHJvY2Vzc1R5cGUgYXMgcHJlcHJvY2VzcywgcHJvbWlzZVR5cGUgYXMgcHJvbWlzZSwgcXVvdGVsZXNzSnNvbiwgcmVjb3JkVHlwZSBhcyByZWNvcmQsIHNldFR5cGUgYXMgc2V0LCBzZXRFcnJvck1hcCwgc3RyaWN0T2JqZWN0VHlwZSBhcyBzdHJpY3RPYmplY3QsIHN0cmluZ1R5cGUgYXMgc3RyaW5nLCBzeW1ib2xUeXBlIGFzIHN5bWJvbCwgZWZmZWN0c1R5cGUgYXMgdHJhbnNmb3JtZXIsIHR1cGxlVHlwZSBhcyB0dXBsZSwgdW5kZWZpbmVkVHlwZSBhcyB1bmRlZmluZWQsIHVuaW9uVHlwZSBhcyB1bmlvbiwgdW5rbm93blR5cGUgYXMgdW5rbm93biwgdXRpbCwgdm9pZFR5cGUgYXMgdm9pZCwgeiB9O1xyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/zod/lib/index.mjs\n");

/***/ })

};
;